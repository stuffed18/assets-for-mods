(()=>{
    var e = {
        338: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.checkpoint {\r\n\tposition: absolute;\r\n\tbottom: 0;\r\n\tleft: 0;\r\n\tmargin: 0;\r\n\tpadding: 8px 10px 8px 8px;\r\n\tline-height: 0;\r\n\tfont-size: 40px;\r\n\tcolor: var(--text-color);\r\n\ttext-align: left;\r\n\topacity: 0.9;\r\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\r\n\tbackground-color: var(--surface-color);\r\n}\r\n.checkpoint.up {\r\n\tposition: absolute;\r\n\tbottom: auto;\r\n\ttop: 0;\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n}\r\n\r\n.checkpoint > div {\r\n\tmargin: 0;\r\n\tpadding: 0 16px 0 16px;\r\n\tclip-path: polygon(0 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\r\n\tbackground-color: var(--surface-tertiary-color);\r\n}\r\n.checkpoint.up > div {\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 0 100%);\r\n}\r\n\r\n.checkpoint > div > img {\r\n\tmargin: 0 12px 5px 0;\r\n\tpadding: 0;\r\n\twidth: 24px;\r\n\theight: 24px;\r\n\tvertical-align: middle;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        416: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.color-picker {\r\n\tmargin: 8px;\r\n}\r\n\r\n.color-picker > .value-saturation-picker {\r\n\tposition: relative;\r\n\tmargin: 0 0 8px 0;\r\n\twidth: 140px;\r\n\theight: 140px;\r\n\tbackground-color: #fff;\r\n\toverflow: hidden;\r\n}\r\n\r\n.color-picker > .value-saturation-picker > .marker {\r\n\tposition: absolute;\r\n\twidth: 12px;\r\n\theight: 12px;\r\n\tbackground-image: radial-gradient(closest-side, transparent, #000, #fff, #000, transparent);\r\n}\r\n\r\n.color-picker > .hue-picker {\r\n\tposition: relative;\r\n\twidth: 140px;\r\n\theight: 30px;\r\n\tbackground-image: linear-gradient(to right, \r\n\t\thsl(0, 100%, 50%),\r\n\t\thsl(60, 100%, 50%),\r\n\t\thsl(120, 100%, 50%),\r\n\t\thsl(180, 100%, 50%),\r\n\t\thsl(240, 100%, 50%),\r\n\t\thsl(300, 100%, 50%),\r\n\t\thsl(0, 100%, 50%)\r\n\t);\r\n\toverflow: hidden;\r\n}\r\n\r\n.color-picker > .hue-picker > .marker {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\theight: 100%;\r\n\twidth: 3px;\r\n\tbackground-image: linear-gradient(to right, #000, #fff, #000);\r\n}\r\n", ""]);
            const o = s
        }
        ,
        27: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.customization {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n}\r\n\r\n.customization > .top {\r\n\tdisplay: block;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n.customization > .top > .button {\r\n\tdisplay: inline-block;\r\n\tmargin: 8px 0;\r\n}\r\n.customization > .top > .button:first-of-type {\r\n\tmargin-left: 8px;\r\n}\r\n\r\n.customization > .colors {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\twidth: 100%;\r\n\ttext-align: center;\r\n\twhite-space: nowrap;\r\n}\r\n\r\n.customization > .colors > div {\r\n\tdisplay: inline-block;\r\n\tmargin: 0 10px;\r\n\tpadding: 0;\r\n\ttext-align: center;\r\n\tbackground: var(--surface-color);\r\n\tpointer-events: auto;\r\n}\r\n.customization > .colors > div > h2 {\r\n\tmargin: 0;\r\n\tpadding: 2px;\r\n\tfont-size: 26px;\r\n\tfont-weight: normal;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\tcolor: var(--text-color);\r\n}\r\n.customization > .colors > div > input {\r\n\tmargin: 8px 8px 0 8px;\r\n\twidth: calc(140px - 8px * 2);\r\n\tfont-weight: normal;\r\n\tclip-path: none;\r\n\ttext-align: center;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        486: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.debug {\r\n\tmargin: 0.25em;\r\n\tpadding: 0;\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\tfont-size: 28px;\r\n\ttext-shadow: 0 0 5px #000;\r\n\tcolor: #fff;\r\n\tz-index: 10;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        986: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.editor {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n}\r\n\r\n.editor > .top {\r\n\tdisplay: block;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n}\r\n\r\n.editor > .top > .button-bar {\r\n\tmargin: 0;\r\n\tpadding: 0 0 0 8px;\r\n\theight: 68px;\r\n\tbackground-color: var(--surface-color);\r\n\twhite-space: nowrap;\r\n}\r\n.editor > .top > .button-bar > .button {\r\n\tmargin: 8px 0;\r\n}\r\n\r\n.editor > .top > .trackname-input {\r\n\tdisplay: inline-block;\r\n\tmargin: 0;\r\n\tpadding: 6px 7px;\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 10px) 100%, 0 100%);\r\n\tfont-size: 30px;\r\n\tcolor: var(--text-color);\r\n\tbackground: var(--surface-secondary-color);\r\n}\r\n.editor > .top > .trackname-input > input {\r\n\tfont-weight: normal;\r\n\tfont-size: 30px;\r\n}\r\n\r\n.editor > .side {\r\n\tposition: absolute;\r\n\ttop: 68px;\r\n\tright: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\theight: calc(100% - 68px);\r\n\tdisplay: flex;\r\n\talign-items: end;\r\n}\r\n\r\n.editor > .side > .side-panel {\r\n\theight: 100%;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\tpointer-events: auto;\r\n}\r\n\r\n.editor > .side > .side-panel > .category-panel, .editor > .side > .side-panel > .part-panel {\r\n\tdisplay: inline-block;\r\n\tvertical-align: top;\r\n\tpadding: 2px 2px 0 2px;\r\n\theight: 100%;\r\n\tbox-sizing: border-box;\r\n\toverflow-x: hidden;\r\n\toverflow-y: scroll;\r\n\tscrollbar-width: thin;\r\n}\r\n.editor > .side > .side-panel > .category-panel > button > img {\r\n\twidth: 96px;\r\n}\r\n.editor > .side > .side-panel > .part-panel.hidden {\r\n\tdisplay: none;\r\n}\r\n\r\n.editor > .side > .side-panel button {\r\n\tdisplay: block;\r\n\tmargin: 0 0 2px 0;\r\n\tpadding: 5px;\r\n\tbackground-color: var(--button-color);\r\n\tborder: 2px solid rgb(38, 31, 88);\r\n\tcursor: pointer;\r\n}\r\n@media (hover: hover) {\r\n\t.editor > .side > .side-panel button:hover {\r\n\t\tbackground-color: var(--button-hover-color);\r\n\t}\r\n}\r\n.editor > .side > .side-panel button:active {\r\n\tbackground-color: var(--button-active-color);\r\n}\r\n.editor > .side > .side-panel button.selected {\r\n\tbackground-color: var(--button-hover-color);\r\n\tbox-shadow: inset 0 0 5px #fff;\r\n\tborder: 2px solid #fff;\r\n}\r\n.editor > .side > .side-panel button > img {\r\n\tdisplay: block;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 64px;\r\n\t-webkit-filter: drop-shadow(0 0 2px #000);\r\n\tfilter: drop-shadow(0 0 2px #000);\r\n\tpointer-events: none;\r\n}\r\n\r\n.editor > .message-box {\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\tposition: absolute;\r\n\tfont-size: 30px;\r\n\tcolor: #ff9696;\r\n\ttext-shadow: 0 0 5px #000;\r\n\tpointer-events: none;\r\n\r\n\tleft: -10px;\r\n\topacity: 0;\r\n}\r\n.editor > .message-box.green {\r\n\tcolor: #96ff96;\r\n}\r\n.editor > .message-box.show {\r\n\tleft: 0;\r\n\topacity: 1;\r\n\ttransition: opacity 0.25s ease-in-out, left 0.25s ease-in-out;\r\n}\r\n.editor > .message-box.hide {\r\n\tleft: 0;\r\n\topacity: 0;\r\n\ttransition: opacity 0.25s ease-in-out, left 0.25s ease-in-out;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        990: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.editor-checkpoint-order > .buttons {\r\n\tdisplay: inline-block;\r\n\tvertical-align: bottom;\r\n}\r\n.editor-checkpoint-order > .buttons > button {\r\n\tdisplay: block;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tborder: none;\r\n\tbackground-color: var(--button-color);\r\n\tpointer-events: auto;\r\n\tcursor: pointer;\r\n}\r\n@media (hover: hover) {\r\n\t.editor-checkpoint-order > .buttons > button:hover {\r\n\t\tbackground-color: var(--button-hover-color);\r\n\t}\r\n}\r\n.editor-checkpoint-order > .buttons > button:active {\r\n\tbackground-color: var(--button-active-color);\r\n}\r\n\r\n.editor-checkpoint-order > .buttons > button > img {\r\n\tmargin: 0;\r\n\tpadding: 0 6px;\r\n\twidth: 20px;\r\n\theight: 20px;\r\n\tvertical-align: bottom;\r\n}\r\n.editor-checkpoint-order.touch > .buttons > button > img {\r\n\tpadding: 24px;\r\n\twidth: 40px;\r\n\theight: 40px;\r\n}\r\n\r\n.editor-checkpoint-order > p {\r\n\tmargin: 0;\r\n\tpadding: 0 10px;\r\n\tdisplay: inline-block;\r\n\tvertical-align: bottom;\r\n\tline-height: 40px;\r\n\tmin-width: 275px;\r\n\tfont-size: 26px;\r\n\ttext-align: center;\r\n\tbackground-color: var(--surface-transparent-color);\r\n\tcolor: var(--text-color);\r\n}\r\n.editor-checkpoint-order.touch > p {\r\n\tline-height: calc((40px + 2 * 24px) * 2);\r\n}\r\n", ""]);
            const o = s
        }
        ,
        697: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.editor-height-selector {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n}\r\n\r\n.editor-height-selector > .buttons {\r\n\tdisplay: inline-block;\r\n\tvertical-align: bottom;\r\n}\r\n.editor-height-selector > .buttons > button {\r\n\tdisplay: block;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tborder: none;\r\n\tbackground-color: var(--button-color);\r\n\tpointer-events: auto;\r\n\tcursor: pointer;\r\n}\r\n@media (hover: hover) {\r\n\t.editor-height-selector > .buttons > button:hover {\r\n\t\tbackground-color: var(--button-hover-color);\r\n\t}\r\n}\r\n.editor-height-selector > .buttons > button:active {\r\n\tbackground-color: var(--button-active-color);\r\n}\r\n\r\n.editor-height-selector > .buttons > button > img { \r\n\tmargin: 0;\r\n\tpadding: 0 6px;\r\n\twidth: 20px;\r\n\theight: 20px;\r\n\tvertical-align: bottom;\r\n}\r\n.editor-height-selector.touch > .buttons > button > img {\r\n\tpadding: 24px;\r\n\twidth: 40px;\r\n\theight: 40px;\r\n}\r\n\r\n.editor-height-selector > p {\r\n\tmargin: 0;\r\n\tpadding: 0 10px;\r\n\tdisplay: inline-block;\r\n\tvertical-align: bottom;\r\n\tline-height: 40px;\r\n\tmin-width: 140px;\r\n\tfont-size: 26px;\r\n\ttext-align: center;\r\n\tbackground-color: var(--surface-transparent-color);\r\n\tcolor: var(--text-color);\r\n}\r\n.editor-height-selector.touch > p {\r\n\tline-height: calc((40px + 2 * 24px) * 2);\r\n}\r\n", ""]);
            const o = s
        }
        ,
        353: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.editor-touch-controls > button {\r\n\tposition: absolute;\r\n\tbottom: 176px;\r\n\tleft: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 160px;\r\n\theight: 160px;\r\n\tbackground-color: var(--button-color);\r\n\tborder: none;\r\n\topacity: 0.6;\r\n\tpointer-events: auto;\r\n}\r\n.editor-touch-controls > button  > img {\r\n\tmargin: 0;\r\n\tpadding: 30px;\r\n\tvertical-align: top;\r\n\twidth: 100%;\r\n    height: 100%;\r\n\tbox-sizing: border-box;\r\n\tpointer-events: none;\r\n\ttransition: padding 0.25s ease-out;\r\n}\r\n.editor-touch-controls > button.active > img {\r\n    padding: 40px;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        57: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.game-toolbar {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\tpadding: 8px 10px 8px 8px;\r\n\tbackground-color: var(--surface-color);\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\topacity: 0;\r\n\ttransform: translateX(-10px);\r\n\ttransition: opacity ease-in-out 0.2s, transform ease-in-out 0.2s;\r\n}\r\n.game-toolbar.up {\r\n\tposition: absolute;\r\n\tbottom: auto;\r\n\ttop: 0;\r\n}\r\n\r\n.game-toolbar.visible {\r\n\topacity: 1;\r\n\ttransform: translateX(0);\r\n\ttransition: opacity 0.2s ease-in-out 0.5s, transform 0.2s ease-in-out 0.5s;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        197: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.hint {\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 90px;\r\n\twidth: 100%;\r\n\ttext-align: center;\r\n\tfont-size: 40px;\r\n\tcolor: #fff;\r\n\ttext-shadow: 0 0 5px #000;\r\n\tpointer-events: none;\r\n\r\n\topacity: 0;\r\n}\r\n.hint.show {\r\n\ttop: 100px;\r\n\topacity: 1;\r\n\ttransition: opacity 0.25s ease-in-out, top 0.25s ease-in-out;\r\n}\r\n.hint.hide {\r\n\ttop: 90px;\r\n\topacity: 0;\r\n\ttransition: opacity 0.25s ease-in-out, top 0.25s ease-in-out;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        132: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.input-visualizer {\r\n    position: absolute;\r\n    left: 0;\r\n    bottom: 64px;\r\n    margin: 10px;\r\n    padding: 0;\r\n    --size: 96px;\r\n    width: calc(var(--size) * 3);\r\n    height: calc(var(--size) * 2);\r\n    opacity: 0.9;\r\n}\r\n\r\n.input-visualizer > div {\r\n    position: absolute;\r\n    margin: 0;\r\n    padding: 0;\r\n    width: var(--size);\r\n    height: var(--size);\r\n    background-color: var(--surface-color);\r\n}\r\n\r\n.input-visualizer > .arrow-up {\r\n    left: var(--size);\r\n    top: 0;\r\n}\r\n\r\n.input-visualizer > .arrow-right {\r\n    left: calc(var(--size) * 2);\r\n    top: var(--size);\r\n}\r\n\r\n.input-visualizer > .arrow-down {\r\n    left: var(--size);\r\n    top: var(--size);\r\n}\r\n\r\n.input-visualizer > .arrow-left {\r\n    left: 0;\r\n    top: var(--size);\r\n}\r\n\r\n.input-visualizer > div.active {\r\n    background-color: var(--surface-tertiary-color);\r\n}\r\n\r\n.input-visualizer > div > img {\r\n    margin: 0;\r\n    padding: 20px;\r\n    width: 100%;\r\n    height: 100%;\r\n    box-sizing: border-box;\r\n}\r\n.input-visualizer > div.active > img {\r\n    padding: 25px;\r\n}", ""]);
            const o = s
        }
        ,
        937: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.leaderboard {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 600px;\r\n\theight: 100%;\r\n\ttext-align: left;\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.leaderboard > h2 {\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\tfont-weight: normal;\r\n\tfont-size: 38px;\r\n\ttext-align: center;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.leaderboard > .container {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tflex-grow: 1;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\toverflow-y: scroll;\r\n\tpointer-events: auto;\r\n}\r\n\r\n.leaderboard > .container > .loading-spinner {\r\n\tmargin: 50% auto;\r\n}\r\n\r\n.leaderboard > .container > .error-message {\r\n\tfont-size: 20px;\r\n\ttext-align: center;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.leaderboard > .container > .buttons {\r\n\tposition: relative;\r\n\tmargin: 10px 10px 0 10px;\r\n\tpadding: 0;\r\n}\r\n\r\n.leaderboard > .container > .buttons:last-of-type {\r\n\tmargin-bottom: 10px;\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tvertical-align: top;\r\n\twidth: 100%;\r\n\theight: 100px;\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\ttext-align: left;\r\n\twhite-space: nowrap;\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main:disabled {\r\n\tbackground-color: var(--button-hover-color);\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main > img {\r\n\tbackground-color: rgba(0, 0, 0, 0.1);\r\n\twidth: 100px;\r\n\theight: 100px;\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main > .left, .leaderboard > .container > .buttons > button.main > .right {\r\n\tdisplay: inline-block;\r\n\tvertical-align: top;\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main > div > p {\r\n\tmargin: 0;\r\n\tpadding: 12px;\r\n\tfont-size: 28px;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main > div > .name {\r\n\ttext-overflow: ellipsis;\r\n\toverflow: hidden;\r\n\twidth: 260px;\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.main > div > .verified-state {\r\n\topacity: 0.8;\r\n\tposition: absolute;\r\n\tright: 6px;\r\n\tmargin: 6px 0 0 0;\r\n\tfont-size: 18px;\r\n}\r\n.leaderboard > .container > .buttons > button.main > div > .verified-state > img {\r\n\tmargin: 0 0 0 2px;\r\n\tpadding: 0;\r\n\theight: 12px;\r\n\tvertical-align: middle;\r\n}\r\n.leaderboard > .container > .buttons > button.main > div > .verified-state.verified {\r\n\tcolor: #5f5;\r\n}\r\n.leaderboard > .container > .buttons > button.main > div > .verified-state.invalid {\r\n\tcolor: #f55;\r\n}\r\n.leaderboard > .container > .buttons > button.main > div > .verified-state.pending {\r\n\tcolor: #ff5;\r\n}\r\n\r\n.leaderboard > .container > .buttons > button.preview {\r\n\tposition: absolute;\r\n\tright: 0;\r\n\ttop: 0;\r\n\tmargin: 8px;\r\n\tpadding: 0 9px;\r\n\tbackground-color: var(--surface-color);\r\n\tclip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);\r\n}\r\n.leaderboard > .container > .buttons > button.preview > img {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 16px;\r\n}\r\n\r\n.leaderboard > .pages {\r\n\tmargin: 10px 10px 0 10px;\r\n\tdisplay: flex;\r\n\tflex-direction: row;\r\n}\r\n.leaderboard > .pages > button.page {\r\n\tpadding: 0;\r\n\twidth: 0;\r\n\tflex-grow: 1;\r\n}\r\n.leaderboard > .pages > button.selected {\r\n\tbackground-color: var(--button-hover-color);\r\n}\r\n\r\n.leaderboard > .button-wrapper > .back {\r\n\tmargin: 10px;\r\n}\r\n\r\n.leaderboard > .button-wrapper > .icon-button {\r\n\tmargin: 10px 0;\r\n\tfloat: right;\r\n}\r\n.leaderboard > .button-wrapper > .icon-button.first {\r\n\tmargin: 10px 10px 10px 0;\r\n}\r\n\r\n.leaderboard > .button-wrapper > .icon-button > img {\r\n\twidth: 28px;\r\n}\r\n.leaderboard > .button-wrapper > .icon-button.disabled > img, .leaderboard > .button-wrapper > .icon-button:disabled > img {\r\n\topacity: 0.25;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        50: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.loading-spinner {\r\n\twidth: 40px;\r\n\theight: 40px;\r\n\tborder-radius: 50%;\r\n\tborder: 5px solid var(--surface-tertiary-color);\r\n\tborder-left-color: var(--text-color);\r\n\r\n\tanimation: 1s linear infinite forwards loading-spinner-spin;\r\n}\r\n\r\n@keyframes loading-spinner-spin {\r\n\tfrom {\r\n\t\ttransform: rotate(0);\r\n\t}\r\n\tto {\r\n\t\ttransform: rotate(360deg);\r\n\t}\r\n}\r\n", ""]);
            const o = s
        }
        ,
        240: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.loading {\r\n\tmargin: 200px 0 0 0;\r\n\tpadding: 0;\r\n}\r\n\r\n.loading > p {\r\n\tmargin: 5px;\r\n\tpadding: 0;\r\n\tcolor: var(--text-color);\r\n\tfont-size: 32px;\r\n}\r\n\r\n.loading > div {\r\n\tmargin: 0 auto;\r\n\tpadding: 0;\r\n\twidth: 600px;\r\n\theight: 50px;\r\n\tbackground-color: var(--surface-color);\r\n\tclip-path: polygon(9px 0, 100% 0, calc(100% - 9px) 100%, 0 100%);\r\n\toverflow: hidden;\r\n}\r\n\r\n.loading > div > div {\r\n\tmargin: 15px 20px;\r\n\tpadding: 0;\r\n\twidth: 560px;\r\n\theight: 20px;\r\n\tclip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);\r\n\tbackground-color: #224;\r\n\tbox-shadow: inset 0 0 6px #000;\r\n}\r\n\r\n.loading > div > div > div {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 0;\r\n\theight: 100%;\r\n\tclip-path: polygon(2px 0, 100% 0, calc(100% - 2px) 100%, 0 100%);\r\n\tbackground-color: #fff;\r\n\tbox-shadow: inset 0 0 6px #000;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        828: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.menu {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: rgba(10,10,20,0.8);\r\n\ttext-align: center;\r\n}\r\n\r\n.menu > .logo {\r\n\tdisplay: block;\r\n\tmargin: 80px auto 180px auto;\r\n\tpadding: 0;\r\n\twidth: 1000px;\r\n\theight: 200px;\r\n\t-webkit-filter: drop-shadow(0 0 3px #000);\r\n\tfilter: drop-shadow(0 0 3px #000);\r\n}\r\n\r\n.menu .button-image {\r\n\tdisplay: inline-block;\r\n\tmargin: 10px 0;\r\n\tpadding: 0;\r\n\twidth: 200px;\r\n\theight: 200px;\r\n\tpointer-events: auto;\r\n}\r\n.menu .button-image > img {\r\n\tmargin: 40px 40px 0 40px;\r\n\tpadding: 0;\r\n\twidth: 96px;\r\n\ttransition: transform 0.2s ease-in-out;\r\n\tpointer-events: none;\r\n}\r\n@media (hover: hover) {\r\n\t.menu .button-image:not(:disabled):hover > img {\r\n\t\ttransform: translateY(-10px);\r\n\t}\r\n}\r\n.menu .button-image > p {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tcolor: var(--text-color);\r\n\tfont-size: 27px;\r\n}\r\n\r\n.menu > .bottom-buttons {\r\n\tmargin: 4px;\r\n\tpadding: 0;\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n}\r\n\r\n.menu > .bottom-buttons > .small {\r\n\tpadding: 6px 12px;\r\n\tclip-path: polygon(4px 0, 100% 0, calc(100% - 4px) 100%, 0 100%);\r\n\tfont-size: 22px;\r\n}\r\n.menu > .bottom-buttons > .small > img {\r\n\tvertical-align: middle;\r\n}\r\n\r\n.menu > .discord-link {\r\n\tdisplay: block;\r\n\tposition: absolute;\r\n\tright: 0;\r\n\tbottom: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tpointer-events: auto;\r\n}\r\n.menu > .discord-link > img {\r\n\tmargin: 8px 16px;\r\n\tpadding: 0;\r\n\theight: 40px;\r\n}\r\n\r\n.menu > .info {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\twidth: 100%;\r\n}\r\n.menu > .info > a {\r\n\tdisplay: block;\r\n\tmargin: 0 auto;\r\n\tpadding: 5px;\r\n\twidth: fit-content;\r\n\tcolor: var(--text-color);\r\n\ttext-decoration: none;\r\n\tfont-size: 20px;\r\n\tpointer-events: auto;\r\n}\r\n.menu > .info > a:hover, .menu > .info > a:focus-visible {\r\n\ttext-decoration: underline;\r\n\toutline: none;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        47: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.message-box > .background {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tz-index: 1;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: rgba(20, 20, 30, 0.5);\r\n\tpointer-events: auto;\r\n}\r\n\r\n.message-box > .box {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 500px / 2);\r\n\ttop: 30%;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 16px;\r\n\twidth: 500px;\r\n\tbox-sizing: border-box;\r\n\tbackground-color: var(--surface-color);\r\n\ttext-align: center;\r\n}\r\n\r\n.message-box > .box > p {\r\n\tmargin: 5px 0 20px 0;\r\n\tpadding: 0;\r\n\tmin-height: 50px;\r\n\tline-height: 0.9;\r\n\tfont-size: 32px;\r\n\toverflow-wrap: break-word;\r\n\twhite-space: pre-wrap;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.message-box.message > .box > button:first-of-type {\r\n\tdisplay: none;\r\n}\r\n\r\n.message-box.confirm > .box > button:first-of-type {\r\n\tfloat: left;\r\n}\r\n.message-box.confirm > .box > button:last-of-type {\r\n\tfloat: right;\r\n}\r\n\r\n.message-box > .box > button {\r\n\tmin-width: 140px;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        853: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.nickname {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 500px / 2);\r\n\ttop: 40%;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 16px;\r\n\twidth: 500px;\r\n\tbox-sizing: border-box;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.nickname > h1 {\r\n\tmargin: 0 4px 0 4px;\r\n\tpadding: 0;\r\n\tfont-size: 35px;\r\n\tfont-weight: normal;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.nickname > input[type=text] {\r\n\tdisplay: block;\r\n\tmargin: 0;\r\n\tpadding: 0.25em;\r\n\tbox-sizing: border-box;\r\n\twidth: 100%;\r\n\tfont-size: 36px;\r\n\tfont-weight: normal;\r\n}\r\n\r\n.nickname > p {\r\n\tmargin: 16px 4px 0 4px;\r\n\tpadding: 0;\r\n\tfont-size: 20px;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.nickname > button {\r\n\tdisplay: inline-block;\r\n\tmargin: 16px 0 0 0;\r\n}\r\n.nickname > button:last-of-type {\r\n\tfloat: right;\r\n}\r\n\r\n.nickname > button.delete {\r\n\tposition: absolute;\r\n\tright: 8px;\r\n\ttop: 0;\r\n\tfont-size: 16px;\r\n\tpadding: 8px 16px;\r\n}\r\n\r\n.nickname > button.delete > img.button-icon {\r\n\tmargin: -5px 0 -2px -3px;\r\n\theight: 16px;\r\n}\r\n\r\nbutton.nickname-verifier-button {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 22px;\r\n\tmargin: 0 4px;\r\n}\r\n\r\n.nickname-user-token {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\tmargin: 0 4px;\r\n\ttext-align: left;\r\n\tfont-size: 18px;\r\n\topacity: 0.5;\r\n\tcolor: var(--text-color);\r\n\tpointer-events: all;\r\n\t-webkit-user-select: all;\r\n\t-moz-user-select: all;\r\n\t-ms-user-select: all;\r\n\tuser-select: all;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        923: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.preview-toolbar {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\tpadding: 8px 10px 8px 8px;\r\n\tbackground-color: var(--surface-color);\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n}\r\n", ""]);
            const o = s
        }
        ,
        493: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.profile-selection {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 500px / 2);\r\n\ttop: 40%;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 500px;\r\n\tbox-sizing: border-box;\r\n\tbackground-color: var(--surface-secondary-color);\r\n}\r\n\r\n.profile-selection > .top-bar {\r\n\tmargin: 0;\r\n\tpadding: 10px;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.profile-selection > .top-bar > h2 {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tfont-weight: normal;\r\n\tfont-size: 38px;\r\n\ttext-align: center;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.profile-selection > .slot {\r\n\tposition: relative;\r\n\tmargin: 10px 10px 0 10px;\r\n\tpadding: 0;\r\n}\r\n\r\n.profile-selection > .slot > button.main {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tvertical-align: top;\r\n\twidth: 100%;\r\n\theight: 100px;\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\ttext-align: left;\r\n\twhite-space: nowrap;\r\n}\r\n\r\n.profile-selection > .slot > button.main.selected {\r\n\tbackground-color: var(--button-hover-color);\r\n}\r\n\r\n.profile-selection > .slot > button.main > img {\r\n\tbackground-color: rgba(0, 0, 0, 0.1);\r\n\twidth: 100px;\r\n\theight: 100px;\r\n\tpointer-events: none;\r\n}\r\n\r\n.profile-selection > .slot > button.main > .name {\r\n\tdisplay: inline-block;\r\n\tvertical-align: top;\r\n\tmargin: 0;\r\n\tpadding: 12px;\r\n\tfont-size: 28px;\r\n\tcolor: var(--text-color);\r\n\ttext-overflow: ellipsis;\r\n\toverflow: hidden;\r\n\twidth: 320px;\r\n}\r\n\r\n.profile-selection > .bottom-bar {\r\n\tmargin: 10px 0 0 0;\r\n\tpadding: 10px;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.profile-selection > .bottom-bar > .button.right {\r\n\tfloat: right;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        156: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, '\r\n.settings-menu {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 800px / 2);\r\n\ttop: 0;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 800px;\r\n\theight: 100%;\r\n\ttext-align: left;\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.settings-menu > h2 {\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\tfont-weight: normal;\r\n\tfont-size: 38px;\r\n\ttext-align: center;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.settings-menu > .container {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tflex-grow: 1;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\toverflow-y: scroll;\r\n\tpointer-events: auto;\r\n}\r\n\r\n.settings-menu > .container > h2 {\r\n\tmargin: 10px;\r\n\tpadding: 4px;\r\n\tfont-weight: normal;\r\n\tfont-size: 24px;\r\n\tcolor: var(--text-color);\r\n\tborder-bottom: 2px solid var(--text-color);\r\n}\r\n\r\n.settings-menu > .container > .setting {\r\n\tmargin: 10px;\r\n\tdisplay: flex;\r\n}\r\n\r\n.settings-menu > .container > .setting > p {\r\n\tdisplay: inline-block;\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\tmin-width: 0;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n\tflex-grow: 1;\r\n\tfont-size: 28px;\r\n\ttext-align: left;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.settings-menu > .container > .setting > .button-wrapper {\r\n\twhite-space: nowrap;\r\n}\r\n.settings-menu > .container > .setting.wrappable > .button-wrapper {\r\n\twhite-space: normal;\r\n}\r\n.settings-menu > .container > .setting.wrappable > .button-wrapper > button {\r\n\tmargin-bottom: 8px;\r\n\twidth: calc(100% / 4);\r\n\tfont-size: 23px;\r\n}\r\n\r\n.settings-menu > .container > .setting > .button-wrapper > button {\r\n\theight: 48px;\r\n\twhite-space: nowrap;\r\n}\r\n.settings-menu > .container > .setting > .button-wrapper > button.selected {\r\n\tbackground-color: var(--button-hover-color);\r\n}\r\n.settings-menu > .container > .setting > .button-wrapper > button.key-binding {\r\n\twidth: 210px;\r\n\tfont-size: 22px;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n\tvertical-align: top;\r\n}\r\n\r\n.settings-menu > .container > .setting > input[type="range"] {\r\n\tmargin: 0 20px;\r\n\tpadding: 0;\r\n\twidth: 390px;\r\n\t-webkit-appearance: none;\r\n\tappearance: none;\r\n\tbackground: transparent;\r\n\tcursor: pointer;\r\n\taccent-color: var(--text-color);\r\n}\r\n.settings-menu > .container > .setting > input[type="range"]::-webkit-slider-runnable-track {\r\n\tbackground-color: var(--surface-tertiary-color);\r\n\theight: 10px;\r\n}\r\n.settings-menu > .container > .setting > input[type="range"]::-moz-range-track {\r\n\tbackground-color: var(--surface-tertiary-color);\r\n\theight: 10px;\r\n}\r\n.settings-menu > .container > .setting > input[type="range"]::-webkit-slider-thumb {\r\n\t-webkit-appearance: none;\r\n\tappearance: none;\r\n\tborder-radius: 0;\r\n\tbackground: var(--text-color);\r\n\twidth: 32px;\r\n\theight: 32px;\r\n\tmargin: -13px 0 0 0;\r\n\tborder: 4px solid var(--button-color);\r\n\toutline: 2px solid var(--text-color);\r\n}\r\n@media (hover: hover) {\r\n\t.settings-menu > .container > .setting > input[type="range"]::-webkit-slider-thumb:hover {\r\n\t\tborder: 4px solid var(--button-hover-color);\r\n\t}\r\n}\r\n.settings-menu > .container > .setting > input[type="range"]::-webkit-slider-thumb:active {\r\n\tborder: 4px solid var(--button-active-color);\r\n}\r\n.settings-menu > .container > .setting > input[type="range"]::-moz-range-thumb {\r\n\t-webkit-appearance: none;\r\n\tappearance: none;\r\n\tborder-radius: 0;\r\n\tbackground: var(--text-color);\r\n\twidth: 24px;\r\n\theight: 24px;\r\n\tborder: 4px solid var(--button-color);\r\n\toutline: 2px solid var(--text-color);\r\n}\r\n@media (hover: hover) {\r\n\t.settings-menu > .container > .setting > input[type="range"]::-moz-range-thumb:hover {\r\n\t\tborder: 4px solid var(--button-hover-color);\r\n\t}\r\n}\r\n.settings-menu > .container > .setting > input[type="range"]::-moz-range-thumb:active {\r\n\tborder: 4px solid var(--button-active-color);\r\n}\r\n\r\n.settings-menu > .button-wrapper > .button {\r\n\tmargin: 10px 0;\r\n}\r\n\r\n.settings-menu > .button-wrapper > .button:first-of-type {\r\n\tmargin-left: 10px;\r\n}\r\n\r\n.settings-menu > .button-wrapper > .button:last-of-type {\r\n\tmargin-right: 10px;\r\n}\r\n\r\n.settings-menu > .button-wrapper > .button > img {\r\n\tmargin-top: -3px;\r\n}\r\n\r\n.settings-menu > .button-wrapper > .apply {\r\n\tfloat: right;\r\n}\r\n', ""]);
            const o = s
        }
        ,
        680: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.speedometer {\r\n\tposition: absolute;\r\n\tbottom: 0;\r\n\tright: 0;\r\n\tmargin: 0;\r\n\tpadding: 8px 8px 8px 10px;\r\n\tmin-width: 140px;\r\n\tline-height: 0;\r\n\tfont-size: 40px;\r\n\tcolor: var(--text-color);\r\n\ttext-align: right;\r\n\topacity: 0.9;\r\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\r\n\tbackground-color: var(--surface-color);\r\n}\r\n.speedometer.up {\r\n\tbottom: auto;\r\n\ttop: 0;\r\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%);\r\n}\r\n\r\n.speedometer > div {\r\n\tmargin: 0;\r\n\tpadding: 0 0 0 16px;\r\n\tclip-path: polygon(6px 0, 100% 0, 100% 100%, 0 100%);\r\n\tbackground-color: var(--surface-tertiary-color);\r\n}\r\n.speedometer.up > div {\r\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 6px 100%);\r\n}\r\n\r\n.speedometer > div > span:last-of-type {\r\n\topacity: 0.5;\r\n\tmargin: 0 0.3em 0 0.25em;\r\n\tpadding: 0;\r\n\tfont-size: 0.5em;\r\n}\r\n.speedometer > div > span > span {\r\n\tdisplay: inline-block;\r\n\twidth: 0.5em;\r\n\ttext-align: center;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        296: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>g
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)
              , o = n(667)
              , l = n.n(o)
              , c = new URL(n(264),n.b)
              , h = new URL(n(607),n.b)
              , d = new URL(n(553),n.b)
              , u = s()(r())
              , p = l()(c)
              , f = l()(h)
              , m = l()(d);
            u.push([e.id, "\r\n:root {\r\n\t--text-color: #fff;\r\n\t--text-disabled-color: #5d6a7c;\r\n\t--surface-color: #28346a;\r\n\t--surface-secondary-color: #212b58;\r\n\t--surface-tertiary-color: #192042;\r\n\t--surface-transparent-color: rgba(40, 52, 106, 0.5);\r\n\t--button-color: #112052;\r\n\t--button-hover-color: #334b77;\r\n\t--button-active-color: #151f41;\r\n\t--button-disabled-color: #313d53;\r\n}\r\n\r\n@font-face {\r\n\tfont-family: ForcedSquare;\r\n\tsrc:\r\n\t\turl(" + p + ') format("woff2"),\r\n\t\turl(' + f + ') format("woff"),\r\n\t\turl(' + m + ') format("truetype");\r\n}\r\n\r\nhtml, body {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\toverflow: hidden;\r\n\r\n\tbackground: #000;\r\n}\r\n\r\n* {\r\n\tfont-family: ForcedSquare, Arial, sans-serif;\r\n\tline-height: 1;\r\n}\r\n\r\n#screen {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n}\r\n\r\n#ui {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\ttransform-origin: 0 0;\r\n\tpointer-events: none;\r\n\t-webkit-tap-highlight-color: transparent;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n}\r\n\r\n::-webkit-scrollbar {\r\n\twidth: 8px;\r\n\tbackground-color: #223;\r\n}\r\n::-webkit-scrollbar-thumb {\r\n\tborder-radius: 4px;\r\n\tbackground-color: #7272c2;\r\n}\r\n\r\n::selection {\r\n\tbackground-color:  #5936d6;\r\n\tcolor:  #fff;\r\n}\r\n\r\nbody {\r\n\tscrollbar-color: #7272c2 #223;\r\n}\r\n\r\n.hide-cursor {\r\n\tcursor: none;\r\n}\r\n\r\n.hidden {\r\n\tdisplay: none;\r\n}\r\n\r\ninput[type="text"] {\r\n\tmargin: 0;\r\n\tpadding: 4px 8px;\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\tfont-size: 24px;\r\n\tfont-weight: bold;\r\n\tcolor: var(--text-color);\r\n\tbackground-color: var(--surface-tertiary-color);\r\n\tborder: none;\r\n\tpointer-events:auto;\r\n}\r\ninput[type="text"]:focus-visible {\r\n\toutline: none;\r\n}\r\n\r\n.button {\r\n\tposition: relative;\r\n\tmargin: 0;\r\n\tpadding: 8px 18px;\r\n\tbackground-color: var(--button-color);\r\n\tborder: none;\r\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\tcolor: var(--text-color);\r\n\tfont-size: 32px;\r\n\r\n\tpointer-events: auto;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tcursor: pointer;\r\n}\r\n.button::after {\r\n\tcontent: "";\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\tbottom: 0;\r\n\tz-index: -1;\r\n\twidth: 0;\r\n\theight: 100%;\r\n\tbackground-color: var(--button-hover-color);\r\n\tborder-bottom: 2px solid var(--text-color);\r\n\ttransition: width 0.1s ease-in-out;\r\n}\r\n@media (hover: hover) {\r\n\t.button:hover::after {\r\n\t\twidth: 100%;\r\n\t}\r\n}\r\n@media not all and (hover: hover) {\r\n\t.button::after {\r\n\t\tbackground-color: var(--button-active-color);\r\n\t}\r\n}\r\n.button:active::after {\r\n\tbackground-color: var(--button-active-color);\r\n\twidth: 100%;\r\n}\r\n.button:focus-visible {\r\n\tbackground-color: var(--button-hover-color);\r\n\ttext-decoration: underline;\r\n\toutline: none;\r\n}\r\n.button > img.button-icon {\r\n\tmargin: -6px -4px 0 -4px;\r\n\tpadding: 0;\r\n\theight: 32px;\r\n\tvertical-align: middle;\r\n\tpointer-events: none;\r\n}\r\n.button:disabled {\r\n\tbackground-color: var(--button-disabled-color);\r\n\tcolor: var(--text-disabled-color);\r\n\tcursor: default;\r\n}\r\n.button:disabled:after {\r\n\tcontent: none;\r\n}\r\n', ""]);
            const g = u
        }
        ,
        894: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.time-announcer {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 35%;\r\n\twidth: 100%;\r\n\toverflow: hidden;\r\n}\r\n\r\n.time-announcer > .record {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tfont-size: 48px;\r\n\ttext-shadow: 0 0 5px #000;\r\n\tcolor: #5f5;\r\n\ttext-align: center;\r\n\topacity: 0;\r\n\tanimation: 0.3s ease-out 0.8s 1 normal forwards running time-announcer-record-animation;\r\n}\r\n\r\n.time-announcer > .track-name {\r\n\tmargin: 0 0 10px 0;\r\n\tpadding: 4px 20px;\r\n\tbox-sizing: border-box;\r\n\twidth: 100%;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\tfont-size: 60px;\r\n\tcolor: var(--text-color);\r\n\ttext-align: center;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n\tanimation: 0.3s ease-out 0s 1 normal forwards running time-announcer-animation;\r\n}\r\n\r\n.time-announcer > .current {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 0;\r\n\tbackground-color: var(--surface-color);\r\n\tfont-size: 48px;\r\n\tcolor: var(--text-color);\r\n\ttext-align: center;\r\n\tanimation: 0.5s ease-out 0s 1 normal forwards running time-announcer-animation;\r\n}\r\n.time-announcer > .difference > p {\r\n\tmargin: 0 0 0 auto;\r\n\tpadding: 0;\r\n\twidth: 0;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\tcolor: #5f5;\r\n\tfont-size: 30px;\r\n\ttext-align: center;\r\n\tanimation: 0.4s ease-out 0.5s 1 normal forwards running time-announcer-animation;\r\n}\r\n.time-announcer > .difference.red > p {\r\n\tcolor: #f55;\r\n}\r\n.time-announcer > .difference > p.title {\r\n\tmargin-top: 30px;\r\n\tbackground-color: transparent;\r\n\ttext-shadow: 0 0 3px #000;\r\n}\r\n\r\n@keyframes time-announcer-record-animation {\r\n\tfrom {\r\n\t\topacity: 0;\r\n\t\ttransform: translateY(10px);\r\n\t}\r\n\r\n\tto {\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n\r\n@keyframes time-announcer-animation {\r\n\tfrom {\r\n\t\twidth: 0;\r\n\t\topacity: 0;\r\n\t}\r\n\r\n\tto {\r\n\t\twidth: 100%;\r\n\t\topacity: 1;\r\n\t}\r\n}\r\n", ""]);
            const o = s
        }
        ,
        521: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.time-bar {\r\n\tdisplay: flex;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 100%;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.time-bar > button {\r\n\tmargin: 6px;\r\n\tpadding: 4px 12px;\r\n}\r\n.time-bar > button > img {\r\n\tmargin: 0 0 2px 0;\r\n\tpadding: 0;\r\n\tvertical-align: middle;\r\n\twidth: 28px;\r\n\theight: 28px;\r\n}\r\n\r\n.time-bar > .bar {\r\n\tposition: relative;\r\n\tmargin: 6px 6px 6px -8px;\r\n\tpadding: 0;\r\n\tflex-grow: 1;\r\n\theight: 40px;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\ttouch-action: none;\r\n\tpointer-events: auto;\r\n}\r\n.time-bar > .bar > div {\r\n\tposition: relative;\r\n\twidth: calc(100% - 8px);\r\n\theight: 100%;\r\n}\r\n.time-bar > .bar > div > .unloaded-fill {\r\n\tposition: absolute;\r\n\tright: -8px;\r\n\ttop: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\theight: 100%;\r\n\tbackground-color: rgba(255, 255, 255, 0.1);\r\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\twill-change: width;\r\n}\r\n.time-bar > .bar > div > .fill {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\theight: 100%;\r\n\tbackground-color: #7272c2;\r\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\twill-change: width;\r\n}\r\n.time-bar > .bar > div > .dash {\r\n\tposition: absolute;\r\n\tz-index: 1;\r\n\tbottom: 0;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 2px;\r\n\theight: 25%;\r\n\tbackground-color: rgba(0,0,0,0.25);\r\n}\r\n.time-bar > .bar > div > .dash.long {\r\n\theight: 50%;\r\n\tbackground-color: rgba(0,0,0,0.35);\r\n}\r\n", ""]);
            const o = s
        }
        ,
        281: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.timer {\r\n\tposition: absolute;\r\n\tbottom: 0;\r\n\tleft: 0;\r\n\twidth: 100%;\r\n\ttext-align: center;\r\n\topacity: 0.9;\r\n}\r\n.timer.up {\r\n\tbottom: auto;\r\n\ttop: 0;\r\n}\r\n\r\n.timer > div {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tdisplay: inline-flex;\r\n\tflex-direction: column;\r\n\twidth: 240px;\r\n\tvertical-align: bottom;\r\n}\r\n.timer.up > div {\r\n\tflex-direction: column-reverse;\r\n\tvertical-align: top;\r\n}\r\n.timer > div > h2 {\r\n\tmargin: 0 auto;\r\n\tpadding: 0;\r\n\twidth: 220px;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n\tcolor: var(--text-color);\r\n\tfont-size: 26px;\r\n\tfont-weight: normal;\r\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\r\n}\r\n\r\n.timer > div > div {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n.timer > .left > div {\r\n\tpadding: 8px 4px 8px 10px;\r\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\r\n}\r\n.timer.up > .left > div {\r\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%);\r\n}\r\n.timer > .center > div {\r\n\tposition: relative;\r\n\tz-index: 1;\r\n\tmargin: 0 -12px;\r\n\tpadding: 8px 10px;\r\n\tclip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\r\n}\r\n.timer.up > .center > div {\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\r\n}\r\n.timer > .right > div {\r\n\tpadding: 8px 10px 8px 4px;\r\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\r\n}\r\n.timer.up > .right > div {\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n}\r\n\r\n.timer > div > div > p {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tbackground-color: var(--surface-tertiary-color);\r\n\tcolor: var(--text-color);\r\n\tfont-size: 34px;\r\n}\r\n.timer > .left > div > p {\r\n\tclip-path: polygon(6px 0, 100% 0, 100% 100%, 0 100%);\r\n}\r\n.timer.up > .left > div > p {\r\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 6px 100%);\r\n}\r\n.timer > .center > div > p {\r\n\tfont-size: 46px;\r\n\tclip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\r\n}\r\n.timer.up > .center > div > p {\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 6px 100%);\r\n}\r\n.timer > .right > div > p {\r\n\tclip-path: polygon(0 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\r\n}\r\n.timer.up > .right > div > p {\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 0 100%);\r\n}\r\n\r\n.timer > div > div > p.green {\r\n\tcolor: #5f5;\r\n}\r\n.timer > div > div > p.red {\r\n\tcolor:#f55;\r\n}\r\n\r\n.timer > div > div > p > span {\r\n\tdisplay: inline-block;\r\n\twidth: 0.5em;\r\n\ttext-align: center;\r\n}\r\n.timer > div > div > p > span.sign {\r\n\tmargin-left: -4px;\r\n\twidth: 0.7em;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        232: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.touch-controls > button {\r\n\tposition: absolute;\r\n\ttop: calc(1.5cm + 50px);\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\twidth: 160px;\r\n\theight: 160px;\r\n\tbackground-color: var(--button-color);\r\n\tborder: none;\r\n\topacity: 0.6;\r\n\tpointer-events: auto;\r\n}\r\n.touch-controls > button  > img {\r\n\tmargin: 0;\r\n\tpadding: 30px;\r\n\tvertical-align: top;\r\n\twidth: 100%;\r\n    height: 100%;\r\n\tbox-sizing: border-box;\r\n\tpointer-events: none;\r\n\ttransition: padding 0.25s ease-out;\r\n}\r\n.touch-controls > button.active > img {\r\n    padding: 40px;\r\n}\r\n\r\n.touch-controls > .quit {\r\n\tleft: 1.5cm;\r\n}\r\n\r\n.touch-controls > .reset {\r\n\tright: 1.5cm;\r\n}\r\n\r\n.touch-controls > .left-container {\r\n\tposition: absolute;\r\n\tleft: 1.5cm;\r\n\tbottom: 1.5cm;\r\n}\r\n\r\n.touch-controls > .right-container {\r\n\tposition: absolute;\r\n\tright: 1.5cm;\r\n\tbottom: 1.5cm;\r\n}\r\n.touch-controls > .right-container > div {\r\n\tdisplay: inline-block;\r\n}\r\n\r\n.touch-controls > div > div {\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\twidth: 160px;\r\n\theight: 160px;\r\n\tbackground-color: var(--button-color);\r\n\topacity: 0.5;\r\n\tpointer-events: auto;\r\n}\r\n.touch-controls > div > div.active {\r\n\tbackground-color: var(--button-active-color);\r\n\topacity: 0.6;\r\n}\r\n\r\n.touch-controls > div > div > img {\r\n\tmargin: 0;\r\n\tpadding: 40px;\r\n\tvertical-align: top;\r\n\twidth: 100%;\r\n    height: 100%;\r\n\tbox-sizing: border-box;\r\n\tpointer-events: none;\r\n}\r\n.touch-controls > div > div.active > img {\r\n    padding: 50px;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        947: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.track-export > .background {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tz-index: 1;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: rgba(20, 20, 30, 0.5);\r\n\tpointer-events: auto;\r\n}\r\n\r\n.track-export > .box {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 80% / 2);\r\n\ttop: 20px;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 10px;\r\n\tbox-sizing: border-box;\r\n\twidth: 80%;\r\n\theight: calc(100% - 20px * 2);\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.track-export > .box > .bar {\r\n\ttext-align: left;\r\n\tpointer-events: auto;\r\n}\r\n.track-export > .box > .bar > .button.right {\r\n\tfloat: right;\r\n}\r\n\r\n.track-export > .box > textarea {\r\n\tmargin: 10px 0 0 0;\r\n\tpadding: 10px;\r\n\tbox-sizing: border-box;\r\n\tmin-width: 100%;\r\n\tmax-width: 100%;\r\n\tmin-height: calc(100% - 52px - 10px);\r\n\tmax-height: calc(100% - 52px - 10px);\r\n\tpointer-events: auto;\r\n\tbackground-color: var(--surface-tertiary-color);\r\n\tborder: none;\r\n\tresize: none;\r\n\tcolor: var(--text-color);\r\n\tword-break: break-all;\r\n\tfont-size: 20px;\r\n}\r\n.track-export > .box > textarea:focus-visible {\r\n\toutline: none;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        421: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.track-info {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 1050px / 2);\r\n\ttop: 0;\r\n\tz-index: 2;\r\n\tdisplay: flex;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 1000px;\r\n\theight: 100%;\r\n}\r\n\r\n.track-info > .side-panel {\r\n\tposition: relative;\r\n\tdisplay: inline-block;\r\n\tmargin-left: 50px;\r\n\twidth: 400px;\r\n\t\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.track-info > .side-panel > h2 {\r\n\tmargin: 10px 10px 0 10px;\r\n\tpadding: 0;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n\tfont-weight: normal;\r\n\tfont-size: 38px;\r\n\ttext-align: center;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n\r\n.track-info > .side-panel > .thumbnail {\r\n\tmargin: 10px 0 0 0;\r\n\tpadding: 40px;\r\n\tbackground-color: var(--surface-secondary-color);\r\n}\r\n\r\n.track-info > .side-panel > .thumbnail > canvas {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 300px;\r\n\theight: 300px;\r\n\tobject-fit: contain;\r\n\t-webkit-filter: drop-shadow(0 0 3px #000);\r\n\tfilter: drop-shadow(0 0 3px #000);\r\n\timage-rendering: pixelated;\r\n}\r\n\r\n.track-info > .side-panel > p {\r\n\tmargin: 16px 0;\r\n\tpadding: 0;\r\n\tfont-size: 32px;\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.track-info > .side-panel > .button.play {\r\n\tposition: absolute;\r\n\tbottom: 10px;\r\n\tleft: 0;\r\n\tmargin: 10px 10px 0 10px;\r\n\tpadding: 0 0 0 30px;\r\n\tbox-sizing: border-box;\r\n\twidth: calc(100% - 2 * 10px);\r\n\theight: 100px;\r\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\r\n\ttext-align: center;\r\n\tfont-size: 50px;\r\n}\r\n\r\n.track-info > .side-panel > .button.play > img {\r\n\tmargin: 0 0 0 10px;\r\n\tpadding: 0;\r\n\tvertical-align: middle;\r\n\twidth: 48px;\r\n\ttransition: transform 0.2s ease-in-out;\r\n\tpointer-events: none;\r\n}\r\n\r\n@media (hover: hover) {\r\n\t.track-info > .side-panel > .button.play:hover > img {\r\n\t\ttransform: translateX(10px);\r\n\t}\r\n}\r\n\r\n.track-info > .side-panel > .back {\r\n\tmargin: 10px;\r\n}\r\n\r\n.track-info > .side-panel > .leaderboard-button {\r\n\tmargin: 10px;\r\n\tfloat: right;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        307: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.track-selection {\r\n\tposition: absolute;\r\n\tbottom: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\ttext-align: center;\r\n}\r\n\r\n.track-selection > .bar {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twidth: 100%;\r\n\tbackground-color: var(--surface-color);\r\n\ttext-align: left;\r\n\r\n\tpointer-events:auto;\r\n}\r\n.track-selection > .bar > .button {\r\n\tmargin: 8px 12px;\r\n}\r\n.track-selection > .bar > .button.right {\r\n\tfloat: right;\r\n}\r\n\r\n.track-selection .tracks-container {\r\n\tmargin: 0;\r\n\tpadding: 20px 0;\r\n\tbox-sizing: border-box;\r\n\twidth: 100%;\r\n\theight: calc(100% - 64px);\r\n\toverflow-y: auto;\r\n\tpointer-events: auto;\r\n}\r\n.track-selection.editor-track-selection .tracks-container {\r\n\tbackground-color: rgba(20, 20, 45, 0.8);\r\n}\r\n\r\n.track-selection h2 {\r\n\tmargin: 0.5em 0.75em;\r\n\tpadding: 0;\r\n\tcolor: var(--text-color);\r\n\tfont-size: 50px;\r\n\tfont-weight: normal;\r\n\tborder-bottom: 2px solid var(--text-color);\r\n}\r\n\r\n.track-selection .tracks-container .track {\r\n\tposition: relative;\r\n\tdisplay: inline-block;\r\n}\r\n\r\n.track-selection .tracks-container .track button {\r\n\tmargin: 10px;\r\n\tpadding: 0;\r\n\tcolor: var(--text-color);\r\n\tfont-size: 32px;\r\n}\r\n.track-selection .tracks-container .track button:after {\r\n\tborder-bottom: none;\r\n}\r\n.track-selection .tracks-container .track button:focus-visible {\r\n\ttext-decoration: none;\r\n}\r\n\r\n.track-selection .track-title {\r\n\tmargin: 0;\r\n\tpadding: 4px;\r\n\tfont-size: 25px;\r\n\tbackground-color: var(--surface-secondary-color);\r\n}\r\n.track-selection .tracks-container .track button:focus-visible .track-title {\r\n\ttext-decoration: underline;\r\n}\r\n.track-selection .track-title > p {\r\n\tmargin: 0;\r\n\tpadding: 0 22px;\r\n\twidth: 208px;\r\n\tbox-sizing: border-box;\r\n\twhite-space: nowrap;\r\n\toverflow: hidden;\r\n\ttext-overflow: ellipsis;\r\n}\r\n\r\n.track-selection .track canvas {\r\n\tmargin: 0;\r\n\tpadding: 20px 40px;\r\n\twidth: 128px;\r\n\theight: 128px;\r\n\tobject-fit: contain;\r\n\t-webkit-filter: drop-shadow(0 0 3px #000);\r\n\tfilter: drop-shadow(0 0 3px #000);\r\n\timage-rendering: pixelated;\r\n}\r\n\r\n.track-selection .record {\r\n\tmargin: 0;\r\n\tpadding: 4px;\r\n\tfont-size: 24px;\r\n\tbackground-color: var(--surface-secondary-color);\r\n\tcolor: var(--text-color);\r\n}\r\n\r\n.track-selection .delete-button {\r\n\tposition: absolute;\r\n\ttop: 7px;\r\n\tright: 6px;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tline-height: 0;\r\n\tborder-radius: 2px;\r\n\tborder: none;\r\n\tbackground-color: var(--button-color);\r\n\r\n\tpointer-events: auto;\r\n\tcursor: pointer;\r\n}\r\n@media (hover: hover) {\r\n\t.track-selection .delete-button:hover {\r\n\t\tbackground-color: var(--button-hover-color);\r\n\t}\r\n}\r\n.track-selection .delete-button:active {\r\n\tbackground-color: var(--button-active-color);\r\n}\r\n.track-selection .delete-button > img {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\theight: 20px;\r\n\tvertical-align: top;\r\n\tpointer-events: none;\r\n}\r\n\r\n", ""]);
            const o = s
        }
        ,
        367: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n#transition-layer {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground-color: #000;\r\n\tpointer-events: none;\r\n\r\n\topacity: 0;\r\n\ttransition: 0.25s ease-in-out opacity;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        18: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.user-export {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 500px / 2);\r\n\ttop: 35%;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 10px;\r\n\tbox-sizing: border-box;\r\n\twidth: 500px;\r\n\theight: 150px;\r\n\tbackground-color: var(--surface-color);\r\n}\r\n\r\n.user-export > textarea {\r\n\tmargin: 0;\r\n\tpadding: 10px;\r\n\tbox-sizing: border-box;\r\n\tmin-width: 100%;\r\n\tmax-width: 100%;\r\n\tmin-height: calc(100% - 52px - 10px);\r\n\tmax-height: calc(100% - 52px - 10px);\r\n\tpointer-events: auto;\r\n\tbackground-color: var(--surface-tertiary-color);\r\n\tborder: none;\r\n\tresize: none;\r\n\tcolor: var(--text-color);\r\n\tword-break: break-all;\r\n\tfont-size: 20px;\r\n}\r\n.user-export > textarea:focus-visible {\r\n\toutline: none;\r\n}\r\n\r\n.user-export > .bar {\r\n\tmargin: 8px 0 0 0;\r\n}\r\n\r\n.user-export > .bar > .button.right {\r\n\tfloat: right;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        4: (e,t,n)=>{
            "use strict";
            n.d(t, {
                Z: ()=>o
            });
            var i = n(81)
              , r = n.n(i)
              , a = n(645)
              , s = n.n(a)()(r());
            s.push([e.id, "\r\n.verifier-ui {\r\n\tposition: absolute;\r\n\tleft: calc(50% - 500px / 2);\r\n\ttop: 0;\r\n\tz-index: 2;\r\n\tmargin: 0;\r\n\tpadding: 16px;\r\n\twidth: 500px;\r\n\theight: 100%;\r\n\toverflow-y: scroll;\r\n\tbox-sizing: border-box;\r\n\tbackground-color: var(--surface-color);\r\n\tpointer-events: auto;\r\n}\r\n\r\n.verifier-ui > p {\r\n\tmargin: 16px 4px 0 4px;\r\n\tpadding: 0;\r\n\tfont-size: 20px;\r\n\tcolor: var(--text-color);\r\n\twhite-space: pre-wrap;\r\n}\r\n\r\n.verifier-ui > button {\r\n\tdisplay: inline-block;\r\n\tmargin: 16px 0 0 0;\r\n}\r\n", ""]);
            const o = s
        }
        ,
        645: e=>{
            "use strict";
            e.exports = function(e) {
                var t = [];
                return t.toString = function() {
                    return this.map((function(t) {
                        var n = ""
                          , i = void 0 !== t[5];
                        return t[4] && (n += "@supports (".concat(t[4], ") {")),
                        t[2] && (n += "@media ".concat(t[2], " {")),
                        i && (n += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")),
                        n += e(t),
                        i && (n += "}"),
                        t[2] && (n += "}"),
                        t[4] && (n += "}"),
                        n
                    }
                    )).join("")
                }
                ,
                t.i = function(e, n, i, r, a) {
                    "string" == typeof e && (e = [[null, e, void 0]]);
                    var s = {};
                    if (i)
                        for (var o = 0; o < this.length; o++) {
                            var l = this[o][0];
                            null != l && (s[l] = !0)
                        }
                    for (var c = 0; c < e.length; c++) {
                        var h = [].concat(e[c]);
                        i && s[h[0]] || (void 0 !== a && (void 0 === h[5] || (h[1] = "@layer".concat(h[5].length > 0 ? " ".concat(h[5]) : "", " {").concat(h[1], "}")),
                        h[5] = a),
                        n && (h[2] ? (h[1] = "@media ".concat(h[2], " {").concat(h[1], "}"),
                        h[2] = n) : h[2] = n),
                        r && (h[4] ? (h[1] = "@supports (".concat(h[4], ") {").concat(h[1], "}"),
                        h[4] = r) : h[4] = "".concat(r)),
                        t.push(h))
                    }
                }
                ,
                t
            }
        }
        ,
        667: e=>{
            "use strict";
            e.exports = function(e, t) {
                return t || (t = {}),
                e ? (e = String(e.__esModule ? e.default : e),
                /^['"].*['"]$/.test(e) && (e = e.slice(1, -1)),
                t.hash && (e += t.hash),
                /["'() \t\n]|(%20)/.test(e) || t.needQuotes ? '"'.concat(e.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : e) : e
            }
        }
        ,
        81: e=>{
            "use strict";
            e.exports = function(e) {
                return e[1]
            }
        }
        ,
        23: (e,t,n)=>{
            var i;
            /**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.10.1
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2023
 * @license MIT
 */
            !function() {
                "use strict";
                var t = "input is invalid type"
                  , r = "object" == typeof window
                  , a = r ? window : {};
                a.JS_SHA256_NO_WINDOW && (r = !1);
                var s = !r && "object" == typeof self
                  , o = !a.JS_SHA256_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                o ? a = n.g : s && (a = self);
                var l = !a.JS_SHA256_NO_COMMON_JS && e.exports
                  , c = n.amdO
                  , h = !a.JS_SHA256_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer
                  , d = "0123456789abcdef".split("")
                  , u = [-2147483648, 8388608, 32768, 128]
                  , p = [24, 16, 8, 0]
                  , f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
                  , m = ["hex", "array", "digest", "arrayBuffer"]
                  , g = [];
                !a.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }
                ),
                !h || !a.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                    return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                }
                );
                var v = function(e, t) {
                    return function(n) {
                        return new b(t,!0).update(n)[e]()
                    }
                }
                  , w = function(e) {
                    var t = v("hex", e);
                    o && (t = y(t, e)),
                    t.create = function() {
                        return new b(e)
                    }
                    ,
                    t.update = function(e) {
                        return t.create().update(e)
                    }
                    ;
                    for (var n = 0; n < m.length; ++n) {
                        var i = m[n];
                        t[i] = v(i, e)
                    }
                    return t
                }
                  , y = function(e, i) {
                    var r, s = n(127), o = n(371).Buffer, l = i ? "sha224" : "sha256";
                    r = o.from && !a.JS_SHA256_NO_BUFFER_FROM ? o.from : function(e) {
                        return new o(e)
                    }
                    ;
                    return function(n) {
                        if ("string" == typeof n)
                            return s.createHash(l).update(n, "utf8").digest("hex");
                        if (null == n)
                            throw new Error(t);
                        return n.constructor === ArrayBuffer && (n = new Uint8Array(n)),
                        Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === o ? s.createHash(l).update(r(n)).digest("hex") : e(n)
                    }
                }
                  , _ = function(e, t) {
                    return function(n, i) {
                        return new E(n,t,!0).update(i)[e]()
                    }
                }
                  , x = function(e) {
                    var t = _("hex", e);
                    t.create = function(t) {
                        return new E(t,e)
                    }
                    ,
                    t.update = function(e, n) {
                        return t.create(e).update(n)
                    }
                    ;
                    for (var n = 0; n < m.length; ++n) {
                        var i = m[n];
                        t[i] = _(i, e)
                    }
                    return t
                };
                function b(e, t) {
                    t ? (g[0] = g[16] = g[1] = g[2] = g[3] = g[4] = g[5] = g[6] = g[7] = g[8] = g[9] = g[10] = g[11] = g[12] = g[13] = g[14] = g[15] = 0,
                    this.blocks = g) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    e ? (this.h0 = 3238371032,
                    this.h1 = 914150663,
                    this.h2 = 812702999,
                    this.h3 = 4144912697,
                    this.h4 = 4290775857,
                    this.h5 = 1750603025,
                    this.h6 = 1694076839,
                    this.h7 = 3204075428) : (this.h0 = 1779033703,
                    this.h1 = 3144134277,
                    this.h2 = 1013904242,
                    this.h3 = 2773480762,
                    this.h4 = 1359893119,
                    this.h5 = 2600822924,
                    this.h6 = 528734635,
                    this.h7 = 1541459225),
                    this.block = this.start = this.bytes = this.hBytes = 0,
                    this.finalized = this.hashed = !1,
                    this.first = !0,
                    this.is224 = e
                }
                function E(e, n, i) {
                    var r, a = typeof e;
                    if ("string" === a) {
                        var s, o = [], l = e.length, c = 0;
                        for (r = 0; r < l; ++r)
                            (s = e.charCodeAt(r)) < 128 ? o[c++] = s : s < 2048 ? (o[c++] = 192 | s >> 6,
                            o[c++] = 128 | 63 & s) : s < 55296 || s >= 57344 ? (o[c++] = 224 | s >> 12,
                            o[c++] = 128 | s >> 6 & 63,
                            o[c++] = 128 | 63 & s) : (s = 65536 + ((1023 & s) << 10 | 1023 & e.charCodeAt(++r)),
                            o[c++] = 240 | s >> 18,
                            o[c++] = 128 | s >> 12 & 63,
                            o[c++] = 128 | s >> 6 & 63,
                            o[c++] = 128 | 63 & s);
                        e = o
                    } else {
                        if ("object" !== a)
                            throw new Error(t);
                        if (null === e)
                            throw new Error(t);
                        if (h && e.constructor === ArrayBuffer)
                            e = new Uint8Array(e);
                        else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                            throw new Error(t)
                    }
                    e.length > 64 && (e = new b(n,!0).update(e).array());
                    var d = []
                      , u = [];
                    for (r = 0; r < 64; ++r) {
                        var p = e[r] || 0;
                        d[r] = 92 ^ p,
                        u[r] = 54 ^ p
                    }
                    b.call(this, n, i),
                    this.update(u),
                    this.oKeyPad = d,
                    this.inner = !0,
                    this.sharedMemory = i
                }
                b.prototype.update = function(e) {
                    if (!this.finalized) {
                        var n, i = typeof e;
                        if ("string" !== i) {
                            if ("object" !== i)
                                throw new Error(t);
                            if (null === e)
                                throw new Error(t);
                            if (h && e.constructor === ArrayBuffer)
                                e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                throw new Error(t);
                            n = !0
                        }
                        for (var r, a, s = 0, o = e.length, l = this.blocks; s < o; ) {
                            if (this.hashed && (this.hashed = !1,
                            l[0] = this.block,
                            l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0),
                            n)
                                for (a = this.start; s < o && a < 64; ++s)
                                    l[a >> 2] |= e[s] << p[3 & a++];
                            else
                                for (a = this.start; s < o && a < 64; ++s)
                                    (r = e.charCodeAt(s)) < 128 ? l[a >> 2] |= r << p[3 & a++] : r < 2048 ? (l[a >> 2] |= (192 | r >> 6) << p[3 & a++],
                                    l[a >> 2] |= (128 | 63 & r) << p[3 & a++]) : r < 55296 || r >= 57344 ? (l[a >> 2] |= (224 | r >> 12) << p[3 & a++],
                                    l[a >> 2] |= (128 | r >> 6 & 63) << p[3 & a++],
                                    l[a >> 2] |= (128 | 63 & r) << p[3 & a++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++s)),
                                    l[a >> 2] |= (240 | r >> 18) << p[3 & a++],
                                    l[a >> 2] |= (128 | r >> 12 & 63) << p[3 & a++],
                                    l[a >> 2] |= (128 | r >> 6 & 63) << p[3 & a++],
                                    l[a >> 2] |= (128 | 63 & r) << p[3 & a++]);
                            this.lastByteIndex = a,
                            this.bytes += a - this.start,
                            a >= 64 ? (this.block = l[16],
                            this.start = a - 64,
                            this.hash(),
                            this.hashed = !0) : this.start = a
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0,
                        this.bytes = this.bytes % 4294967296),
                        this
                    }
                }
                ,
                b.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var e = this.blocks
                          , t = this.lastByteIndex;
                        e[16] = this.block,
                        e[t >> 2] |= u[3 & t],
                        this.block = e[16],
                        t >= 56 && (this.hashed || this.hash(),
                        e[0] = this.block,
                        e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0),
                        e[14] = this.hBytes << 3 | this.bytes >>> 29,
                        e[15] = this.bytes << 3,
                        this.hash()
                    }
                }
                ,
                b.prototype.hash = function() {
                    var e, t, n, i, r, a, s, o, l, c = this.h0, h = this.h1, d = this.h2, u = this.h3, p = this.h4, m = this.h5, g = this.h6, v = this.h7, w = this.blocks;
                    for (e = 16; e < 64; ++e)
                        t = ((r = w[e - 15]) >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3,
                        n = ((r = w[e - 2]) >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10,
                        w[e] = w[e - 16] + t + w[e - 7] + n << 0;
                    for (l = h & d,
                    e = 0; e < 64; e += 4)
                        this.first ? (this.is224 ? (a = 300032,
                        v = (r = w[0] - 1413257819) - 150054599 << 0,
                        u = r + 24177077 << 0) : (a = 704751109,
                        v = (r = w[0] - 210244248) - 1521486534 << 0,
                        u = r + 143694565 << 0),
                        this.first = !1) : (t = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10),
                        i = (a = c & h) ^ c & d ^ l,
                        v = u + (r = v + (n = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (p & m ^ ~p & g) + f[e] + w[e]) << 0,
                        u = r + (t + i) << 0),
                        t = (u >>> 2 | u << 30) ^ (u >>> 13 | u << 19) ^ (u >>> 22 | u << 10),
                        i = (s = u & c) ^ u & h ^ a,
                        g = d + (r = g + (n = (v >>> 6 | v << 26) ^ (v >>> 11 | v << 21) ^ (v >>> 25 | v << 7)) + (v & p ^ ~v & m) + f[e + 1] + w[e + 1]) << 0,
                        t = ((d = r + (t + i) << 0) >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10),
                        i = (o = d & u) ^ d & c ^ s,
                        m = h + (r = m + (n = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & v ^ ~g & p) + f[e + 2] + w[e + 2]) << 0,
                        t = ((h = r + (t + i) << 0) >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10),
                        i = (l = h & d) ^ h & u ^ o,
                        p = c + (r = p + (n = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7)) + (m & g ^ ~m & v) + f[e + 3] + w[e + 3]) << 0,
                        c = r + (t + i) << 0,
                        this.chromeBugWorkAround = !0;
                    this.h0 = this.h0 + c << 0,
                    this.h1 = this.h1 + h << 0,
                    this.h2 = this.h2 + d << 0,
                    this.h3 = this.h3 + u << 0,
                    this.h4 = this.h4 + p << 0,
                    this.h5 = this.h5 + m << 0,
                    this.h6 = this.h6 + g << 0,
                    this.h7 = this.h7 + v << 0
                }
                ,
                b.prototype.hex = function() {
                    this.finalize();
                    var e = this.h0
                      , t = this.h1
                      , n = this.h2
                      , i = this.h3
                      , r = this.h4
                      , a = this.h5
                      , s = this.h6
                      , o = this.h7
                      , l = d[e >> 28 & 15] + d[e >> 24 & 15] + d[e >> 20 & 15] + d[e >> 16 & 15] + d[e >> 12 & 15] + d[e >> 8 & 15] + d[e >> 4 & 15] + d[15 & e] + d[t >> 28 & 15] + d[t >> 24 & 15] + d[t >> 20 & 15] + d[t >> 16 & 15] + d[t >> 12 & 15] + d[t >> 8 & 15] + d[t >> 4 & 15] + d[15 & t] + d[n >> 28 & 15] + d[n >> 24 & 15] + d[n >> 20 & 15] + d[n >> 16 & 15] + d[n >> 12 & 15] + d[n >> 8 & 15] + d[n >> 4 & 15] + d[15 & n] + d[i >> 28 & 15] + d[i >> 24 & 15] + d[i >> 20 & 15] + d[i >> 16 & 15] + d[i >> 12 & 15] + d[i >> 8 & 15] + d[i >> 4 & 15] + d[15 & i] + d[r >> 28 & 15] + d[r >> 24 & 15] + d[r >> 20 & 15] + d[r >> 16 & 15] + d[r >> 12 & 15] + d[r >> 8 & 15] + d[r >> 4 & 15] + d[15 & r] + d[a >> 28 & 15] + d[a >> 24 & 15] + d[a >> 20 & 15] + d[a >> 16 & 15] + d[a >> 12 & 15] + d[a >> 8 & 15] + d[a >> 4 & 15] + d[15 & a] + d[s >> 28 & 15] + d[s >> 24 & 15] + d[s >> 20 & 15] + d[s >> 16 & 15] + d[s >> 12 & 15] + d[s >> 8 & 15] + d[s >> 4 & 15] + d[15 & s];
                    return this.is224 || (l += d[o >> 28 & 15] + d[o >> 24 & 15] + d[o >> 20 & 15] + d[o >> 16 & 15] + d[o >> 12 & 15] + d[o >> 8 & 15] + d[o >> 4 & 15] + d[15 & o]),
                    l
                }
                ,
                b.prototype.toString = b.prototype.hex,
                b.prototype.digest = function() {
                    this.finalize();
                    var e = this.h0
                      , t = this.h1
                      , n = this.h2
                      , i = this.h3
                      , r = this.h4
                      , a = this.h5
                      , s = this.h6
                      , o = this.h7
                      , l = [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, 255 & s];
                    return this.is224 || l.push(o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o),
                    l
                }
                ,
                b.prototype.array = b.prototype.digest,
                b.prototype.arrayBuffer = function() {
                    this.finalize();
                    var e = new ArrayBuffer(this.is224 ? 28 : 32)
                      , t = new DataView(e);
                    return t.setUint32(0, this.h0),
                    t.setUint32(4, this.h1),
                    t.setUint32(8, this.h2),
                    t.setUint32(12, this.h3),
                    t.setUint32(16, this.h4),
                    t.setUint32(20, this.h5),
                    t.setUint32(24, this.h6),
                    this.is224 || t.setUint32(28, this.h7),
                    e
                }
                ,
                E.prototype = new b,
                E.prototype.finalize = function() {
                    if (b.prototype.finalize.call(this),
                    this.inner) {
                        this.inner = !1;
                        var e = this.array();
                        b.call(this, this.is224, this.sharedMemory),
                        this.update(this.oKeyPad),
                        this.update(e),
                        b.prototype.finalize.call(this)
                    }
                }
                ;
                var S = w();
                S.sha256 = S,
                S.sha224 = w(!0),
                S.sha256.hmac = x(),
                S.sha224.hmac = x(!0),
                l ? e.exports = S : (a.sha256 = S.sha256,
                a.sha224 = S.sha224,
                c && (void 0 === (i = function() {
                    return S
                }
                .call(S, n, S, e)) || (e.exports = i)))
            }()
        }
        ,
        379: e=>{
            "use strict";
            var t = [];
            function n(e) {
                for (var n = -1, i = 0; i < t.length; i++)
                    if (t[i].identifier === e) {
                        n = i;
                        break
                    }
                return n
            }
            function i(e, i) {
                for (var a = {}, s = [], o = 0; o < e.length; o++) {
                    var l = e[o]
                      , c = i.base ? l[0] + i.base : l[0]
                      , h = a[c] || 0
                      , d = "".concat(c, " ").concat(h);
                    a[c] = h + 1;
                    var u = n(d)
                      , p = {
                        css: l[1],
                        media: l[2],
                        sourceMap: l[3],
                        supports: l[4],
                        layer: l[5]
                    };
                    if (-1 !== u)
                        t[u].references++,
                        t[u].updater(p);
                    else {
                        var f = r(p, i);
                        i.byIndex = o,
                        t.splice(o, 0, {
                            identifier: d,
                            updater: f,
                            references: 1
                        })
                    }
                    s.push(d)
                }
                return s
            }
            function r(e, t) {
                var n = t.domAPI(t);
                n.update(e);
                return function(t) {
                    if (t) {
                        if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer)
                            return;
                        n.update(e = t)
                    } else
                        n.remove()
                }
            }
            e.exports = function(e, r) {
                var a = i(e = e || [], r = r || {});
                return function(e) {
                    e = e || [];
                    for (var s = 0; s < a.length; s++) {
                        var o = n(a[s]);
                        t[o].references--
                    }
                    for (var l = i(e, r), c = 0; c < a.length; c++) {
                        var h = n(a[c]);
                        0 === t[h].references && (t[h].updater(),
                        t.splice(h, 1))
                    }
                    a = l
                }
            }
        }
        ,
        569: e=>{
            "use strict";
            var t = {};
            e.exports = function(e, n) {
                var i = function(e) {
                    if (void 0 === t[e]) {
                        var n = document.querySelector(e);
                        if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement)
                            try {
                                n = n.contentDocument.head
                            } catch (e) {
                                n = null
                            }
                        t[e] = n
                    }
                    return t[e]
                }(e);
                if (!i)
                    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                i.appendChild(n)
            }
        }
        ,
        216: e=>{
            "use strict";
            e.exports = function(e) {
                var t = document.createElement("style");
                return e.setAttributes(t, e.attributes),
                e.insert(t, e.options),
                t
            }
        }
        ,
        565: (e,t,n)=>{
            "use strict";
            e.exports = function(e) {
                var t = n.nc;
                t && e.setAttribute("nonce", t)
            }
        }
        ,
        795: e=>{
            "use strict";
            e.exports = function(e) {
                if ("undefined" == typeof document)
                    return {
                        update: function() {},
                        remove: function() {}
                    };
                var t = e.insertStyleElement(e);
                return {
                    update: function(n) {
                        !function(e, t, n) {
                            var i = "";
                            n.supports && (i += "@supports (".concat(n.supports, ") {")),
                            n.media && (i += "@media ".concat(n.media, " {"));
                            var r = void 0 !== n.layer;
                            r && (i += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")),
                            i += n.css,
                            r && (i += "}"),
                            n.media && (i += "}"),
                            n.supports && (i += "}");
                            var a = n.sourceMap;
                            a && "undefined" != typeof btoa && (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))), " */")),
                            t.styleTagTransform(i, e, t.options)
                        }(t, e, n)
                    },
                    remove: function() {
                        !function(e) {
                            if (null === e.parentNode)
                                return !1;
                            e.parentNode.removeChild(e)
                        }(t)
                    }
                }
            }
        }
        ,
        589: e=>{
            "use strict";
            e.exports = function(e, t) {
                if (t.styleSheet)
                    t.styleSheet.cssText = e;
                else {
                    for (; t.firstChild; )
                        t.removeChild(t.firstChild);
                    t.appendChild(document.createTextNode(e))
                }
            }
        }
        ,
        553: (e,t,n)=>{
            "use strict";
            e.exports = n.p + "4e75ed8189c5a7b6fbf8.ttf"
        }
        ,
        607: (e,t,n)=>{
            "use strict";
            e.exports = n.p + "2e5b7bff10d7782e539c.woff"
        }
        ,
        264: (e,t,n)=>{
            "use strict";
            e.exports = n.p + "a82f15d48dbc61b6edeb.woff2"
        }
        ,
        371: ()=>{}
        ,
        127: ()=>{}
    }
      , t = {};
    function n(i) {
        var r = t[i];
        if (void 0 !== r)
            return r.exports;
        var a = t[i] = {
            id: i,
            exports: {}
        };
        return e[i](a, a.exports, n),
        a.exports
    }
    n.m = e,
    n.amdO = {},
    n.n = e=>{
        var t = e && e.__esModule ? ()=>e.default : ()=>e;
        return n.d(t, {
            a: t
        }),
        t
    }
    ,
    n.d = (e,t)=>{
        for (var i in t)
            n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, {
                enumerable: !0,
                get: t[i]
            })
    }
    ,
    n.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    n.o = (e,t)=>Object.prototype.hasOwnProperty.call(e, t),
    n.p = "/dist/",
    n.b = document.baseURI || self.location.href,
    n.nc = void 0,
    (()=>{
        "use strict";
        var e = n(379)
          , t = n.n(e)
          , i = n(795)
          , r = n.n(i)
          , a = n(569)
          , s = n.n(a)
          , o = n(565)
          , l = n.n(o)
          , c = n(216)
          , h = n.n(c)
          , d = n(589)
          , u = n.n(d)
          , p = n(296)
          , f = {};
        f.styleTagTransform = u(),
        f.setAttributes = l(),
        f.insert = s().bind(null, "head"),
        f.domAPI = r(),
        f.insertStyleElement = h();
        t()(p.Z, f);
        p.Z && p.Z.locals && p.Z.locals;
        const m = "160"
          , g = 0
          , v = 1
          , w = 2
          , y = 0
          , _ = 1
          , x = 2
          , b = 3
          , E = 100
          , S = "attached"
          , M = 301
          , T = 302
          , k = 303
          , C = 304
          , A = 306
          , P = 1e3
          , R = 1001
          , L = 1002
          , I = 1003
          , N = 1004
          , U = 1005
          , D = 1006
          , B = 1007
          , O = 1008
          , z = 1009
          , F = 1012
          , W = 1013
          , H = 1014
          , V = 1015
          , G = 1016
          , j = 1020
          , X = 1023
          , q = 1026
          , Y = 1027
          , Z = 33776
          , K = 33777
          , J = 33778
          , Q = 33779
          , $ = 36492
          , ee = 2300
          , te = 2301
          , ne = 2302
          , ie = 2400
          , re = 2401
          , ae = 2402
          , se = 3001
          , oe = ""
          , le = "srgb"
          , ce = "srgb-linear"
          , he = "display-p3"
          , de = "display-p3-linear"
          , ue = "linear"
          , pe = "srgb"
          , fe = "rec709"
          , me = "p3"
          , ge = 7680
          , ve = 35044
          , we = "300 es"
          , ye = 1035
          , _e = 2e3
          , xe = 2001;
        class be {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []),
                -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            }
            removeEventListener(e, t) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[e];
                if (void 0 !== n) {
                    const e = n.indexOf(t);
                    -1 !== e && n.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                if (void 0 === this._listeners)
                    return;
                const t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    const n = t.slice(0);
                    for (let t = 0, i = n.length; t < i; t++)
                        n[t].call(this, e);
                    e.target = null
                }
            }
        }
        const Ee = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let Se = 1234567;
        const Me = Math.PI / 180
          , Te = 180 / Math.PI;
        function ke() {
            const e = 4294967295 * Math.random() | 0
              , t = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (Ee[255 & e] + Ee[e >> 8 & 255] + Ee[e >> 16 & 255] + Ee[e >> 24 & 255] + "-" + Ee[255 & t] + Ee[t >> 8 & 255] + "-" + Ee[t >> 16 & 15 | 64] + Ee[t >> 24 & 255] + "-" + Ee[63 & n | 128] + Ee[n >> 8 & 255] + "-" + Ee[n >> 16 & 255] + Ee[n >> 24 & 255] + Ee[255 & i] + Ee[i >> 8 & 255] + Ee[i >> 16 & 255] + Ee[i >> 24 & 255]).toLowerCase()
        }
        function Ce(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }
        function Ae(e, t) {
            return (e % t + t) % t
        }
        function Pe(e, t, n) {
            return (1 - n) * e + n * t
        }
        function Re(e) {
            return 0 == (e & e - 1) && 0 !== e
        }
        function Le(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
        function Ie(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return e / 4294967295;
            case Uint16Array:
                return e / 65535;
            case Uint8Array:
                return e / 255;
            case Int32Array:
                return Math.max(e / 2147483647, -1);
            case Int16Array:
                return Math.max(e / 32767, -1);
            case Int8Array:
                return Math.max(e / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function Ne(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return Math.round(4294967295 * e);
            case Uint16Array:
                return Math.round(65535 * e);
            case Uint8Array:
                return Math.round(255 * e);
            case Int32Array:
                return Math.round(2147483647 * e);
            case Int16Array:
                return Math.round(32767 * e);
            case Int8Array:
                return Math.round(127 * e);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const Ue = {
            DEG2RAD: Me,
            RAD2DEG: Te,
            generateUUID: ke,
            clamp: Ce,
            euclideanModulo: Ae,
            mapLinear: function(e, t, n, i, r) {
                return i + (e - t) * (r - i) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: Pe,
            damp: function(e, t, n, i) {
                return Pe(e, t, 1 - Math.exp(-n * i))
            },
            pingpong: function(e, t=1) {
                return t - Math.abs(Ae(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (Se = e);
                let t = Se += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t),
                t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
                ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * Me
            },
            radToDeg: function(e) {
                return e * Te
            },
            isPowerOfTwo: Re,
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: Le,
            setQuaternionFromProperEuler: function(e, t, n, i, r) {
                const a = Math.cos
                  , s = Math.sin
                  , o = a(n / 2)
                  , l = s(n / 2)
                  , c = a((t + i) / 2)
                  , h = s((t + i) / 2)
                  , d = a((t - i) / 2)
                  , u = s((t - i) / 2)
                  , p = a((i - t) / 2)
                  , f = s((i - t) / 2);
                switch (r) {
                case "XYX":
                    e.set(o * h, l * d, l * u, o * c);
                    break;
                case "YZY":
                    e.set(l * u, o * h, l * d, o * c);
                    break;
                case "ZXZ":
                    e.set(l * d, l * u, o * h, o * c);
                    break;
                case "XZX":
                    e.set(o * h, l * f, l * p, o * c);
                    break;
                case "YXY":
                    e.set(l * p, o * h, l * f, o * c);
                    break;
                case "ZYZ":
                    e.set(l * f, l * p, o * h, o * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: Ne,
            denormalize: Ie
        };
        class De {
            constructor(e=0, t=0) {
                De.prototype.isVector2 = !0,
                this.x = e,
                this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e,
                this.y = t,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6],
                this.y = i[1] * t + i[4] * n + i[7],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(Ce(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this
            }
            rotateAround(e, t) {
                const n = Math.cos(t)
                  , i = Math.sin(t)
                  , r = this.x - e.x
                  , a = this.y - e.y;
                return this.x = r * n - a * i + e.x,
                this.y = r * i + a * n + e.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class Be {
            constructor(e, t, n, i, r, a, s, o, l) {
                Be.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, i, r, a, s, o, l)
            }
            set(e, t, n, i, r, a, s, o, l) {
                const c = this.elements;
                return c[0] = e,
                c[1] = i,
                c[2] = s,
                c[3] = t,
                c[4] = r,
                c[5] = o,
                c[6] = n,
                c[7] = a,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0),
                t.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , i = t.elements
                  , r = this.elements
                  , a = n[0]
                  , s = n[3]
                  , o = n[6]
                  , l = n[1]
                  , c = n[4]
                  , h = n[7]
                  , d = n[2]
                  , u = n[5]
                  , p = n[8]
                  , f = i[0]
                  , m = i[3]
                  , g = i[6]
                  , v = i[1]
                  , w = i[4]
                  , y = i[7]
                  , _ = i[2]
                  , x = i[5]
                  , b = i[8];
                return r[0] = a * f + s * v + o * _,
                r[3] = a * m + s * w + o * x,
                r[6] = a * g + s * y + o * b,
                r[1] = l * f + c * v + h * _,
                r[4] = l * m + c * w + h * x,
                r[7] = l * g + c * y + h * b,
                r[2] = d * f + u * v + p * _,
                r[5] = d * m + u * w + p * x,
                r[8] = d * g + u * y + p * b,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[3] *= e,
                t[6] *= e,
                t[1] *= e,
                t[4] *= e,
                t[7] *= e,
                t[2] *= e,
                t[5] *= e,
                t[8] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , a = e[4]
                  , s = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8];
                return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , a = e[4]
                  , s = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8]
                  , h = c * a - s * l
                  , d = s * o - c * r
                  , u = l * r - a * o
                  , p = t * h + n * d + i * u;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return e[0] = h * f,
                e[1] = (i * l - c * n) * f,
                e[2] = (s * n - i * a) * f,
                e[3] = d * f,
                e[4] = (c * t - i * o) * f,
                e[5] = (i * r - s * t) * f,
                e[6] = u * f,
                e[7] = (n * o - l * t) * f,
                e[8] = (a * t - n * r) * f,
                this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1],
                t[1] = t[3],
                t[3] = e,
                e = t[2],
                t[2] = t[6],
                t[6] = e,
                e = t[5],
                t[5] = t[7],
                t[7] = e,
                this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0],
                e[1] = t[3],
                e[2] = t[6],
                e[3] = t[1],
                e[4] = t[4],
                e[5] = t[7],
                e[6] = t[2],
                e[7] = t[5],
                e[8] = t[8],
                this
            }
            setUvTransform(e, t, n, i, r, a, s) {
                const o = Math.cos(r)
                  , l = Math.sin(r);
                return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1),
                this
            }
            scale(e, t) {
                return this.premultiply(Oe.makeScale(e, t)),
                this
            }
            rotate(e) {
                return this.premultiply(Oe.makeRotation(-e)),
                this
            }
            translate(e, t) {
                return this.premultiply(Oe.makeTranslation(e, t)),
                this
            }
            makeTranslation(e, t) {
                return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                this
            }
            makeRotation(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                this
            }
            makeScale(e, t) {
                return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let e = 0; e < 9; e++)
                    if (t[e] !== n[e])
                        return !1;
                return !0
            }
            fromArray(e, t=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray(e=[], t=0) {
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Oe = new Be;
        function ze(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] >= 65535)
                    return !0;
            return !1
        }
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        function Fe(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }
        function We() {
            const e = Fe("canvas");
            return e.style.display = "block",
            e
        }
        const He = {};
        function Ve(e) {
            e in He || (He[e] = !0,
            console.warn(e))
        }
        const Ge = (new Be).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
          , je = (new Be).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
          , Xe = {
            [ce]: {
                transfer: ue,
                primaries: fe,
                toReference: e=>e,
                fromReference: e=>e
            },
            [le]: {
                transfer: pe,
                primaries: fe,
                toReference: e=>e.convertSRGBToLinear(),
                fromReference: e=>e.convertLinearToSRGB()
            },
            [de]: {
                transfer: ue,
                primaries: me,
                toReference: e=>e.applyMatrix3(je),
                fromReference: e=>e.applyMatrix3(Ge)
            },
            [he]: {
                transfer: pe,
                primaries: me,
                toReference: e=>e.convertSRGBToLinear().applyMatrix3(je),
                fromReference: e=>e.applyMatrix3(Ge).convertLinearToSRGB()
            }
        }
          , qe = new Set([ce, de])
          , Ye = {
            enabled: !0,
            _workingColorSpace: ce,
            get workingColorSpace() {
                return this._workingColorSpace
            },
            set workingColorSpace(e) {
                if (!qe.has(e))
                    throw new Error(`Unsupported working color space, "${e}".`);
                this._workingColorSpace = e
            },
            convert: function(e, t, n) {
                if (!1 === this.enabled || t === n || !t || !n)
                    return e;
                const i = Xe[t].toReference;
                return (0,
                Xe[n].fromReference)(i(e))
            },
            fromWorkingColorSpace: function(e, t) {
                return this.convert(e, this._workingColorSpace, t)
            },
            toWorkingColorSpace: function(e, t) {
                return this.convert(e, t, this._workingColorSpace)
            },
            getPrimaries: function(e) {
                return Xe[e].primaries
            },
            getTransfer: function(e) {
                return e === oe ? ue : Xe[e].transfer
            }
        };
        function Ze(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }
        function Ke(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        let Je;
        class Qe {
            static getDataURL(e) {
                if (/^data:/i.test(e.src))
                    return e.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return e.src;
                let t;
                if (e instanceof HTMLCanvasElement)
                    t = e;
                else {
                    void 0 === Je && (Je = Fe("canvas")),
                    Je.width = e.width,
                    Je.height = e.height;
                    const n = Je.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                    t = Je
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
                t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = Fe("canvas");
                    t.width = e.width,
                    t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const i = n.getImageData(0, 0, e.width, e.height)
                      , r = i.data;
                    for (let e = 0; e < r.length; e++)
                        r[e] = 255 * Ze(r[e] / 255);
                    return n.putImageData(i, 0, 0),
                    t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++)
                        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Ze(t[e] / 255)) : t[e] = Ze(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                e
            }
        }
        let $e = 0;
        class et {
            constructor(e=null) {
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: $e++
                }),
                this.uuid = ke(),
                this.data = e,
                this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.images[this.uuid])
                    return e.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                }
                  , i = this.data;
                if (null !== i) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++)
                            i[t].isDataTexture ? e.push(tt(i[t].image)) : e.push(tt(i[t]))
                    } else
                        e = tt(i);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n),
                n
            }
        }
        function tt(e) {
            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Qe.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let nt = 0;
        class it extends be {
            constructor(e=it.DEFAULT_IMAGE, t=it.DEFAULT_MAPPING, n=1001, i=1001, r=1006, a=1008, s=1023, o=1009, l=it.DEFAULT_ANISOTROPY, c="") {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: nt++
                }),
                this.uuid = ke(),
                this.name = "",
                this.source = new et(e),
                this.mipmaps = [],
                this.mapping = t,
                this.channel = 0,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = a,
                this.anisotropy = l,
                this.format = s,
                this.internalFormat = null,
                this.type = o,
                this.offset = new De(0,0),
                this.repeat = new De(1,1),
                this.center = new De(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new Be,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                "string" == typeof c ? this.colorSpace = c : (Ve("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = c === se ? le : oe),
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(e=null) {
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name,
                this.source = e.source,
                this.mipmaps = e.mipmaps.slice(0),
                this.mapping = e.mapping,
                this.channel = e.channel,
                this.wrapS = e.wrapS,
                this.wrapT = e.wrapT,
                this.magFilter = e.magFilter,
                this.minFilter = e.minFilter,
                this.anisotropy = e.anisotropy,
                this.format = e.format,
                this.internalFormat = e.internalFormat,
                this.type = e.type,
                this.offset.copy(e.offset),
                this.repeat.copy(e.repeat),
                this.center.copy(e.center),
                this.rotation = e.rotation,
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrix.copy(e.matrix),
                this.generateMipmaps = e.generateMipmaps,
                this.premultiplyAlpha = e.premultiplyAlpha,
                this.flipY = e.flipY,
                this.unpackAlignment = e.unpackAlignment,
                this.colorSpace = e.colorSpace,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid])
                    return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t || (e.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (300 !== this.mapping)
                    return e;
                if (e.applyMatrix3(this.matrix),
                e.x < 0 || e.x > 1)
                    switch (this.wrapS) {
                    case P:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case R:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case L:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                    case P:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case R:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case L:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                return this.flipY && (e.y = 1 - e.y),
                e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++,
                this.source.needsUpdate = !0)
            }
            get encoding() {
                return Ve("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace === le ? se : 3e3
            }
            set encoding(e) {
                Ve("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = e === se ? le : oe
            }
        }
        it.DEFAULT_IMAGE = null,
        it.DEFAULT_MAPPING = 300,
        it.DEFAULT_ANISOTROPY = 1;
        class rt {
            constructor(e=0, t=0, n=0, i=1) {
                rt.prototype.isVector4 = !0,
                this.x = e,
                this.y = t,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, i) {
                return this.x = e,
                this.y = t,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this.w = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setW(e) {
                return this.w = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this.w = void 0 !== e.w ? e.w : 1,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this.w += e.w,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this.w += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this.w = e.w + t.w,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this.w += e.w * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this.w -= e.w,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this.w -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this.w = e.w - t.w,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this.w *= e.w,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this.w *= e,
                this
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , a = e.elements;
                return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r,
                this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r,
                this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r,
                this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = e.x / t,
                this.y = e.y / t,
                this.z = e.z / t),
                this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, i, r;
                const a = .01
                  , s = .1
                  , o = e.elements
                  , l = o[0]
                  , c = o[4]
                  , h = o[8]
                  , d = o[1]
                  , u = o[5]
                  , p = o[9]
                  , f = o[2]
                  , m = o[6]
                  , g = o[10];
                if (Math.abs(c - d) < a && Math.abs(h - f) < a && Math.abs(p - m) < a) {
                    if (Math.abs(c + d) < s && Math.abs(h + f) < s && Math.abs(p + m) < s && Math.abs(l + u + g - 3) < s)
                        return this.set(1, 0, 0, 0),
                        this;
                    t = Math.PI;
                    const e = (l + 1) / 2
                      , o = (u + 1) / 2
                      , v = (g + 1) / 2
                      , w = (c + d) / 4
                      , y = (h + f) / 4
                      , _ = (p + m) / 4;
                    return e > o && e > v ? e < a ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(e),
                    i = w / n,
                    r = y / n) : o > v ? o < a ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(o),
                    n = w / i,
                    r = _ / i) : v < a ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(v),
                    n = y / r,
                    i = _ / r),
                    this.set(n, i, r, t),
                    this
                }
                let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (d - c) * (d - c));
                return Math.abs(v) < .001 && (v = 1),
                this.x = (m - p) / v,
                this.y = (h - f) / v,
                this.z = (d - c) / v,
                this.w = Math.acos((l + u + g - 1) / 2),
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this.w = Math.min(this.w, e.w),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this.w = Math.max(this.w, e.w),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this.z = Math.max(e.z, Math.min(t.z, this.z)),
                this.w = Math.max(e.w, Math.min(t.w, this.w)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this.z = Math.max(e, Math.min(t, this.z)),
                this.w = Math.max(e, Math.min(t, this.w)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this.w += (e.w - this.w) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this.w = e.w + (t.w - e.w) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this.w = e[t + 3],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e[t + 3] = this.w,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this.w = e.getW(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class at extends be {
            constructor(e=1, t=1, n={}) {
                super(),
                this.isRenderTarget = !0,
                this.width = e,
                this.height = t,
                this.depth = 1,
                this.scissor = new rt(0,0,e,t),
                this.scissorTest = !1,
                this.viewport = new rt(0,0,e,t);
                const i = {
                    width: e,
                    height: t,
                    depth: 1
                };
                void 0 !== n.encoding && (Ve("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
                n.colorSpace = n.encoding === se ? le : oe),
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: D,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, n),
                this.texture = new it(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.flipY = !1,
                this.texture.generateMipmaps = n.generateMipmaps,
                this.texture.internalFormat = n.internalFormat,
                this.depthBuffer = n.depthBuffer,
                this.stencilBuffer = n.stencilBuffer,
                this.depthTexture = n.depthTexture,
                this.samples = n.samples
            }
            setSize(e, t, n=1) {
                this.width === e && this.height === t && this.depth === n || (this.width = e,
                this.height = t,
                this.depth = n,
                this.texture.image.width = e,
                this.texture.image.height = t,
                this.texture.image.depth = n,
                this.dispose()),
                this.viewport.set(0, 0, e, t),
                this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.scissor.copy(e.scissor),
                this.scissorTest = e.scissorTest,
                this.viewport.copy(e.viewport),
                this.texture = e.texture.clone(),
                this.texture.isRenderTargetTexture = !0;
                const t = Object.assign({}, e.texture.image);
                return this.texture.source = new et(t),
                this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                this.samples = e.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class st extends at {
            constructor(e=1, t=1, n={}) {
                super(e, t, n),
                this.isWebGLRenderTarget = !0
            }
        }
        class ot extends it {
            constructor(e=null, t=1, n=1, i=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                },
                this.magFilter = I,
                this.minFilter = I,
                this.wrapR = R,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class lt extends it {
            constructor(e=null, t=1, n=1, i=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                },
                this.magFilter = I,
                this.minFilter = I,
                this.wrapR = R,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class ct {
            constructor(e=0, t=0, n=0, i=1) {
                this.isQuaternion = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._w = i
            }
            static slerpFlat(e, t, n, i, r, a, s) {
                let o = n[i + 0]
                  , l = n[i + 1]
                  , c = n[i + 2]
                  , h = n[i + 3];
                const d = r[a + 0]
                  , u = r[a + 1]
                  , p = r[a + 2]
                  , f = r[a + 3];
                if (0 === s)
                    return e[t + 0] = o,
                    e[t + 1] = l,
                    e[t + 2] = c,
                    void (e[t + 3] = h);
                if (1 === s)
                    return e[t + 0] = d,
                    e[t + 1] = u,
                    e[t + 2] = p,
                    void (e[t + 3] = f);
                if (h !== f || o !== d || l !== u || c !== p) {
                    let e = 1 - s;
                    const t = o * d + l * u + c * p + h * f
                      , n = t >= 0 ? 1 : -1
                      , i = 1 - t * t;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , a = Math.atan2(r, t * n);
                        e = Math.sin(e * a) / r,
                        s = Math.sin(s * a) / r
                    }
                    const r = s * n;
                    if (o = o * e + d * r,
                    l = l * e + u * r,
                    c = c * e + p * r,
                    h = h * e + f * r,
                    e === 1 - s) {
                        const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                        o *= e,
                        l *= e,
                        c *= e,
                        h *= e
                    }
                }
                e[t] = o,
                e[t + 1] = l,
                e[t + 2] = c,
                e[t + 3] = h
            }
            static multiplyQuaternionsFlat(e, t, n, i, r, a) {
                const s = n[i]
                  , o = n[i + 1]
                  , l = n[i + 2]
                  , c = n[i + 3]
                  , h = r[a]
                  , d = r[a + 1]
                  , u = r[a + 2]
                  , p = r[a + 3];
                return e[t] = s * p + c * h + o * u - l * d,
                e[t + 1] = o * p + c * d + l * h - s * u,
                e[t + 2] = l * p + c * u + s * d - o * h,
                e[t + 3] = c * p - s * h - o * d - l * u,
                e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e,
                this._onChangeCallback()
            }
            set(e, t, n, i) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(e) {
                return this._x = e.x,
                this._y = e.y,
                this._z = e.z,
                this._w = e.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(e, t=!0) {
                const n = e._x
                  , i = e._y
                  , r = e._z
                  , a = e._order
                  , s = Math.cos
                  , o = Math.sin
                  , l = s(n / 2)
                  , c = s(i / 2)
                  , h = s(r / 2)
                  , d = o(n / 2)
                  , u = o(i / 2)
                  , p = o(r / 2);
                switch (a) {
                case "XYZ":
                    this._x = d * c * h + l * u * p,
                    this._y = l * u * h - d * c * p,
                    this._z = l * c * p + d * u * h,
                    this._w = l * c * h - d * u * p;
                    break;
                case "YXZ":
                    this._x = d * c * h + l * u * p,
                    this._y = l * u * h - d * c * p,
                    this._z = l * c * p - d * u * h,
                    this._w = l * c * h + d * u * p;
                    break;
                case "ZXY":
                    this._x = d * c * h - l * u * p,
                    this._y = l * u * h + d * c * p,
                    this._z = l * c * p + d * u * h,
                    this._w = l * c * h - d * u * p;
                    break;
                case "ZYX":
                    this._x = d * c * h - l * u * p,
                    this._y = l * u * h + d * c * p,
                    this._z = l * c * p - d * u * h,
                    this._w = l * c * h + d * u * p;
                    break;
                case "YZX":
                    this._x = d * c * h + l * u * p,
                    this._y = l * u * h + d * c * p,
                    this._z = l * c * p - d * u * h,
                    this._w = l * c * h - d * u * p;
                    break;
                case "XZY":
                    this._x = d * c * h - l * u * p,
                    this._y = l * u * h - d * c * p,
                    this._z = l * c * p + d * u * h,
                    this._w = l * c * h + d * u * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                }
                return !0 === t && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2
                  , i = Math.sin(n);
                return this._x = e.x * i,
                this._y = e.y * i,
                this._z = e.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e) {
                const t = e.elements
                  , n = t[0]
                  , i = t[4]
                  , r = t[8]
                  , a = t[1]
                  , s = t[5]
                  , o = t[9]
                  , l = t[2]
                  , c = t[6]
                  , h = t[10]
                  , d = n + s + h;
                if (d > 0) {
                    const e = .5 / Math.sqrt(d + 1);
                    this._w = .25 / e,
                    this._x = (c - o) * e,
                    this._y = (r - l) * e,
                    this._z = (a - i) * e
                } else if (n > s && n > h) {
                    const e = 2 * Math.sqrt(1 + n - s - h);
                    this._w = (c - o) / e,
                    this._x = .25 * e,
                    this._y = (i + a) / e,
                    this._z = (r + l) / e
                } else if (s > h) {
                    const e = 2 * Math.sqrt(1 + s - n - h);
                    this._w = (r - l) / e,
                    this._x = (i + a) / e,
                    this._y = .25 * e,
                    this._z = (o + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + h - n - s);
                    this._w = (a - i) / e,
                    this._x = (r + l) / e,
                    this._y = (o + c) / e,
                    this._z = .25 * e
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                this._y = e.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -e.z,
                this._z = e.y,
                this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                this._y = e.z * t.x - e.x * t.z,
                this._z = e.x * t.y - e.y * t.x,
                this._w = n),
                this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(Ce(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n)
                    return this;
                const i = Math.min(1, t / n);
                return this.slerp(e, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (e = 1 / e,
                this._x = this._x * e,
                this._y = this._y * e,
                this._z = this._z * e,
                this._w = this._w * e),
                this._onChangeCallback(),
                this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x
                  , i = e._y
                  , r = e._z
                  , a = e._w
                  , s = t._x
                  , o = t._y
                  , l = t._z
                  , c = t._w;
                return this._x = n * c + a * s + i * l - r * o,
                this._y = i * c + a * o + r * s - n * l,
                this._z = r * c + a * l + n * o - i * s,
                this._w = a * c - n * s - i * o - r * l,
                this._onChangeCallback(),
                this
            }
            slerp(e, t) {
                if (0 === t)
                    return this;
                if (1 === t)
                    return this.copy(e);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , a = this._w;
                let s = a * e._w + n * e._x + i * e._y + r * e._z;
                if (s < 0 ? (this._w = -e._w,
                this._x = -e._x,
                this._y = -e._y,
                this._z = -e._z,
                s = -s) : this.copy(e),
                s >= 1)
                    return this._w = a,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const o = 1 - s * s;
                if (o <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * a + t * this._w,
                    this._x = e * n + t * this._x,
                    this._y = e * i + t * this._y,
                    this._z = e * r + t * this._z,
                    this.normalize(),
                    this
                }
                const l = Math.sqrt(o)
                  , c = Math.atan2(l, s)
                  , h = Math.sin((1 - t) * c) / l
                  , d = Math.sin(t * c) / l;
                return this._w = a * h + this._w * d,
                this._x = n * h + this._x * d,
                this._y = i * h + this._y * d,
                this._z = r * h + this._z * d,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = Math.random()
                  , t = Math.sqrt(1 - e)
                  , n = Math.sqrt(e)
                  , i = 2 * Math.PI * Math.random()
                  , r = 2 * Math.PI * Math.random();
                return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, t=0) {
                return this._x = e[t],
                this._y = e[t + 1],
                this._z = e[t + 2],
                this._w = e[t + 3],
                this._onChangeCallback(),
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._w,
                e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t),
                this._y = e.getY(t),
                this._z = e.getZ(t),
                this._w = e.getW(t),
                this._onChangeCallback(),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class ht {
            constructor(e=0, t=0, n=0) {
                ht.prototype.isVector3 = !0,
                this.x = e,
                this.y = t,
                this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z),
                this.x = e,
                this.y = t,
                this.z = n,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x,
                this.y = e.y * t.y,
                this.z = e.z * t.z,
                this
            }
            applyEuler(e) {
                return this.applyQuaternion(ut.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(ut.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i,
                this.y = r[1] * t + r[4] * n + r[7] * i,
                this.z = r[2] * t + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements
                  , a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a,
                this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a,
                this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a,
                this
            }
            applyQuaternion(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.x
                  , a = e.y
                  , s = e.z
                  , o = e.w
                  , l = 2 * (a * i - s * n)
                  , c = 2 * (s * t - r * i)
                  , h = 2 * (r * n - a * t);
                return this.x = t + o * l + a * h - s * c,
                this.y = n + o * c + s * l - r * h,
                this.z = i + o * h + r * c - a * l,
                this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i,
                this.y = r[1] * t + r[5] * n + r[9] * i,
                this.z = r[2] * t + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this.z = Math.max(e.z, Math.min(t.z, this.z)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this.z = Math.max(e, Math.min(t, this.z)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x
                  , i = e.y
                  , r = e.z
                  , a = t.x
                  , s = t.y
                  , o = t.z;
                return this.x = i * o - r * s,
                this.y = r * a - n * o,
                this.z = n * s - i * a,
                this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t)
                    return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return dt.copy(this).projectOnVector(e),
                this.sub(dt)
            }
            reflect(e) {
                return this.sub(dt.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(Ce(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y
                  , i = this.z - e.z;
                return t * t + n * n + i * i
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const i = Math.sin(t) * e;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(t) * e,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t),
                this.y = n,
                this.z = e * Math.cos(t),
                this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12],
                this.y = t[13],
                this.z = t[14],
                this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length()
                  , n = this.setFromMatrixColumn(e, 1).length()
                  , i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x,
                this.y = e._y,
                this.z = e._z,
                this
            }
            setFromColor(e) {
                return this.x = e.r,
                this.y = e.g,
                this.z = e.b,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const e = 2 * (Math.random() - .5)
                  , t = Math.random() * Math.PI * 2
                  , n = Math.sqrt(1 - e ** 2);
                return this.x = n * Math.cos(t),
                this.y = n * Math.sin(t),
                this.z = e,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const dt = new ht
          , ut = new ct;
        class pt {
            constructor(e=new ht(1 / 0,1 / 0,1 / 0), t=new ht(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = e,
                this.max = t
            }
            set(e, t) {
                return this.min.copy(e),
                this.max.copy(t),
                this
            }
            setFromArray(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t += 3)
                    this.expandByPoint(mt.fromArray(e, t));
                return this
            }
            setFromBufferAttribute(e) {
                this.makeEmpty();
                for (let t = 0, n = e.count; t < n; t++)
                    this.expandByPoint(mt.fromBufferAttribute(e, t));
                return this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = mt.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n),
                this.max.copy(e).add(n),
                this
            }
            setFromObject(e, t=!1) {
                return this.makeEmpty(),
                this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            expandByObject(e, t=!1) {
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute("position");
                    if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                        for (let t = 0, n = i.count; t < n; t++)
                            !0 === e.isMesh ? e.getVertexPosition(t, mt) : mt.fromBufferAttribute(i, t),
                            mt.applyMatrix4(e.matrixWorld),
                            this.expandByPoint(mt);
                    else
                        void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                        gt.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                        gt.copy(n.boundingBox)),
                        gt.applyMatrix4(e.matrixWorld),
                        this.union(gt)
                }
                const i = e.children;
                for (let e = 0, n = i.length; e < n; e++)
                    this.expandByObject(i[e], t);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, mt),
                mt.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                n = e.normal.x * this.min.x),
                e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                n += e.normal.y * this.min.y),
                e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                n += e.normal.z * this.min.z),
                t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(Et),
                St.subVectors(this.max, Et),
                vt.subVectors(e.a, Et),
                wt.subVectors(e.b, Et),
                yt.subVectors(e.c, Et),
                _t.subVectors(wt, vt),
                xt.subVectors(yt, wt),
                bt.subVectors(vt, yt);
                let t = [0, -_t.z, _t.y, 0, -xt.z, xt.y, 0, -bt.z, bt.y, _t.z, 0, -_t.x, xt.z, 0, -xt.x, bt.z, 0, -bt.x, -_t.y, _t.x, 0, -xt.y, xt.x, 0, -bt.y, bt.x, 0];
                return !!kt(t, vt, wt, yt, St) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!kt(t, vt, wt, yt, St) && (Mt.crossVectors(_t, xt),
                t = [Mt.x, Mt.y, Mt.z],
                kt(t, vt, wt, yt, St)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, mt).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                e.radius = .5 * this.getSize(mt).length()),
                e
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (ft[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                ft[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                ft[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                ft[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                ft[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                ft[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                ft[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                ft[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(ft)),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const ft = [new ht, new ht, new ht, new ht, new ht, new ht, new ht, new ht]
          , mt = new ht
          , gt = new pt
          , vt = new ht
          , wt = new ht
          , yt = new ht
          , _t = new ht
          , xt = new ht
          , bt = new ht
          , Et = new ht
          , St = new ht
          , Mt = new ht
          , Tt = new ht;
        function kt(e, t, n, i, r) {
            for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                Tt.fromArray(e, a);
                const s = r.x * Math.abs(Tt.x) + r.y * Math.abs(Tt.y) + r.z * Math.abs(Tt.z)
                  , o = t.dot(Tt)
                  , l = n.dot(Tt)
                  , c = i.dot(Tt);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s)
                    return !1
            }
            return !0
        }
        const Ct = new pt
          , At = new ht
          , Pt = new ht;
        class Rt {
            constructor(e=new ht, t=-1) {
                this.isSphere = !0,
                this.center = e,
                this.radius = t
            }
            set(e, t) {
                return this.center.copy(e),
                this.radius = t,
                this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : Ct.setFromPoints(e).getCenter(n);
                let i = 0;
                for (let t = 0, r = e.length; t < r; t++)
                    i = Math.max(i, n.distanceToSquared(e[t]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(e) {
                return this.center.copy(e.center),
                this.radius = e.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e),
                n > this.radius * this.radius && (t.sub(this.center).normalize(),
                t.multiplyScalar(this.radius).add(this.center)),
                t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(),
                e) : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e),
                this.radius = this.radius * e.getMaxScaleOnAxis(),
                this
            }
            translate(e) {
                return this.center.add(e),
                this
            }
            expandByPoint(e) {
                if (this.isEmpty())
                    return this.center.copy(e),
                    this.radius = 0,
                    this;
                At.subVectors(e, this.center);
                const t = At.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t)
                      , n = .5 * (e - this.radius);
                    this.center.addScaledVector(At, n / e),
                    this.radius += n
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Pt.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(At.copy(e.center).add(Pt)),
                this.expandByPoint(At.copy(e.center).sub(Pt))),
                this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Lt = new ht
          , It = new ht
          , Nt = new ht
          , Ut = new ht
          , Dt = new ht
          , Bt = new ht
          , Ot = new ht;
        class zt {
            constructor(e=new ht, t=new ht(0,0,-1)) {
                this.origin = e,
                this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e),
                this.direction.copy(t),
                this
            }
            copy(e) {
                return this.origin.copy(e.origin),
                this.direction.copy(e.direction),
                this
            }
            at(e, t) {
                return t.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(),
                this
            }
            recast(e) {
                return this.origin.copy(this.at(e, Lt)),
                this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = Lt.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (Lt.copy(this.origin).addScaledVector(this.direction, t),
                Lt.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, i) {
                It.copy(e).add(t).multiplyScalar(.5),
                Nt.copy(t).sub(e).normalize(),
                Ut.copy(this.origin).sub(It);
                const r = .5 * e.distanceTo(t)
                  , a = -this.direction.dot(Nt)
                  , s = Ut.dot(this.direction)
                  , o = -Ut.dot(Nt)
                  , l = Ut.lengthSq()
                  , c = Math.abs(1 - a * a);
                let h, d, u, p;
                if (c > 0)
                    if (h = a * o - s,
                    d = a * s - o,
                    p = r * c,
                    h >= 0)
                        if (d >= -p)
                            if (d <= p) {
                                const e = 1 / c;
                                h *= e,
                                d *= e,
                                u = h * (h + a * d + 2 * s) + d * (a * h + d + 2 * o) + l
                            } else
                                d = r,
                                h = Math.max(0, -(a * d + s)),
                                u = -h * h + d * (d + 2 * o) + l;
                        else
                            d = -r,
                            h = Math.max(0, -(a * d + s)),
                            u = -h * h + d * (d + 2 * o) + l;
                    else
                        d <= -p ? (h = Math.max(0, -(-a * r + s)),
                        d = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                        u = -h * h + d * (d + 2 * o) + l) : d <= p ? (h = 0,
                        d = Math.min(Math.max(-r, -o), r),
                        u = d * (d + 2 * o) + l) : (h = Math.max(0, -(a * r + s)),
                        d = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                        u = -h * h + d * (d + 2 * o) + l);
                else
                    d = a > 0 ? -r : r,
                    h = Math.max(0, -(a * d + s)),
                    u = -h * h + d * (d + 2 * o) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, h),
                i && i.copy(It).addScaledVector(Nt, d),
                u
            }
            intersectSphere(e, t) {
                Lt.subVectors(e.center, this.origin);
                const n = Lt.dot(this.direction)
                  , i = Lt.dot(Lt) - n * n
                  , r = e.radius * e.radius;
                if (i > r)
                    return null;
                const a = Math.sqrt(r - i)
                  , s = n - a
                  , o = n + a;
                return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t)
                    return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                if (0 === t)
                    return !0;
                return e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, i, r, a, s, o;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , h = 1 / this.direction.z
                  , d = this.origin;
                return l >= 0 ? (n = (e.min.x - d.x) * l,
                i = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
                i = (e.min.x - d.x) * l),
                c >= 0 ? (r = (e.min.y - d.y) * c,
                a = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c,
                a = (e.min.y - d.y) * c),
                n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                (a < i || isNaN(i)) && (i = a),
                h >= 0 ? (s = (e.min.z - d.z) * h,
                o = (e.max.z - d.z) * h) : (s = (e.max.z - d.z) * h,
                o = (e.min.z - d.z) * h),
                n > o || s > i ? null : ((s > n || n != n) && (n = s),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, Lt)
            }
            intersectTriangle(e, t, n, i, r) {
                Dt.subVectors(t, e),
                Bt.subVectors(n, e),
                Ot.crossVectors(Dt, Bt);
                let a, s = this.direction.dot(Ot);
                if (s > 0) {
                    if (i)
                        return null;
                    a = 1
                } else {
                    if (!(s < 0))
                        return null;
                    a = -1,
                    s = -s
                }
                Ut.subVectors(this.origin, e);
                const o = a * this.direction.dot(Bt.crossVectors(Ut, Bt));
                if (o < 0)
                    return null;
                const l = a * this.direction.dot(Dt.cross(Ut));
                if (l < 0)
                    return null;
                if (o + l > s)
                    return null;
                const c = -a * Ut.dot(Ot);
                return c < 0 ? null : this.at(c / s, r)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e),
                this.direction.transformDirection(e),
                this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Ft {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m) {
                Ft.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m)
            }
            set(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m) {
                const g = this.elements;
                return g[0] = e,
                g[4] = t,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = a,
                g[9] = s,
                g[13] = o,
                g[2] = l,
                g[6] = c,
                g[10] = h,
                g[14] = d,
                g[3] = u,
                g[7] = p,
                g[11] = f,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Ft).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                t[9] = n[9],
                t[10] = n[10],
                t[11] = n[11],
                t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                t[15] = n[15],
                this
            }
            copyPosition(e) {
                const t = this.elements
                  , n = e.elements;
                return t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0),
                t.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(e) {
                const t = this.elements
                  , n = e.elements
                  , i = 1 / Wt.setFromMatrixColumn(e, 0).length()
                  , r = 1 / Wt.setFromMatrixColumn(e, 1).length()
                  , a = 1 / Wt.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i,
                t[1] = n[1] * i,
                t[2] = n[2] * i,
                t[3] = 0,
                t[4] = n[4] * r,
                t[5] = n[5] * r,
                t[6] = n[6] * r,
                t[7] = 0,
                t[8] = n[8] * a,
                t[9] = n[9] * a,
                t[10] = n[10] * a,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromEuler(e) {
                const t = this.elements
                  , n = e.x
                  , i = e.y
                  , r = e.z
                  , a = Math.cos(n)
                  , s = Math.sin(n)
                  , o = Math.cos(i)
                  , l = Math.sin(i)
                  , c = Math.cos(r)
                  , h = Math.sin(r);
                if ("XYZ" === e.order) {
                    const e = a * c
                      , n = a * h
                      , i = s * c
                      , r = s * h;
                    t[0] = o * c,
                    t[4] = -o * h,
                    t[8] = l,
                    t[1] = n + i * l,
                    t[5] = e - r * l,
                    t[9] = -s * o,
                    t[2] = r - e * l,
                    t[6] = i + n * l,
                    t[10] = a * o
                } else if ("YXZ" === e.order) {
                    const e = o * c
                      , n = o * h
                      , i = l * c
                      , r = l * h;
                    t[0] = e + r * s,
                    t[4] = i * s - n,
                    t[8] = a * l,
                    t[1] = a * h,
                    t[5] = a * c,
                    t[9] = -s,
                    t[2] = n * s - i,
                    t[6] = r + e * s,
                    t[10] = a * o
                } else if ("ZXY" === e.order) {
                    const e = o * c
                      , n = o * h
                      , i = l * c
                      , r = l * h;
                    t[0] = e - r * s,
                    t[4] = -a * h,
                    t[8] = i + n * s,
                    t[1] = n + i * s,
                    t[5] = a * c,
                    t[9] = r - e * s,
                    t[2] = -a * l,
                    t[6] = s,
                    t[10] = a * o
                } else if ("ZYX" === e.order) {
                    const e = a * c
                      , n = a * h
                      , i = s * c
                      , r = s * h;
                    t[0] = o * c,
                    t[4] = i * l - n,
                    t[8] = e * l + r,
                    t[1] = o * h,
                    t[5] = r * l + e,
                    t[9] = n * l - i,
                    t[2] = -l,
                    t[6] = s * o,
                    t[10] = a * o
                } else if ("YZX" === e.order) {
                    const e = a * o
                      , n = a * l
                      , i = s * o
                      , r = s * l;
                    t[0] = o * c,
                    t[4] = r - e * h,
                    t[8] = i * h + n,
                    t[1] = h,
                    t[5] = a * c,
                    t[9] = -s * c,
                    t[2] = -l * c,
                    t[6] = n * h + i,
                    t[10] = e - r * h
                } else if ("XZY" === e.order) {
                    const e = a * o
                      , n = a * l
                      , i = s * o
                      , r = s * l;
                    t[0] = o * c,
                    t[4] = -h,
                    t[8] = l * c,
                    t[1] = e * h + r,
                    t[5] = a * c,
                    t[9] = n * h - i,
                    t[2] = i * h - n,
                    t[6] = s * c,
                    t[10] = r * h + e
                }
                return t[3] = 0,
                t[7] = 0,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(Vt, e, Gt)
            }
            lookAt(e, t, n) {
                const i = this.elements;
                return qt.subVectors(e, t),
                0 === qt.lengthSq() && (qt.z = 1),
                qt.normalize(),
                jt.crossVectors(n, qt),
                0 === jt.lengthSq() && (1 === Math.abs(n.z) ? qt.x += 1e-4 : qt.z += 1e-4,
                qt.normalize(),
                jt.crossVectors(n, qt)),
                jt.normalize(),
                Xt.crossVectors(qt, jt),
                i[0] = jt.x,
                i[4] = Xt.x,
                i[8] = qt.x,
                i[1] = jt.y,
                i[5] = Xt.y,
                i[9] = qt.y,
                i[2] = jt.z,
                i[6] = Xt.z,
                i[10] = qt.z,
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , i = t.elements
                  , r = this.elements
                  , a = n[0]
                  , s = n[4]
                  , o = n[8]
                  , l = n[12]
                  , c = n[1]
                  , h = n[5]
                  , d = n[9]
                  , u = n[13]
                  , p = n[2]
                  , f = n[6]
                  , m = n[10]
                  , g = n[14]
                  , v = n[3]
                  , w = n[7]
                  , y = n[11]
                  , _ = n[15]
                  , x = i[0]
                  , b = i[4]
                  , E = i[8]
                  , S = i[12]
                  , M = i[1]
                  , T = i[5]
                  , k = i[9]
                  , C = i[13]
                  , A = i[2]
                  , P = i[6]
                  , R = i[10]
                  , L = i[14]
                  , I = i[3]
                  , N = i[7]
                  , U = i[11]
                  , D = i[15];
                return r[0] = a * x + s * M + o * A + l * I,
                r[4] = a * b + s * T + o * P + l * N,
                r[8] = a * E + s * k + o * R + l * U,
                r[12] = a * S + s * C + o * L + l * D,
                r[1] = c * x + h * M + d * A + u * I,
                r[5] = c * b + h * T + d * P + u * N,
                r[9] = c * E + h * k + d * R + u * U,
                r[13] = c * S + h * C + d * L + u * D,
                r[2] = p * x + f * M + m * A + g * I,
                r[6] = p * b + f * T + m * P + g * N,
                r[10] = p * E + f * k + m * R + g * U,
                r[14] = p * S + f * C + m * L + g * D,
                r[3] = v * x + w * M + y * A + _ * I,
                r[7] = v * b + w * T + y * P + _ * N,
                r[11] = v * E + w * k + y * R + _ * U,
                r[15] = v * S + w * C + y * L + _ * D,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[4] *= e,
                t[8] *= e,
                t[12] *= e,
                t[1] *= e,
                t[5] *= e,
                t[9] *= e,
                t[13] *= e,
                t[2] *= e,
                t[6] *= e,
                t[10] *= e,
                t[14] *= e,
                t[3] *= e,
                t[7] *= e,
                t[11] *= e,
                t[15] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[4]
                  , i = e[8]
                  , r = e[12]
                  , a = e[1]
                  , s = e[5]
                  , o = e[9]
                  , l = e[13]
                  , c = e[2]
                  , h = e[6]
                  , d = e[10]
                  , u = e[14];
                return e[3] * (+r * o * h - i * l * h - r * s * d + n * l * d + i * s * u - n * o * u) + e[7] * (+t * o * u - t * l * d + r * a * d - i * a * u + i * l * c - r * o * c) + e[11] * (+t * l * h - t * s * u - r * a * h + n * a * u + r * s * c - n * l * c) + e[15] * (-i * s * c - t * o * h + t * s * d + i * a * h - n * a * d + n * o * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this
            }
            setPosition(e, t, n) {
                const i = this.elements;
                return e.isVector3 ? (i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z) : (i[12] = e,
                i[13] = t,
                i[14] = n),
                this
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , a = e[4]
                  , s = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8]
                  , h = e[9]
                  , d = e[10]
                  , u = e[11]
                  , p = e[12]
                  , f = e[13]
                  , m = e[14]
                  , g = e[15]
                  , v = h * m * l - f * d * l + f * o * u - s * m * u - h * o * g + s * d * g
                  , w = p * d * l - c * m * l - p * o * u + a * m * u + c * o * g - a * d * g
                  , y = c * f * l - p * h * l + p * s * u - a * f * u - c * s * g + a * h * g
                  , _ = p * h * o - c * f * o - p * s * d + a * f * d + c * s * m - a * h * m
                  , x = t * v + n * w + i * y + r * _;
                if (0 === x)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const b = 1 / x;
                return e[0] = v * b,
                e[1] = (f * d * r - h * m * r - f * i * u + n * m * u + h * i * g - n * d * g) * b,
                e[2] = (s * m * r - f * o * r + f * i * l - n * m * l - s * i * g + n * o * g) * b,
                e[3] = (h * o * r - s * d * r - h * i * l + n * d * l + s * i * u - n * o * u) * b,
                e[4] = w * b,
                e[5] = (c * m * r - p * d * r + p * i * u - t * m * u - c * i * g + t * d * g) * b,
                e[6] = (p * o * r - a * m * r - p * i * l + t * m * l + a * i * g - t * o * g) * b,
                e[7] = (a * d * r - c * o * r + c * i * l - t * d * l - a * i * u + t * o * u) * b,
                e[8] = y * b,
                e[9] = (p * h * r - c * f * r - p * n * u + t * f * u + c * n * g - t * h * g) * b,
                e[10] = (a * f * r - p * s * r + p * n * l - t * f * l - a * n * g + t * s * g) * b,
                e[11] = (c * s * r - a * h * r - c * n * l + t * h * l + a * n * u - t * s * u) * b,
                e[12] = _ * b,
                e[13] = (c * f * i - p * h * i + p * n * d - t * f * d - c * n * m + t * h * m) * b,
                e[14] = (p * s * i - a * f * i - p * n * o + t * f * o + a * n * m - t * s * m) * b,
                e[15] = (a * h * i - c * s * i + c * n * o - t * h * o - a * n * d + t * s * d) * b,
                this
            }
            scale(e) {
                const t = this.elements
                  , n = e.x
                  , i = e.y
                  , r = e.z;
                return t[0] *= n,
                t[4] *= i,
                t[8] *= r,
                t[1] *= n,
                t[5] *= i,
                t[9] *= r,
                t[2] *= n,
                t[6] *= i,
                t[10] *= r,
                t[3] *= n,
                t[7] *= i,
                t[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const e = this.elements
                  , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                  , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                  , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            }
            makeTranslation(e, t, n) {
                return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t)
                  , i = Math.sin(t)
                  , r = 1 - n
                  , a = e.x
                  , s = e.y
                  , o = e.z
                  , l = r * a
                  , c = r * s;
                return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(e, t, n, i, r, a) {
                return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(e, t, n) {
                const i = this.elements
                  , r = t._x
                  , a = t._y
                  , s = t._z
                  , o = t._w
                  , l = r + r
                  , c = a + a
                  , h = s + s
                  , d = r * l
                  , u = r * c
                  , p = r * h
                  , f = a * c
                  , m = a * h
                  , g = s * h
                  , v = o * l
                  , w = o * c
                  , y = o * h
                  , _ = n.x
                  , x = n.y
                  , b = n.z;
                return i[0] = (1 - (f + g)) * _,
                i[1] = (u + y) * _,
                i[2] = (p - w) * _,
                i[3] = 0,
                i[4] = (u - y) * x,
                i[5] = (1 - (d + g)) * x,
                i[6] = (m + v) * x,
                i[7] = 0,
                i[8] = (p + w) * b,
                i[9] = (m - v) * b,
                i[10] = (1 - (d + f)) * b,
                i[11] = 0,
                i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z,
                i[15] = 1,
                this
            }
            decompose(e, t, n) {
                const i = this.elements;
                let r = Wt.set(i[0], i[1], i[2]).length();
                const a = Wt.set(i[4], i[5], i[6]).length()
                  , s = Wt.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r),
                e.x = i[12],
                e.y = i[13],
                e.z = i[14],
                Ht.copy(this);
                const o = 1 / r
                  , l = 1 / a
                  , c = 1 / s;
                return Ht.elements[0] *= o,
                Ht.elements[1] *= o,
                Ht.elements[2] *= o,
                Ht.elements[4] *= l,
                Ht.elements[5] *= l,
                Ht.elements[6] *= l,
                Ht.elements[8] *= c,
                Ht.elements[9] *= c,
                Ht.elements[10] *= c,
                t.setFromRotationMatrix(Ht),
                n.x = r,
                n.y = a,
                n.z = s,
                this
            }
            makePerspective(e, t, n, i, r, a, s=2e3) {
                const o = this.elements
                  , l = 2 * r / (t - e)
                  , c = 2 * r / (n - i)
                  , h = (t + e) / (t - e)
                  , d = (n + i) / (n - i);
                let u, p;
                if (s === _e)
                    u = -(a + r) / (a - r),
                    p = -2 * a * r / (a - r);
                else {
                    if (s !== xe)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                    u = -a / (a - r),
                    p = -a * r / (a - r)
                }
                return o[0] = l,
                o[4] = 0,
                o[8] = h,
                o[12] = 0,
                o[1] = 0,
                o[5] = c,
                o[9] = d,
                o[13] = 0,
                o[2] = 0,
                o[6] = 0,
                o[10] = u,
                o[14] = p,
                o[3] = 0,
                o[7] = 0,
                o[11] = -1,
                o[15] = 0,
                this
            }
            makeOrthographic(e, t, n, i, r, a, s=2e3) {
                const o = this.elements
                  , l = 1 / (t - e)
                  , c = 1 / (n - i)
                  , h = 1 / (a - r)
                  , d = (t + e) * l
                  , u = (n + i) * c;
                let p, f;
                if (s === _e)
                    p = (a + r) * h,
                    f = -2 * h;
                else {
                    if (s !== xe)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                    p = r * h,
                    f = -1 * h
                }
                return o[0] = 2 * l,
                o[4] = 0,
                o[8] = 0,
                o[12] = -d,
                o[1] = 0,
                o[5] = 2 * c,
                o[9] = 0,
                o[13] = -u,
                o[2] = 0,
                o[6] = 0,
                o[10] = f,
                o[14] = -p,
                o[3] = 0,
                o[7] = 0,
                o[11] = 0,
                o[15] = 1,
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let e = 0; e < 16; e++)
                    if (t[e] !== n[e])
                        return !1;
                return !0
            }
            fromArray(e, t=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray(e=[], t=0) {
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e[t + 9] = n[9],
                e[t + 10] = n[10],
                e[t + 11] = n[11],
                e[t + 12] = n[12],
                e[t + 13] = n[13],
                e[t + 14] = n[14],
                e[t + 15] = n[15],
                e
            }
        }
        const Wt = new ht
          , Ht = new Ft
          , Vt = new ht(0,0,0)
          , Gt = new ht(1,1,1)
          , jt = new ht
          , Xt = new ht
          , qt = new ht
          , Yt = new Ft
          , Zt = new ct;
        class Kt {
            constructor(e=0, t=0, n=0, i=Kt.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e,
                this._onChangeCallback()
            }
            set(e, t, n, i=this._order) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._order = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(e) {
                return this._x = e._x,
                this._y = e._y,
                this._z = e._z,
                this._order = e._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e, t=this._order, n=!0) {
                const i = e.elements
                  , r = i[0]
                  , a = i[4]
                  , s = i[8]
                  , o = i[1]
                  , l = i[5]
                  , c = i[9]
                  , h = i[2]
                  , d = i[6]
                  , u = i[10];
                switch (t) {
                case "XYZ":
                    this._y = Math.asin(Ce(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, u),
                    this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Ce(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, u),
                    this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Ce(d, -1, 1)),
                    Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u),
                    this._z = Math.atan2(-a, l)) : (this._y = 0,
                    this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Ce(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u),
                    this._z = Math.atan2(o, r)) : (this._x = 0,
                    this._z = Math.atan2(-a, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Ce(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-h, r)) : (this._x = 0,
                    this._y = Math.atan2(s, u));
                    break;
                case "XZY":
                    this._z = Math.asin(-Ce(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                    this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, u),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(e, t, n) {
                return Yt.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(Yt, t, n)
            }
            setFromVector3(e, t=this._order) {
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return Zt.setFromEuler(this),
                this.setFromQuaternion(Zt, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0],
                this._y = e[1],
                this._z = e[2],
                void 0 !== e[3] && (this._order = e[3]),
                this._onChangeCallback(),
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._order,
                e
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        Kt.DEFAULT_ORDER = "XYZ";
        class Jt {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = (1 << e | 0) >>> 0
            }
            enable(e) {
                this.mask |= 1 << e | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e | 0
            }
            disable(e) {
                this.mask &= ~(1 << e | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return 0 != (this.mask & e.mask)
            }
            isEnabled(e) {
                return 0 != (this.mask & (1 << e | 0))
            }
        }
        let Qt = 0;
        const $t = new ht
          , en = new ct
          , tn = new Ft
          , nn = new ht
          , rn = new ht
          , an = new ht
          , sn = new ct
          , on = new ht(1,0,0)
          , ln = new ht(0,1,0)
          , cn = new ht(0,0,1)
          , hn = {
            type: "added"
        }
          , dn = {
            type: "removed"
        };
        class un extends be {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: Qt++
                }),
                this.uuid = ke(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = un.DEFAULT_UP.clone();
                const e = new ht
                  , t = new Kt
                  , n = new ct
                  , i = new ht(1,1,1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                }
                )),
                n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ft
                    },
                    normalMatrix: {
                        value: new Be
                    }
                }),
                this.matrix = new Ft,
                this.matrixWorld = new Ft,
                this.matrixAutoUpdate = un.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldAutoUpdate = un.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new Jt,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(e),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e),
                this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return en.setFromAxisAngle(e, t),
                this.quaternion.multiply(en),
                this
            }
            rotateOnWorldAxis(e, t) {
                return en.setFromAxisAngle(e, t),
                this.quaternion.premultiply(en),
                this
            }
            rotateX(e) {
                return this.rotateOnAxis(on, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(ln, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(cn, e)
            }
            translateOnAxis(e, t) {
                return $t.copy(e).applyQuaternion(this.quaternion),
                this.position.add($t.multiplyScalar(t)),
                this
            }
            translateX(e) {
                return this.translateOnAxis(on, e)
            }
            translateY(e) {
                return this.translateOnAxis(ln, e)
            }
            translateZ(e) {
                return this.translateOnAxis(cn, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(tn.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? nn.copy(e) : nn.set(e, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                rn.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? tn.lookAt(rn, nn, this.up) : tn.lookAt(nn, rn, this.up),
                this.quaternion.setFromRotationMatrix(tn),
                i && (tn.extractRotation(i.matrixWorld),
                en.setFromRotationMatrix(tn),
                this.quaternion.premultiply(en.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
                e.parent = this,
                this.children.push(e),
                e.dispatchEvent(hn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null,
                this.children.splice(t, 1),
                e.dispatchEvent(dn)),
                this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1),
                tn.copy(this.matrixWorld).invert(),
                null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                tn.multiply(e.parent.matrixWorld)),
                e.applyMatrix4(tn),
                this.add(e),
                e.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== i)
                        return i
                }
            }
            getObjectsByProperty(e, t, n=[]) {
                this[e] === t && n.push(this);
                const i = this.children;
                for (let r = 0, a = i.length; r < a; r++)
                    i[r].getObjectsByProperty(e, t, n);
                return n
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1),
                e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(rn, e, an),
                e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(rn, sn, e),
                e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible)
                    return;
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t),
                t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                e = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== e || i.updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e
                  , n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                i.up = this.up.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isBatchedMesh && (i.type = "BatchedMesh",
                i.perObjectFrustumCulled = this.perObjectFrustumCulled,
                i.sortObjects = this.sortObjects,
                i.drawRanges = this._drawRanges,
                i.reservedRanges = this._reservedRanges,
                i.visibility = this._visibility,
                i.active = this._active,
                i.bounds = this._bounds.map((e=>({
                    boxInitialized: e.boxInitialized,
                    boxMin: e.box.min.toArray(),
                    boxMax: e.box.max.toArray(),
                    sphereInitialized: e.sphereInitialized,
                    sphereRadius: e.sphere.radius,
                    sphereCenter: e.sphere.center.toArray()
                }))),
                i.maxGeometryCount = this._maxGeometryCount,
                i.maxVertexCount = this._maxVertexCount,
                i.maxIndexCount = this._maxIndexCount,
                i.geometryInitialized = this._geometryInitialized,
                i.geometryCount = this._geometryCount,
                i.matricesTexture = this._matricesTexture.toJSON(e),
                null !== this.boundingSphere && (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius
                }),
                null !== this.boundingBox && (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray()
                })),
                this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                    this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                r(e.shapes, i)
                            }
                        else
                            r(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            t.push(r(e.materials, this.material[n]));
                        i.material = t
                    } else
                        i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let t = 0; t < this.children.length; t++)
                        i.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        i.animations.push(r(e.animations, n))
                    }
                }
                if (t) {
                    const t = a(e.geometries)
                      , i = a(e.materials)
                      , r = a(e.textures)
                      , s = a(e.images)
                      , o = a(e.shapes)
                      , l = a(e.skeletons)
                      , c = a(e.animations)
                      , h = a(e.nodes);
                    t.length > 0 && (n.geometries = t),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    s.length > 0 && (n.images = s),
                    o.length > 0 && (n.shapes = o),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c),
                    h.length > 0 && (n.nodes = h)
                }
                return n.object = i,
                n;
                function a(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata,
                        t.push(i)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e, t=!0) {
                if (this.name = e.name,
                this.up.copy(e.up),
                this.position.copy(e.position),
                this.rotation.order = e.rotation.order,
                this.quaternion.copy(e.quaternion),
                this.scale.copy(e.scale),
                this.matrix.copy(e.matrix),
                this.matrixWorld.copy(e.matrixWorld),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                this.layers.mask = e.layers.mask,
                this.visible = e.visible,
                this.castShadow = e.castShadow,
                this.receiveShadow = e.receiveShadow,
                this.frustumCulled = e.frustumCulled,
                this.renderOrder = e.renderOrder,
                this.animations = e.animations.slice(),
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                !0 === t)
                    for (let t = 0; t < e.children.length; t++) {
                        const n = e.children[t];
                        this.add(n.clone())
                    }
                return this
            }
        }
        un.DEFAULT_UP = new ht(0,1,0),
        un.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        un.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const pn = new ht
          , fn = new ht
          , mn = new ht
          , gn = new ht
          , vn = new ht
          , wn = new ht
          , yn = new ht
          , _n = new ht
          , xn = new ht
          , bn = new ht;
        let En = !1;
        class Sn {
            constructor(e=new ht, t=new ht, n=new ht) {
                this.a = e,
                this.b = t,
                this.c = n
            }
            static getNormal(e, t, n, i) {
                i.subVectors(n, t),
                pn.subVectors(e, t),
                i.cross(pn);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, i, r) {
                pn.subVectors(i, t),
                fn.subVectors(n, t),
                mn.subVectors(e, t);
                const a = pn.dot(pn)
                  , s = pn.dot(fn)
                  , o = pn.dot(mn)
                  , l = fn.dot(fn)
                  , c = fn.dot(mn)
                  , h = a * l - s * s;
                if (0 === h)
                    return r.set(0, 0, 0),
                    null;
                const d = 1 / h
                  , u = (l * o - s * c) * d
                  , p = (a * c - s * o) * d;
                return r.set(1 - u - p, p, u)
            }
            static containsPoint(e, t, n, i) {
                return null !== this.getBarycoord(e, t, n, i, gn) && (gn.x >= 0 && gn.y >= 0 && gn.x + gn.y <= 1)
            }
            static getUV(e, t, n, i, r, a, s, o) {
                return !1 === En && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                En = !0),
                this.getInterpolation(e, t, n, i, r, a, s, o)
            }
            static getInterpolation(e, t, n, i, r, a, s, o) {
                return null === this.getBarycoord(e, t, n, i, gn) ? (o.x = 0,
                o.y = 0,
                "z"in o && (o.z = 0),
                "w"in o && (o.w = 0),
                null) : (o.setScalar(0),
                o.addScaledVector(r, gn.x),
                o.addScaledVector(a, gn.y),
                o.addScaledVector(s, gn.z),
                o)
            }
            static isFrontFacing(e, t, n, i) {
                return pn.subVectors(n, t),
                fn.subVectors(e, t),
                pn.cross(fn).dot(i) < 0
            }
            set(e, t, n) {
                return this.a.copy(e),
                this.b.copy(t),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(e, t, n, i) {
                return this.a.copy(e[t]),
                this.b.copy(e[n]),
                this.c.copy(e[i]),
                this
            }
            setFromAttributeAndIndices(e, t, n, i) {
                return this.a.fromBufferAttribute(e, t),
                this.b.fromBufferAttribute(e, n),
                this.c.fromBufferAttribute(e, i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a),
                this.b.copy(e.b),
                this.c.copy(e.c),
                this
            }
            getArea() {
                return pn.subVectors(this.c, this.b),
                fn.subVectors(this.a, this.b),
                .5 * pn.cross(fn).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return Sn.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return Sn.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getUV(e, t, n, i, r) {
                return !1 === En && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                En = !0),
                Sn.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
            }
            getInterpolation(e, t, n, i, r) {
                return Sn.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
            }
            containsPoint(e) {
                return Sn.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return Sn.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let a, s;
                vn.subVectors(i, n),
                wn.subVectors(r, n),
                _n.subVectors(e, n);
                const o = vn.dot(_n)
                  , l = wn.dot(_n);
                if (o <= 0 && l <= 0)
                    return t.copy(n);
                xn.subVectors(e, i);
                const c = vn.dot(xn)
                  , h = wn.dot(xn);
                if (c >= 0 && h <= c)
                    return t.copy(i);
                const d = o * h - c * l;
                if (d <= 0 && o >= 0 && c <= 0)
                    return a = o / (o - c),
                    t.copy(n).addScaledVector(vn, a);
                bn.subVectors(e, r);
                const u = vn.dot(bn)
                  , p = wn.dot(bn);
                if (p >= 0 && u <= p)
                    return t.copy(r);
                const f = u * l - o * p;
                if (f <= 0 && l >= 0 && p <= 0)
                    return s = l / (l - p),
                    t.copy(n).addScaledVector(wn, s);
                const m = c * p - u * h;
                if (m <= 0 && h - c >= 0 && u - p >= 0)
                    return yn.subVectors(r, i),
                    s = (h - c) / (h - c + (u - p)),
                    t.copy(i).addScaledVector(yn, s);
                const g = 1 / (m + f + d);
                return a = f * g,
                s = d * g,
                t.copy(n).addScaledVector(vn, a).addScaledVector(wn, s)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        const Mn = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Tn = {
            h: 0,
            s: 0,
            l: 0
        }
          , kn = {
            h: 0,
            s: 0,
            l: 0
        };
        function Cn(e, t, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        class An {
            constructor(e, t, n) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(e, t, n)
            }
            set(e, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = e;
                    t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                } else
                    this.setRGB(e, t, n);
                return this
            }
            setScalar(e) {
                return this.r = e,
                this.g = e,
                this.b = e,
                this
            }
            setHex(e, t=le) {
                return e = Math.floor(e),
                this.r = (e >> 16 & 255) / 255,
                this.g = (e >> 8 & 255) / 255,
                this.b = (255 & e) / 255,
                Ye.toWorkingColorSpace(this, t),
                this
            }
            setRGB(e, t, n, i=Ye.workingColorSpace) {
                return this.r = e,
                this.g = t,
                this.b = n,
                Ye.toWorkingColorSpace(this, i),
                this
            }
            setHSL(e, t, n, i=Ye.workingColorSpace) {
                if (e = Ae(e, 1),
                t = Ce(t, 0, 1),
                n = Ce(n, 0, 1),
                0 === t)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + t) : n + t - n * t
                      , r = 2 * n - i;
                    this.r = Cn(r, i, e + 1 / 3),
                    this.g = Cn(r, i, e),
                    this.b = Cn(r, i, e - 1 / 3)
                }
                return Ye.toWorkingColorSpace(this, i),
                this
            }
            setStyle(e, t=le) {
                function n(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let r;
                    const a = i[1]
                      , s = i[2];
                    switch (a) {
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                            return n(r[4]),
                            this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                            return n(r[4]),
                            this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                            return n(r[4]),
                            this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const n = i[1]
                      , r = n.length;
                    if (3 === r)
                        return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                    if (6 === r)
                        return this.setHex(parseInt(n, 16), t);
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0)
                    return this.setColorName(e, t);
                return this
            }
            setColorName(e, t=le) {
                const n = Mn[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this
            }
            copySRGBToLinear(e) {
                return this.r = Ze(e.r),
                this.g = Ze(e.g),
                this.b = Ze(e.b),
                this
            }
            copyLinearToSRGB(e) {
                return this.r = Ke(e.r),
                this.g = Ke(e.g),
                this.b = Ke(e.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(e=le) {
                return Ye.fromWorkingColorSpace(Pn.copy(this), e),
                65536 * Math.round(Ce(255 * Pn.r, 0, 255)) + 256 * Math.round(Ce(255 * Pn.g, 0, 255)) + Math.round(Ce(255 * Pn.b, 0, 255))
            }
            getHexString(e=le) {
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e, t=Ye.workingColorSpace) {
                Ye.fromWorkingColorSpace(Pn.copy(this), t);
                const n = Pn.r
                  , i = Pn.g
                  , r = Pn.b
                  , a = Math.max(n, i, r)
                  , s = Math.min(n, i, r);
                let o, l;
                const c = (s + a) / 2;
                if (s === a)
                    o = 0,
                    l = 0;
                else {
                    const e = a - s;
                    switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s),
                    a) {
                    case n:
                        o = (i - r) / e + (i < r ? 6 : 0);
                        break;
                    case i:
                        o = (r - n) / e + 2;
                        break;
                    case r:
                        o = (n - i) / e + 4
                    }
                    o /= 6
                }
                return e.h = o,
                e.s = l,
                e.l = c,
                e
            }
            getRGB(e, t=Ye.workingColorSpace) {
                return Ye.fromWorkingColorSpace(Pn.copy(this), t),
                e.r = Pn.r,
                e.g = Pn.g,
                e.b = Pn.b,
                e
            }
            getStyle(e=le) {
                Ye.fromWorkingColorSpace(Pn.copy(this), e);
                const t = Pn.r
                  , n = Pn.g
                  , i = Pn.b;
                return e !== le ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * i)})`
            }
            offsetHSL(e, t, n) {
                return this.getHSL(Tn),
                this.setHSL(Tn.h + e, Tn.s + t, Tn.l + n)
            }
            add(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this
            }
            addColors(e, t) {
                return this.r = e.r + t.r,
                this.g = e.g + t.g,
                this.b = e.b + t.b,
                this
            }
            addScalar(e) {
                return this.r += e,
                this.g += e,
                this.b += e,
                this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r),
                this.g = Math.max(0, this.g - e.g),
                this.b = Math.max(0, this.b - e.b),
                this
            }
            multiply(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this
            }
            multiplyScalar(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t,
                this.g += (e.g - this.g) * t,
                this.b += (e.b - this.b) * t,
                this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n,
                this.g = e.g + (t.g - e.g) * n,
                this.b = e.b + (t.b - e.b) * n,
                this
            }
            lerpHSL(e, t) {
                this.getHSL(Tn),
                e.getHSL(kn);
                const n = Pe(Tn.h, kn.h, t)
                  , i = Pe(Tn.s, kn.s, t)
                  , r = Pe(Tn.l, kn.l, t);
                return this.setHSL(n, i, r),
                this
            }
            setFromVector3(e) {
                return this.r = e.x,
                this.g = e.y,
                this.b = e.z,
                this
            }
            applyMatrix3(e) {
                const t = this.r
                  , n = this.g
                  , i = this.b
                  , r = e.elements;
                return this.r = r[0] * t + r[3] * n + r[6] * i,
                this.g = r[1] * t + r[4] * n + r[7] * i,
                this.b = r[2] * t + r[5] * n + r[8] * i,
                this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, t=0) {
                return this.r = e[t],
                this.g = e[t + 1],
                this.b = e[t + 2],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.r,
                e[t + 1] = this.g,
                e[t + 2] = this.b,
                e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t),
                this.g = e.getY(t),
                this.b = e.getZ(t),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const Pn = new An;
        An.NAMES = Mn;
        let Rn = 0;
        class Ln extends be {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: Rn++
                }),
                this.uuid = ke(),
                this.name = "",
                this.type = "Material",
                this.blending = 1,
                this.side = 0,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = 204,
                this.blendDst = 205,
                this.blendEquation = E,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.blendColor = new An(0,0,0),
                this.blendAlpha = 0,
                this.depthFunc = 3,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = 519,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = ge,
                this.stencilZFail = ge,
                this.stencilZPass = ge,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++,
                this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                            continue
                        }
                        const i = this[t];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata,
                        t.push(i)
                    }
                    return t
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                1 !== this.blending && (n.blending = this.blending),
                0 !== this.side && (n.side = this.side),
                !0 === this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = !0),
                204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
                205 !== this.blendDst && (n.blendDst = this.blendDst),
                this.blendEquation !== E && (n.blendEquation = this.blendEquation),
                null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
                !1 === this.depthTest && (n.depthTest = this.depthTest),
                !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
                0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                this.stencilFail !== ge && (n.stencilFail = this.stencilFail),
                this.stencilZFail !== ge && (n.stencilZFail = this.stencilZFail),
                this.stencilZPass !== ge && (n.stencilZPass = this.stencilZPass),
                !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaHash && (n.alphaHash = !0),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                !0 === this.wireframe && (n.wireframe = !0),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                !1 === this.fog && (n.fog = !1),
                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t) {
                    const t = i(e.textures)
                      , r = i(e.images);
                    t.length > 0 && (n.textures = t),
                    r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name,
                this.blending = e.blending,
                this.side = e.side,
                this.vertexColors = e.vertexColors,
                this.opacity = e.opacity,
                this.transparent = e.transparent,
                this.blendSrc = e.blendSrc,
                this.blendDst = e.blendDst,
                this.blendEquation = e.blendEquation,
                this.blendSrcAlpha = e.blendSrcAlpha,
                this.blendDstAlpha = e.blendDstAlpha,
                this.blendEquationAlpha = e.blendEquationAlpha,
                this.blendColor.copy(e.blendColor),
                this.blendAlpha = e.blendAlpha,
                this.depthFunc = e.depthFunc,
                this.depthTest = e.depthTest,
                this.depthWrite = e.depthWrite,
                this.stencilWriteMask = e.stencilWriteMask,
                this.stencilFunc = e.stencilFunc,
                this.stencilRef = e.stencilRef,
                this.stencilFuncMask = e.stencilFuncMask,
                this.stencilFail = e.stencilFail,
                this.stencilZFail = e.stencilZFail,
                this.stencilZPass = e.stencilZPass,
                this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let i = 0; i !== e; ++i)
                        n[i] = t[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = e.clipIntersection,
                this.clipShadows = e.clipShadows,
                this.shadowSide = e.shadowSide,
                this.colorWrite = e.colorWrite,
                this.precision = e.precision,
                this.polygonOffset = e.polygonOffset,
                this.polygonOffsetFactor = e.polygonOffsetFactor,
                this.polygonOffsetUnits = e.polygonOffsetUnits,
                this.dithering = e.dithering,
                this.alphaTest = e.alphaTest,
                this.alphaHash = e.alphaHash,
                this.alphaToCoverage = e.alphaToCoverage,
                this.premultipliedAlpha = e.premultipliedAlpha,
                this.forceSinglePass = e.forceSinglePass,
                this.visible = e.visible,
                this.toneMapped = e.toneMapped,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
        }
        class In extends Ln {
            constructor(e) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new An(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        const Nn = new ht
          , Un = new De;
        class Dn {
            constructor(e, t, n=!1) {
                if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = e,
                this.itemSize = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.normalized = n,
                this.usage = ve,
                this._updateRange = {
                    offset: 0,
                    count: -1
                },
                this.updateRanges = [],
                this.gpuType = V,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
                this._updateRange
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.name = e.name,
                this.array = new e.array.constructor(e.array),
                this.itemSize = e.itemSize,
                this.count = e.count,
                this.normalized = e.normalized,
                this.usage = e.usage,
                this.gpuType = e.gpuType,
                this
            }
            copyAt(e, t, n) {
                e *= this.itemSize,
                n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                return this
            }
            copyArray(e) {
                return this.array.set(e),
                this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        Un.fromBufferAttribute(this, t),
                        Un.applyMatrix3(e),
                        this.setXY(t, Un.x, Un.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        Nn.fromBufferAttribute(this, t),
                        Nn.applyMatrix3(e),
                        this.setXYZ(t, Nn.x, Nn.y, Nn.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Nn.fromBufferAttribute(this, t),
                    Nn.applyMatrix4(e),
                    this.setXYZ(t, Nn.x, Nn.y, Nn.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Nn.fromBufferAttribute(this, t),
                    Nn.applyNormalMatrix(e),
                    this.setXYZ(t, Nn.x, Nn.y, Nn.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Nn.fromBufferAttribute(this, t),
                    Nn.transformDirection(e),
                    this.setXYZ(t, Nn.x, Nn.y, Nn.z);
                return this
            }
            set(e, t=0) {
                return this.array.set(e, t),
                this
            }
            getComponent(e, t) {
                let n = this.array[e * this.itemSize + t];
                return this.normalized && (n = Ie(n, this.array)),
                n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = Ne(n, this.array)),
                this.array[e * this.itemSize + t] = n,
                this
            }
            getX(e) {
                let t = this.array[e * this.itemSize];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            setX(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.array[e * this.itemSize] = t,
                this
            }
            getY(e) {
                let t = this.array[e * this.itemSize + 1];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            setY(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.array[e * this.itemSize + 1] = t,
                this
            }
            getZ(e) {
                let t = this.array[e * this.itemSize + 2];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            setZ(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.array[e * this.itemSize + 2] = t,
                this
            }
            getW(e) {
                let t = this.array[e * this.itemSize + 3];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            setW(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.array[e * this.itemSize + 3] = t,
                this
            }
            setXY(e, t, n) {
                return e *= this.itemSize,
                this.normalized && (t = Ne(t, this.array),
                n = Ne(n, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, i) {
                return e *= this.itemSize,
                this.normalized && (t = Ne(t, this.array),
                n = Ne(n, this.array),
                i = Ne(i, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = i,
                this
            }
            setXYZW(e, t, n, i, r) {
                return e *= this.itemSize,
                this.normalized && (t = Ne(t, this.array),
                n = Ne(n, this.array),
                i = Ne(i, this.array),
                r = Ne(r, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = i,
                this.array[e + 3] = r,
                this
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name),
                this.usage !== ve && (e.usage = this.usage),
                e
            }
        }
        class Bn extends Dn {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class On extends Dn {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class zn extends Dn {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        let Fn = 0;
        const Wn = new Ft
          , Hn = new un
          , Vn = new ht
          , Gn = new pt
          , jn = new pt
          , Xn = new ht;
        class qn extends be {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: Fn++
                }),
                this.uuid = ke(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new (ze(e) ? On : Bn)(e,1) : this.index = e,
                this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t,
                this
            }
            deleteAttribute(e) {
                return delete this.attributes[e],
                this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t, n=0) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e,
                this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e),
                t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new Be).getNormalMatrix(e);
                    n.applyNormalMatrix(t),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(e),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(e) {
                return Wn.makeRotationFromQuaternion(e),
                this.applyMatrix4(Wn),
                this
            }
            rotateX(e) {
                return Wn.makeRotationX(e),
                this.applyMatrix4(Wn),
                this
            }
            rotateY(e) {
                return Wn.makeRotationY(e),
                this.applyMatrix4(Wn),
                this
            }
            rotateZ(e) {
                return Wn.makeRotationZ(e),
                this.applyMatrix4(Wn),
                this
            }
            translate(e, t, n) {
                return Wn.makeTranslation(e, t, n),
                this.applyMatrix4(Wn),
                this
            }
            scale(e, t, n) {
                return Wn.makeScale(e, t, n),
                this.applyMatrix4(Wn),
                this
            }
            lookAt(e) {
                return Hn.lookAt(e),
                Hn.updateMatrix(),
                this.applyMatrix4(Hn.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Vn).negate(),
                this.translate(Vn.x, Vn.y, Vn.z),
                this
            }
            setFromPoints(e) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    t.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new zn(t,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new pt);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new ht(-1 / 0,-1 / 0,-1 / 0), new ht(1 / 0,1 / 0,1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Gn.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Xn.addVectors(this.boundingBox.min, Gn.min),
                            this.boundingBox.expandByPoint(Xn),
                            Xn.addVectors(this.boundingBox.max, Gn.max),
                            this.boundingBox.expandByPoint(Xn)) : (this.boundingBox.expandByPoint(Gn.min),
                            this.boundingBox.expandByPoint(Gn.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Rt);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new ht, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (Gn.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            jn.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Xn.addVectors(Gn.min, jn.min),
                            Gn.expandByPoint(Xn),
                            Xn.addVectors(Gn.max, jn.max),
                            Gn.expandByPoint(Xn)) : (Gn.expandByPoint(jn.min),
                            Gn.expandByPoint(jn.max))
                        }
                    Gn.getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.count; t < r; t++)
                        Xn.fromBufferAttribute(e, t),
                        i = Math.max(i, n.distanceToSquared(Xn));
                    if (t)
                        for (let r = 0, a = t.length; r < a; r++) {
                            const a = t[r]
                              , s = this.morphTargetsRelative;
                            for (let t = 0, r = a.count; t < r; t++)
                                Xn.fromBufferAttribute(a, t),
                                s && (Vn.fromBufferAttribute(e, t),
                                Xn.add(Vn)),
                                i = Math.max(i, n.distanceToSquared(Xn))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index
                  , t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = e.array
                  , i = t.position.array
                  , r = t.normal.array
                  , a = t.uv.array
                  , s = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Dn(new Float32Array(4 * s),4));
                const o = this.getAttribute("tangent").array
                  , l = []
                  , c = [];
                for (let e = 0; e < s; e++)
                    l[e] = new ht,
                    c[e] = new ht;
                const h = new ht
                  , d = new ht
                  , u = new ht
                  , p = new De
                  , f = new De
                  , m = new De
                  , g = new ht
                  , v = new ht;
                function w(e, t, n) {
                    h.fromArray(i, 3 * e),
                    d.fromArray(i, 3 * t),
                    u.fromArray(i, 3 * n),
                    p.fromArray(a, 2 * e),
                    f.fromArray(a, 2 * t),
                    m.fromArray(a, 2 * n),
                    d.sub(h),
                    u.sub(h),
                    f.sub(p),
                    m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(d).multiplyScalar(m.y).addScaledVector(u, -f.y).multiplyScalar(r),
                    v.copy(u).multiplyScalar(f.x).addScaledVector(d, -m.x).multiplyScalar(r),
                    l[e].add(g),
                    l[t].add(g),
                    l[n].add(g),
                    c[e].add(v),
                    c[t].add(v),
                    c[n].add(v))
                }
                let y = this.groups;
                0 === y.length && (y = [{
                    start: 0,
                    count: n.length
                }]);
                for (let e = 0, t = y.length; e < t; ++e) {
                    const t = y[e]
                      , i = t.start;
                    for (let e = i, r = i + t.count; e < r; e += 3)
                        w(n[e + 0], n[e + 1], n[e + 2])
                }
                const _ = new ht
                  , x = new ht
                  , b = new ht
                  , E = new ht;
                function S(e) {
                    b.fromArray(r, 3 * e),
                    E.copy(b);
                    const t = l[e];
                    _.copy(t),
                    _.sub(b.multiplyScalar(b.dot(t))).normalize(),
                    x.crossVectors(E, t);
                    const n = x.dot(c[e]) < 0 ? -1 : 1;
                    o[4 * e] = _.x,
                    o[4 * e + 1] = _.y,
                    o[4 * e + 2] = _.z,
                    o[4 * e + 3] = n
                }
                for (let e = 0, t = y.length; e < t; ++e) {
                    const t = y[e]
                      , i = t.start;
                    for (let e = i, r = i + t.count; e < r; e += 3)
                        S(n[e + 0]),
                        S(n[e + 1]),
                        S(n[e + 2])
                }
            }
            computeVertexNormals() {
                const e = this.index
                  , t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Dn(new Float32Array(3 * t.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++)
                            n.setXYZ(e, 0, 0, 0);
                    const i = new ht
                      , r = new ht
                      , a = new ht
                      , s = new ht
                      , o = new ht
                      , l = new ht
                      , c = new ht
                      , h = new ht;
                    if (e)
                        for (let d = 0, u = e.count; d < u; d += 3) {
                            const u = e.getX(d + 0)
                              , p = e.getX(d + 1)
                              , f = e.getX(d + 2);
                            i.fromBufferAttribute(t, u),
                            r.fromBufferAttribute(t, p),
                            a.fromBufferAttribute(t, f),
                            c.subVectors(a, r),
                            h.subVectors(i, r),
                            c.cross(h),
                            s.fromBufferAttribute(n, u),
                            o.fromBufferAttribute(n, p),
                            l.fromBufferAttribute(n, f),
                            s.add(c),
                            o.add(c),
                            l.add(c),
                            n.setXYZ(u, s.x, s.y, s.z),
                            n.setXYZ(p, o.x, o.y, o.z),
                            n.setXYZ(f, l.x, l.y, l.z)
                        }
                    else
                        for (let e = 0, s = t.count; e < s; e += 3)
                            i.fromBufferAttribute(t, e + 0),
                            r.fromBufferAttribute(t, e + 1),
                            a.fromBufferAttribute(t, e + 2),
                            c.subVectors(a, r),
                            h.subVectors(i, r),
                            c.cross(h),
                            n.setXYZ(e + 0, c.x, c.y, c.z),
                            n.setXYZ(e + 1, c.x, c.y, c.z),
                            n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++)
                    Xn.fromBufferAttribute(e, t),
                    Xn.normalize(),
                    e.setXYZ(t, Xn.x, Xn.y, Xn.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array
                      , i = e.itemSize
                      , r = e.normalized
                      , a = new n.constructor(t.length * i);
                    let s = 0
                      , o = 0;
                    for (let r = 0, l = t.length; r < l; r++) {
                        s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                        for (let e = 0; e < i; e++)
                            a[o++] = n[s++]
                    }
                    return new Dn(a,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const t = new qn
                  , n = this.index.array
                  , i = this.attributes;
                for (const r in i) {
                    const a = e(i[r], n);
                    t.setAttribute(r, a)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const a = []
                      , s = r[i];
                    for (let t = 0, i = s.length; t < i; t++) {
                        const i = e(s[t], n);
                        a.push(i)
                    }
                    t.morphAttributes[i] = a
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const a = this.groups;
                for (let e = 0, n = a.length; e < n; e++) {
                    const n = a[e];
                    t.addGroup(n.start, n.count, n.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid,
                e.type = this.type,
                "" !== this.name && (e.name = this.name),
                Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t)
                        void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const t in n) {
                    const i = n[t];
                    e.data.attributes[t] = i.toJSON(e.data)
                }
                const i = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const n = this.morphAttributes[t]
                      , a = [];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        a.push(i.toJSON(e.data))
                    }
                    a.length > 0 && (i[t] = a,
                    r = !0)
                }
                r && (e.data.morphAttributes = i,
                e.data.morphTargetsRelative = this.morphTargetsRelative);
                const a = this.groups;
                a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                const s = this.boundingSphere;
                return null !== s && (e.data.boundingSphere = {
                    center: s.center.toArray(),
                    radius: s.radius
                }),
                e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const i = e.attributes;
                for (const e in i) {
                    const n = i[e];
                    this.setAttribute(e, n.clone(t))
                }
                const r = e.morphAttributes;
                for (const e in r) {
                    const n = []
                      , i = r[e];
                    for (let e = 0, r = i.length; e < r; e++)
                        n.push(i[e].clone(t));
                    this.morphAttributes[e] = n
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const a = e.groups;
                for (let e = 0, t = a.length; e < t; e++) {
                    const t = a[e];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const s = e.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const o = e.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()),
                this.drawRange.start = e.drawRange.start,
                this.drawRange.count = e.drawRange.count,
                this.userData = e.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Yn = new Ft
          , Zn = new zt
          , Kn = new Rt
          , Jn = new ht
          , Qn = new ht
          , $n = new ht
          , ei = new ht
          , ti = new ht
          , ni = new ht
          , ii = new De
          , ri = new De
          , ai = new De
          , si = new ht
          , oi = new ht
          , li = new ht
          , ci = new ht
          , hi = new ht;
        class di extends un {
            constructor(e=new qn, t=new In) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            getVertexPosition(e, t) {
                const n = this.geometry
                  , i = n.attributes.position
                  , r = n.morphAttributes.position
                  , a = n.morphTargetsRelative;
                t.fromBufferAttribute(i, e);
                const s = this.morphTargetInfluences;
                if (r && s) {
                    ni.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = s[n]
                          , o = r[n];
                        0 !== i && (ti.fromBufferAttribute(o, e),
                        a ? ni.addScaledVector(ti, i) : ni.addScaledVector(ti.sub(t), i))
                    }
                    t.add(ni)
                }
                return t
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    Kn.copy(n.boundingSphere),
                    Kn.applyMatrix4(r),
                    Zn.copy(e.ray).recast(e.near),
                    !1 === Kn.containsPoint(Zn.origin)) {
                        if (null === Zn.intersectSphere(Kn, Jn))
                            return;
                        if (Zn.origin.distanceToSquared(Jn) > (e.far - e.near) ** 2)
                            return
                    }
                    Yn.copy(r).invert(),
                    Zn.copy(e.ray).applyMatrix4(Yn),
                    null !== n.boundingBox && !1 === Zn.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Zn)
                }
            }
            _computeIntersections(e, t, n) {
                let i;
                const r = this.geometry
                  , a = this.material
                  , s = r.index
                  , o = r.attributes.position
                  , l = r.attributes.uv
                  , c = r.attributes.uv1
                  , h = r.attributes.normal
                  , d = r.groups
                  , u = r.drawRange;
                if (null !== s)
                    if (Array.isArray(a))
                        for (let r = 0, o = d.length; r < o; r++) {
                            const o = d[r]
                              , p = a[o.materialIndex];
                            for (let r = Math.max(o.start, u.start), a = Math.min(s.count, Math.min(o.start + o.count, u.start + u.count)); r < a; r += 3) {
                                i = ui(this, p, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = o.materialIndex,
                                t.push(i))
                            }
                        }
                    else {
                        for (let r = Math.max(0, u.start), o = Math.min(s.count, u.start + u.count); r < o; r += 3) {
                            i = ui(this, a, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                            i && (i.faceIndex = Math.floor(r / 3),
                            t.push(i))
                        }
                    }
                else if (void 0 !== o)
                    if (Array.isArray(a))
                        for (let r = 0, s = d.length; r < s; r++) {
                            const s = d[r]
                              , p = a[s.materialIndex];
                            for (let r = Math.max(s.start, u.start), a = Math.min(o.count, Math.min(s.start + s.count, u.start + u.count)); r < a; r += 3) {
                                i = ui(this, p, e, n, l, c, h, r, r + 1, r + 2),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = s.materialIndex,
                                t.push(i))
                            }
                        }
                    else {
                        for (let r = Math.max(0, u.start), s = Math.min(o.count, u.start + u.count); r < s; r += 3) {
                            i = ui(this, a, e, n, l, c, h, r, r + 1, r + 2),
                            i && (i.faceIndex = Math.floor(r / 3),
                            t.push(i))
                        }
                    }
            }
        }
        function ui(e, t, n, i, r, a, s, o, l, c) {
            e.getVertexPosition(o, Qn),
            e.getVertexPosition(l, $n),
            e.getVertexPosition(c, ei);
            const h = function(e, t, n, i, r, a, s, o) {
                let l;
                if (l = 1 === t.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 0 === t.side, o),
                null === l)
                    return null;
                hi.copy(o),
                hi.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(hi);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: hi.clone(),
                    object: e
                }
            }(e, t, n, i, Qn, $n, ei, ci);
            if (h) {
                r && (ii.fromBufferAttribute(r, o),
                ri.fromBufferAttribute(r, l),
                ai.fromBufferAttribute(r, c),
                h.uv = Sn.getInterpolation(ci, Qn, $n, ei, ii, ri, ai, new De)),
                a && (ii.fromBufferAttribute(a, o),
                ri.fromBufferAttribute(a, l),
                ai.fromBufferAttribute(a, c),
                h.uv1 = Sn.getInterpolation(ci, Qn, $n, ei, ii, ri, ai, new De),
                h.uv2 = h.uv1),
                s && (si.fromBufferAttribute(s, o),
                oi.fromBufferAttribute(s, l),
                li.fromBufferAttribute(s, c),
                h.normal = Sn.getInterpolation(ci, Qn, $n, ei, si, oi, li, new ht),
                h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
                const e = {
                    a: o,
                    b: l,
                    c,
                    normal: new ht,
                    materialIndex: 0
                };
                Sn.getNormal(Qn, $n, ei, e.normal),
                h.face = e
            }
            return h
        }
        class pi extends qn {
            constructor(e=1, t=1, n=1, i=1, r=1, a=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                };
                const s = this;
                i = Math.floor(i),
                r = Math.floor(r),
                a = Math.floor(a);
                const o = []
                  , l = []
                  , c = []
                  , h = [];
                let d = 0
                  , u = 0;
                function p(e, t, n, i, r, a, p, f, m, g, v) {
                    const w = a / m
                      , y = p / g
                      , _ = a / 2
                      , x = p / 2
                      , b = f / 2
                      , E = m + 1
                      , S = g + 1;
                    let M = 0
                      , T = 0;
                    const k = new ht;
                    for (let a = 0; a < S; a++) {
                        const s = a * y - x;
                        for (let o = 0; o < E; o++) {
                            const d = o * w - _;
                            k[e] = d * i,
                            k[t] = s * r,
                            k[n] = b,
                            l.push(k.x, k.y, k.z),
                            k[e] = 0,
                            k[t] = 0,
                            k[n] = f > 0 ? 1 : -1,
                            c.push(k.x, k.y, k.z),
                            h.push(o / m),
                            h.push(1 - a / g),
                            M += 1
                        }
                    }
                    for (let e = 0; e < g; e++)
                        for (let t = 0; t < m; t++) {
                            const n = d + t + E * e
                              , i = d + t + E * (e + 1)
                              , r = d + (t + 1) + E * (e + 1)
                              , a = d + (t + 1) + E * e;
                            o.push(n, i, a),
                            o.push(i, r, a),
                            T += 6
                        }
                    s.addGroup(u, T, v),
                    u += T,
                    d += M
                }
                p("z", "y", "x", -1, -1, n, t, e, a, r, 0),
                p("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
                p("x", "z", "y", 1, 1, e, n, t, i, a, 2),
                p("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
                p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
                p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
                this.setIndex(o),
                this.setAttribute("position", new zn(l,3)),
                this.setAttribute("normal", new zn(c,3)),
                this.setAttribute("uv", new zn(h,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new pi(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
            }
        }
        function fi(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const i in e[n]) {
                    const r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                }
            }
            return t
        }
        function mi(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const i = fi(e[n]);
                for (const e in i)
                    t[e] = i[e]
            }
            return t
        }
        function gi(e) {
            return null === e.getRenderTarget() ? e.outputColorSpace : Ye.workingColorSpace
        }
        const vi = {
            clone: fi,
            merge: mi
        };
        class wi extends Ln {
            constructor(e) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                    clipCullDistance: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== e && this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.fragmentShader = e.fragmentShader,
                this.vertexShader = e.vertexShader,
                this.uniforms = fi(e.uniforms),
                this.uniformsGroups = function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }(e.uniformsGroups),
                this.defines = Object.assign({}, e.defines),
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.fog = e.fog,
                this.lights = e.lights,
                this.clipping = e.clipping,
                this.extensions = Object.assign({}, e.extensions),
                this.glslVersion = e.glslVersion,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion,
                t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(e).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : t.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                t.vertexShader = this.vertexShader,
                t.fragmentShader = this.fragmentShader,
                t.lights = this.lights,
                t.clipping = this.clipping;
                const n = {};
                for (const e in this.extensions)
                    !0 === this.extensions[e] && (n[e] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n),
                t
            }
        }
        class yi extends un {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new Ft,
                this.projectionMatrix = new Ft,
                this.projectionMatrixInverse = new Ft,
                this.coordinateSystem = _e
            }
            copy(e, t) {
                return super.copy(e, t),
                this.matrixWorldInverse.copy(e.matrixWorldInverse),
                this.projectionMatrix.copy(e.projectionMatrix),
                this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                this.coordinateSystem = e.coordinateSystem,
                this
            }
            getWorldDirection(e) {
                return super.getWorldDirection(e).negate()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class _i extends yi {
            constructor(e=50, t=1, n=.1, i=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = e,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = t,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.fov = e.fov,
                this.zoom = e.zoom,
                this.near = e.near,
                this.far = e.far,
                this.focus = e.focus,
                this.aspect = e.aspect,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this.filmGauge = e.filmGauge,
                this.filmOffset = e.filmOffset,
                this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * Te * Math.atan(t),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * Me * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * Te * Math.atan(Math.tan(.5 * Me * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(e, t, n, i, r, a) {
                this.aspect = e / t,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = a,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * Me * this.fov) / this.zoom
                  , n = 2 * t
                  , i = this.aspect * n
                  , r = -.5 * i;
                const a = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = a.fullWidth
                      , s = a.fullHeight;
                    r += a.offsetX * i / e,
                    t -= a.offsetY * n / s,
                    i *= a.width / e,
                    n *= a.height / s
                }
                const s = this.filmOffset;
                0 !== s && (r += e * s / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov,
                t.object.zoom = this.zoom,
                t.object.near = this.near,
                t.object.far = this.far,
                t.object.focus = this.focus,
                t.object.aspect = this.aspect,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t.object.filmGauge = this.filmGauge,
                t.object.filmOffset = this.filmOffset,
                t
            }
        }
        const xi = -90;
        class bi extends un {
            constructor(e, t, n) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = n,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const i = new _i(xi,1,e,t);
                i.layers = this.layers,
                this.add(i);
                const r = new _i(xi,1,e,t);
                r.layers = this.layers,
                this.add(r);
                const a = new _i(xi,1,e,t);
                a.layers = this.layers,
                this.add(a);
                const s = new _i(xi,1,e,t);
                s.layers = this.layers,
                this.add(s);
                const o = new _i(xi,1,e,t);
                o.layers = this.layers,
                this.add(o);
                const l = new _i(xi,1,e,t);
                l.layers = this.layers,
                this.add(l)
            }
            updateCoordinateSystem() {
                const e = this.coordinateSystem
                  , t = this.children.concat()
                  , [n,i,r,a,s,o] = t;
                for (const e of t)
                    this.remove(e);
                if (e === _e)
                    n.up.set(0, 1, 0),
                    n.lookAt(1, 0, 0),
                    i.up.set(0, 1, 0),
                    i.lookAt(-1, 0, 0),
                    r.up.set(0, 0, -1),
                    r.lookAt(0, 1, 0),
                    a.up.set(0, 0, 1),
                    a.lookAt(0, -1, 0),
                    s.up.set(0, 1, 0),
                    s.lookAt(0, 0, 1),
                    o.up.set(0, 1, 0),
                    o.lookAt(0, 0, -1);
                else {
                    if (e !== xe)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    n.up.set(0, -1, 0),
                    n.lookAt(-1, 0, 0),
                    i.up.set(0, -1, 0),
                    i.lookAt(1, 0, 0),
                    r.up.set(0, 0, 1),
                    r.lookAt(0, 1, 0),
                    a.up.set(0, 0, -1),
                    a.lookAt(0, -1, 0),
                    s.up.set(0, -1, 0),
                    s.lookAt(0, 0, 1),
                    o.up.set(0, -1, 0),
                    o.lookAt(0, 0, -1)
                }
                for (const e of t)
                    this.add(e),
                    e.updateMatrixWorld()
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: n, activeMipmapLevel: i} = this;
                this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                this.updateCoordinateSystem());
                const [r,a,s,o,l,c] = this.children
                  , h = e.getRenderTarget()
                  , d = e.getActiveCubeFace()
                  , u = e.getActiveMipmapLevel()
                  , p = e.xr.enabled;
                e.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                e.setRenderTarget(n, 0, i),
                e.render(t, r),
                e.setRenderTarget(n, 1, i),
                e.render(t, a),
                e.setRenderTarget(n, 2, i),
                e.render(t, s),
                e.setRenderTarget(n, 3, i),
                e.render(t, o),
                e.setRenderTarget(n, 4, i),
                e.render(t, l),
                n.texture.generateMipmaps = f,
                e.setRenderTarget(n, 5, i),
                e.render(t, c),
                e.setRenderTarget(h, d, u),
                e.xr.enabled = p,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class Ei extends it {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : M, n, i, r, a, s, o, l, c),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class Si extends st {
            constructor(e=1, t={}) {
                super(e, e, t),
                this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: e,
                    height: e,
                    depth: 1
                }
                  , i = [n, n, n, n, n, n];
                void 0 !== t.encoding && (Ve("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
                t.colorSpace = t.encoding === se ? le : oe),
                this.texture = new Ei(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
                this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : D
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type,
                this.texture.colorSpace = t.colorSpace,
                this.texture.generateMipmaps = t.generateMipmaps,
                this.texture.minFilter = t.minFilter,
                this.texture.magFilter = t.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , i = new pi(5,5,5)
                  , r = new wi({
                    name: "CubemapFromEquirect",
                    uniforms: fi(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
                r.uniforms.tEquirect.value = t;
                const a = new di(i,r)
                  , s = t.minFilter;
                t.minFilter === O && (t.minFilter = D);
                return new bi(1,10,this).update(e, a),
                t.minFilter = s,
                a.geometry.dispose(),
                a.material.dispose(),
                this
            }
            clear(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    e.setRenderTarget(this, r),
                    e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }
        const Mi = new ht
          , Ti = new ht
          , ki = new Be;
        class Ci {
            constructor(e=new ht(1,0,0), t=0) {
                this.isPlane = !0,
                this.normal = e,
                this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e),
                this.constant = t,
                this
            }
            setComponents(e, t, n, i) {
                return this.normal.set(e, t, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e),
                this.constant = -t.dot(this.normal),
                this
            }
            setFromCoplanarPoints(e, t, n) {
                const i = Mi.subVectors(n, t).cross(Ti.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e),
                this
            }
            copy(e) {
                return this.normal.copy(e.normal),
                this.constant = e.constant,
                this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e),
                this.constant *= e,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, t) {
                const n = e.delta(Mi)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start)
                  , n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || ki.getNormalMatrix(e)
                  , i = this.coplanarPoint(Mi).applyMatrix4(e)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal),
                this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Ai = new Rt
          , Pi = new ht;
        class Ri {
            constructor(e=new Ci, t=new Ci, n=new Ci, i=new Ci, r=new Ci, a=new Ci) {
                this.planes = [e, t, n, i, r, a]
            }
            set(e, t, n, i, r, a) {
                const s = this.planes;
                return s[0].copy(e),
                s[1].copy(t),
                s[2].copy(n),
                s[3].copy(i),
                s[4].copy(r),
                s[5].copy(a),
                this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e, t=2e3) {
                const n = this.planes
                  , i = e.elements
                  , r = i[0]
                  , a = i[1]
                  , s = i[2]
                  , o = i[3]
                  , l = i[4]
                  , c = i[5]
                  , h = i[6]
                  , d = i[7]
                  , u = i[8]
                  , p = i[9]
                  , f = i[10]
                  , m = i[11]
                  , g = i[12]
                  , v = i[13]
                  , w = i[14]
                  , y = i[15];
                if (n[0].setComponents(o - r, d - l, m - u, y - g).normalize(),
                n[1].setComponents(o + r, d + l, m + u, y + g).normalize(),
                n[2].setComponents(o + a, d + c, m + p, y + v).normalize(),
                n[3].setComponents(o - a, d - c, m - p, y - v).normalize(),
                n[4].setComponents(o - s, d - h, m - f, y - w).normalize(),
                t === _e)
                    n[5].setComponents(o + s, d + h, m + f, y + w).normalize();
                else {
                    if (t !== xe)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    n[5].setComponents(s, h, f, w).normalize()
                }
                return this
            }
            intersectsObject(e) {
                if (void 0 !== e.boundingSphere)
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Ai.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                else {
                    const t = e.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    Ai.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                }
                return this.intersectsSphere(Ai)
            }
            intersectsSprite(e) {
                return Ai.center.set(0, 0, 0),
                Ai.radius = .7071067811865476,
                Ai.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(Ai)
            }
            intersectsSphere(e) {
                const t = this.planes
                  , n = e.center
                  , i = -e.radius;
                for (let e = 0; e < 6; e++) {
                    if (t[e].distanceToPoint(n) < i)
                        return !1
                }
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (Pi.x = i.normal.x > 0 ? e.max.x : e.min.x,
                    Pi.y = i.normal.y > 0 ? e.max.y : e.min.y,
                    Pi.z = i.normal.z > 0 ? e.max.z : e.min.z,
                    i.distanceToPoint(Pi) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function Li() {
            let e = null
              , t = !1
              , n = null
              , i = null;
            function r(t, a) {
                n(t, a),
                i = e.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (i = e.requestAnimationFrame(r),
                    t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(i),
                    t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }
        function Ii(e, t) {
            const n = t.isWebGL2
              , i = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data),
                    i.get(e)
                },
                remove: function(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const n = i.get(t);
                    n && (e.deleteBuffer(n.buffer),
                    i.delete(t))
                },
                update: function(t, r) {
                    if (t.isGLBufferAttribute) {
                        const e = i.get(t);
                        return void ((!e || e.version < t.version) && i.set(t, {
                            buffer: t.buffer,
                            type: t.type,
                            bytesPerElement: t.elementSize,
                            version: t.version
                        }))
                    }
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const a = i.get(t);
                    if (void 0 === a)
                        i.set(t, function(t, i) {
                            const r = t.array
                              , a = t.usage
                              , s = r.byteLength
                              , o = e.createBuffer();
                            let l;
                            if (e.bindBuffer(i, o),
                            e.bufferData(i, r, a),
                            t.onUploadCallback(),
                            r instanceof Float32Array)
                                l = e.FLOAT;
                            else if (r instanceof Uint16Array)
                                if (t.isFloat16BufferAttribute) {
                                    if (!n)
                                        throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                    l = e.HALF_FLOAT
                                } else
                                    l = e.UNSIGNED_SHORT;
                            else if (r instanceof Int16Array)
                                l = e.SHORT;
                            else if (r instanceof Uint32Array)
                                l = e.UNSIGNED_INT;
                            else if (r instanceof Int32Array)
                                l = e.INT;
                            else if (r instanceof Int8Array)
                                l = e.BYTE;
                            else if (r instanceof Uint8Array)
                                l = e.UNSIGNED_BYTE;
                            else {
                                if (!(r instanceof Uint8ClampedArray))
                                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                                l = e.UNSIGNED_BYTE
                            }
                            return {
                                buffer: o,
                                type: l,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: s
                            }
                        }(t, r));
                    else if (a.version < t.version) {
                        if (a.size !== t.array.byteLength)
                            throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        !function(t, i, r) {
                            const a = i.array
                              , s = i._updateRange
                              , o = i.updateRanges;
                            if (e.bindBuffer(r, t),
                            -1 === s.count && 0 === o.length && e.bufferSubData(r, 0, a),
                            0 !== o.length) {
                                for (let t = 0, i = o.length; t < i; t++) {
                                    const i = o[t];
                                    n ? e.bufferSubData(r, i.start * a.BYTES_PER_ELEMENT, a, i.start, i.count) : e.bufferSubData(r, i.start * a.BYTES_PER_ELEMENT, a.subarray(i.start, i.start + i.count))
                                }
                                i.clearUpdateRanges()
                            }
                            -1 !== s.count && (n ? e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)),
                            s.count = -1),
                            i.onUploadCallback()
                        }(a.buffer, t, r),
                        a.version = t.version
                    }
                }
            }
        }
        class Ni extends qn {
            constructor(e=1, t=1, n=1, i=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = e / 2
                  , a = t / 2
                  , s = Math.floor(n)
                  , o = Math.floor(i)
                  , l = s + 1
                  , c = o + 1
                  , h = e / s
                  , d = t / o
                  , u = []
                  , p = []
                  , f = []
                  , m = [];
                for (let e = 0; e < c; e++) {
                    const t = e * d - a;
                    for (let n = 0; n < l; n++) {
                        const i = n * h - r;
                        p.push(i, -t, 0),
                        f.push(0, 0, 1),
                        m.push(n / s),
                        m.push(1 - e / o)
                    }
                }
                for (let e = 0; e < o; e++)
                    for (let t = 0; t < s; t++) {
                        const n = t + l * e
                          , i = t + l * (e + 1)
                          , r = t + 1 + l * (e + 1)
                          , a = t + 1 + l * e;
                        u.push(n, i, a),
                        u.push(i, r, a)
                    }
                this.setIndex(u),
                this.setAttribute("position", new zn(p,3)),
                this.setAttribute("normal", new zn(f,3)),
                this.setAttribute("uv", new zn(m,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Ni(e.width,e.height,e.widthSegments,e.heightSegments)
            }
        }
        const Ui = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 0.01 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        }
          , Di = {
            common: {
                diffuse: {
                    value: new An(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Be
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Be
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new Be
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new Be
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new Be
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new Be
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new Be
                },
                normalScale: {
                    value: new De(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new Be
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new Be
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new Be
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new Be
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new An(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new An(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Be
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Be
                }
            },
            sprite: {
                diffuse: {
                    value: new An(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new De(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Be
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Be
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , Bi = {
            basic: {
                uniforms: mi([Di.common, Di.specularmap, Di.envmap, Di.aomap, Di.lightmap, Di.fog]),
                vertexShader: Ui.meshbasic_vert,
                fragmentShader: Ui.meshbasic_frag
            },
            lambert: {
                uniforms: mi([Di.common, Di.specularmap, Di.envmap, Di.aomap, Di.lightmap, Di.emissivemap, Di.bumpmap, Di.normalmap, Di.displacementmap, Di.fog, Di.lights, {
                    emissive: {
                        value: new An(0)
                    }
                }]),
                vertexShader: Ui.meshlambert_vert,
                fragmentShader: Ui.meshlambert_frag
            },
            phong: {
                uniforms: mi([Di.common, Di.specularmap, Di.envmap, Di.aomap, Di.lightmap, Di.emissivemap, Di.bumpmap, Di.normalmap, Di.displacementmap, Di.fog, Di.lights, {
                    emissive: {
                        value: new An(0)
                    },
                    specular: {
                        value: new An(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Ui.meshphong_vert,
                fragmentShader: Ui.meshphong_frag
            },
            standard: {
                uniforms: mi([Di.common, Di.envmap, Di.aomap, Di.lightmap, Di.emissivemap, Di.bumpmap, Di.normalmap, Di.displacementmap, Di.roughnessmap, Di.metalnessmap, Di.fog, Di.lights, {
                    emissive: {
                        value: new An(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Ui.meshphysical_vert,
                fragmentShader: Ui.meshphysical_frag
            },
            toon: {
                uniforms: mi([Di.common, Di.aomap, Di.lightmap, Di.emissivemap, Di.bumpmap, Di.normalmap, Di.displacementmap, Di.gradientmap, Di.fog, Di.lights, {
                    emissive: {
                        value: new An(0)
                    }
                }]),
                vertexShader: Ui.meshtoon_vert,
                fragmentShader: Ui.meshtoon_frag
            },
            matcap: {
                uniforms: mi([Di.common, Di.bumpmap, Di.normalmap, Di.displacementmap, Di.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Ui.meshmatcap_vert,
                fragmentShader: Ui.meshmatcap_frag
            },
            points: {
                uniforms: mi([Di.points, Di.fog]),
                vertexShader: Ui.points_vert,
                fragmentShader: Ui.points_frag
            },
            dashed: {
                uniforms: mi([Di.common, Di.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Ui.linedashed_vert,
                fragmentShader: Ui.linedashed_frag
            },
            depth: {
                uniforms: mi([Di.common, Di.displacementmap]),
                vertexShader: Ui.depth_vert,
                fragmentShader: Ui.depth_frag
            },
            normal: {
                uniforms: mi([Di.common, Di.bumpmap, Di.normalmap, Di.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ui.meshnormal_vert,
                fragmentShader: Ui.meshnormal_frag
            },
            sprite: {
                uniforms: mi([Di.sprite, Di.fog]),
                vertexShader: Ui.sprite_vert,
                fragmentShader: Ui.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Be
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: Ui.background_vert,
                fragmentShader: Ui.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: Ui.backgroundCube_vert,
                fragmentShader: Ui.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: Ui.cube_vert,
                fragmentShader: Ui.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: Ui.equirect_vert,
                fragmentShader: Ui.equirect_frag
            },
            distanceRGBA: {
                uniforms: mi([Di.common, Di.displacementmap, {
                    referencePosition: {
                        value: new ht
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: Ui.distanceRGBA_vert,
                fragmentShader: Ui.distanceRGBA_frag
            },
            shadow: {
                uniforms: mi([Di.lights, Di.fog, {
                    color: {
                        value: new An(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Ui.shadow_vert,
                fragmentShader: Ui.shadow_frag
            }
        };
        Bi.physical = {
            uniforms: mi([Bi.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Be
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Be
                },
                clearcoatNormalScale: {
                    value: new De(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Be
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Be
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Be
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new An(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Be
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Be
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Be
                },
                transmissionSamplerSize: {
                    value: new De
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Be
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new An(0)
                },
                specularColor: {
                    value: new An(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Be
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Be
                },
                anisotropyVector: {
                    value: new De
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Be
                }
            }]),
            vertexShader: Ui.meshphysical_vert,
            fragmentShader: Ui.meshphysical_frag
        };
        const Oi = {
            r: 0,
            b: 0,
            g: 0
        };
        function zi(e, t, n, i, r, a, s) {
            const o = new An(0);
            let l, c, h = !0 === a ? 0 : 1, d = null, u = 0, p = null;
            function f(t, n) {
                t.getRGB(Oi, gi(e)),
                i.buffers.color.setClear(Oi.r, Oi.g, Oi.b, n, s)
            }
            return {
                getClearColor: function() {
                    return o
                },
                setClearColor: function(e, t=1) {
                    o.set(e),
                    h = t,
                    f(o, h)
                },
                getClearAlpha: function() {
                    return h
                },
                setClearAlpha: function(e) {
                    h = e,
                    f(o, h)
                },
                render: function(a, m) {
                    let g = !1
                      , v = !0 === m.isScene ? m.background : null;
                    if (v && v.isTexture) {
                        v = (m.backgroundBlurriness > 0 ? n : t).get(v)
                    }
                    null === v ? f(o, h) : v && v.isColor && (f(v, 1),
                    g = !0);
                    const w = e.xr.getEnvironmentBlendMode();
                    "additive" === w ? i.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === w && i.buffers.color.setClear(0, 0, 0, 0, s),
                    (e.autoClear || g) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                    v && (v.isCubeTexture || v.mapping === A) ? (void 0 === c && (c = new di(new pi(1,1,1),new wi({
                        name: "BackgroundCubeMaterial",
                        uniforms: fi(Bi.backgroundCube.uniforms),
                        vertexShader: Bi.backgroundCube.vertexShader,
                        fragmentShader: Bi.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    c.geometry.deleteAttribute("normal"),
                    c.geometry.deleteAttribute("uv"),
                    c.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    r.update(c)),
                    c.material.uniforms.envMap.value = v,
                    c.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1,
                    c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness,
                    c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity,
                    c.material.toneMapped = Ye.getTransfer(v.colorSpace) !== pe,
                    d === v && u === v.version && p === e.toneMapping || (c.material.needsUpdate = !0,
                    d = v,
                    u = v.version,
                    p = e.toneMapping),
                    c.layers.enableAll(),
                    a.unshift(c, c.geometry, c.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new di(new Ni(2,2),new wi({
                        name: "BackgroundMaterial",
                        uniforms: fi(Bi.background.uniforms),
                        vertexShader: Bi.background.vertexShader,
                        fragmentShader: Bi.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    l.geometry.deleteAttribute("normal"),
                    Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    r.update(l)),
                    l.material.uniforms.t2D.value = v,
                    l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity,
                    l.material.toneMapped = Ye.getTransfer(v.colorSpace) !== pe,
                    !0 === v.matrixAutoUpdate && v.updateMatrix(),
                    l.material.uniforms.uvTransform.value.copy(v.matrix),
                    d === v && u === v.version && p === e.toneMapping || (l.material.needsUpdate = !0,
                    d = v,
                    u = v.version,
                    p = e.toneMapping),
                    l.layers.enableAll(),
                    a.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }
        function Fi(e, t, n, i) {
            const r = e.getParameter(e.MAX_VERTEX_ATTRIBS)
              , a = i.isWebGL2 ? null : t.get("OES_vertex_array_object")
              , s = i.isWebGL2 || null !== a
              , o = {}
              , l = p(null);
            let c = l
              , h = !1;
            function d(t) {
                return i.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
            }
            function u(t) {
                return i.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
            }
            function p(e) {
                const t = []
                  , n = []
                  , i = [];
                for (let e = 0; e < r; e++)
                    t[e] = 0,
                    n[e] = 0,
                    i[e] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: e,
                    attributes: {},
                    index: null
                }
            }
            function f() {
                const e = c.newAttributes;
                for (let t = 0, n = e.length; t < n; t++)
                    e[t] = 0
            }
            function m(e) {
                g(e, 0)
            }
            function g(n, r) {
                const a = c.newAttributes
                  , s = c.enabledAttributes
                  , o = c.attributeDivisors;
                if (a[n] = 1,
                0 === s[n] && (e.enableVertexAttribArray(n),
                s[n] = 1),
                o[n] !== r) {
                    (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
                    o[n] = r
                }
            }
            function v() {
                const t = c.newAttributes
                  , n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== t[i] && (e.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function w(t, n, i, r, a, s, o) {
                !0 === o ? e.vertexAttribIPointer(t, n, i, a, s) : e.vertexAttribPointer(t, n, i, r, a, s)
            }
            function y() {
                _(),
                h = !0,
                c !== l && (c = l,
                d(c.object))
            }
            function _() {
                l.geometry = null,
                l.program = null,
                l.wireframe = !1
            }
            return {
                setup: function(r, l, u, y, _) {
                    let x = !1;
                    if (s) {
                        const t = function(t, n, r) {
                            const s = !0 === r.wireframe;
                            let l = o[t.id];
                            void 0 === l && (l = {},
                            o[t.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {},
                            l[n.id] = c);
                            let h = c[s];
                            void 0 === h && (h = p(i.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()),
                            c[s] = h);
                            return h
                        }(y, u, l);
                        c !== t && (c = t,
                        d(c.object)),
                        x = function(e, t, n, i) {
                            const r = c.attributes
                              , a = t.attributes;
                            let s = 0;
                            const o = n.getAttributes();
                            for (const t in o) {
                                if (o[t].location >= 0) {
                                    const n = r[t];
                                    let i = a[t];
                                    if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                                    "instanceColor" === t && e.instanceColor && (i = e.instanceColor)),
                                    void 0 === n)
                                        return !0;
                                    if (n.attribute !== i)
                                        return !0;
                                    if (i && n.data !== i.data)
                                        return !0;
                                    s++
                                }
                            }
                            return c.attributesNum !== s || c.index !== i
                        }(r, y, u, _),
                        x && function(e, t, n, i) {
                            const r = {}
                              , a = t.attributes;
                            let s = 0;
                            const o = n.getAttributes();
                            for (const t in o) {
                                if (o[t].location >= 0) {
                                    let n = a[t];
                                    void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                                    "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                    const i = {};
                                    i.attribute = n,
                                    n && n.data && (i.data = n.data),
                                    r[t] = i,
                                    s++
                                }
                            }
                            c.attributes = r,
                            c.attributesNum = s,
                            c.index = i
                        }(r, y, u, _)
                    } else {
                        const e = !0 === l.wireframe;
                        c.geometry === y.id && c.program === u.id && c.wireframe === e || (c.geometry = y.id,
                        c.program = u.id,
                        c.wireframe = e,
                        x = !0)
                    }
                    null !== _ && n.update(_, e.ELEMENT_ARRAY_BUFFER),
                    (x || h) && (h = !1,
                    function(r, a, s, o) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                            return;
                        f();
                        const l = o.attributes
                          , c = s.getAttributes()
                          , h = a.defaultAttributeValues;
                        for (const t in c) {
                            const a = c[t];
                            if (a.location >= 0) {
                                let s = l[t];
                                if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix),
                                "instanceColor" === t && r.instanceColor && (s = r.instanceColor)),
                                void 0 !== s) {
                                    const t = s.normalized
                                      , l = s.itemSize
                                      , c = n.get(s);
                                    if (void 0 === c)
                                        continue;
                                    const h = c.buffer
                                      , d = c.type
                                      , u = c.bytesPerElement
                                      , p = !0 === i.isWebGL2 && (d === e.INT || d === e.UNSIGNED_INT || s.gpuType === W);
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data
                                          , i = n.stride
                                          , c = s.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < a.locationSize; e++)
                                                g(a.location + e, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let e = 0; e < a.locationSize; e++)
                                                m(a.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, h);
                                        for (let e = 0; e < a.locationSize; e++)
                                            w(a.location + e, l / a.locationSize, d, t, i * u, (c + l / a.locationSize * e) * u, p)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let e = 0; e < a.locationSize; e++)
                                                g(a.location + e, s.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let e = 0; e < a.locationSize; e++)
                                                m(a.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, h);
                                        for (let e = 0; e < a.locationSize; e++)
                                            w(a.location + e, l / a.locationSize, d, t, l * u, l / a.locationSize * e * u, p)
                                    }
                                } else if (void 0 !== h) {
                                    const n = h[t];
                                    if (void 0 !== n)
                                        switch (n.length) {
                                        case 2:
                                            e.vertexAttrib2fv(a.location, n);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(a.location, n);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(a.location, n);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(a.location, n)
                                        }
                                }
                            }
                        }
                        v()
                    }(r, l, u, y),
                    null !== _ && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(_).buffer))
                },
                reset: y,
                resetDefaultState: _,
                dispose: function() {
                    y();
                    for (const e in o) {
                        const t = o[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n)
                                u(n[e].object),
                                delete n[e];
                            delete t[e]
                        }
                        delete o[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === o[e.id])
                        return;
                    const t = o[e.id];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n)
                            u(n[e].object),
                            delete n[e];
                        delete t[e]
                    }
                    delete o[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in o) {
                        const n = o[t];
                        if (void 0 === n[e.id])
                            continue;
                        const i = n[e.id];
                        for (const e in i)
                            u(i[e].object),
                            delete i[e];
                        delete n[e.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }
        function Wi(e, t, n, i) {
            const r = i.isWebGL2;
            let a;
            this.setMode = function(e) {
                a = e
            }
            ,
            this.render = function(t, i) {
                e.drawArrays(a, t, i),
                n.update(i, a, 1)
            }
            ,
            this.renderInstances = function(i, s, o) {
                if (0 === o)
                    return;
                let l, c;
                if (r)
                    l = e,
                    c = "drawArraysInstanced";
                else if (l = t.get("ANGLE_instanced_arrays"),
                c = "drawArraysInstancedANGLE",
                null === l)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](a, i, s, o),
                n.update(s, a, o)
            }
            ,
            this.renderMultiDraw = function(e, i, r) {
                if (0 === r)
                    return;
                const s = t.get("WEBGL_multi_draw");
                if (null === s)
                    for (let t = 0; t < r; t++)
                        this.render(e[t], i[t]);
                else {
                    s.multiDrawArraysWEBGL(a, e, 0, i, 0, r);
                    let t = 0;
                    for (let e = 0; e < r; e++)
                        t += i[e];
                    n.update(t, a, 1)
                }
            }
        }
        function Hi(e, t, n) {
            let i;
            function r(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                        return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const a = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e.constructor.name;
            let s = void 0 !== n.precision ? n.precision : "highp";
            const o = r(s);
            o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."),
            s = o);
            const l = a || t.has("WEBGL_draw_buffers")
              , c = !0 === n.logarithmicDepthBuffer
              , h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
              , d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , u = e.getParameter(e.MAX_TEXTURE_SIZE)
              , p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)
              , f = e.getParameter(e.MAX_VERTEX_ATTRIBS)
              , m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)
              , g = e.getParameter(e.MAX_VARYING_VECTORS)
              , v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)
              , w = d > 0
              , y = a || t.has("OES_texture_float");
            return {
                isWebGL2: a,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== i)
                        return i;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: s,
                logarithmicDepthBuffer: c,
                maxTextures: h,
                maxVertexTextures: d,
                maxTextureSize: u,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: w,
                floatFragmentTextures: y,
                floatVertexTextures: w && y,
                maxSamples: a ? e.getParameter(e.MAX_SAMPLES) : 0
            }
        }
        function Vi(e) {
            const t = this;
            let n = null
              , i = 0
              , r = !1
              , a = !1;
            const s = new Ci
              , o = new Be
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c(e, n, i, r) {
                const a = null !== e ? e.length : 0;
                let c = null;
                if (0 !== a) {
                    if (c = l.value,
                    !0 !== r || null === c) {
                        const t = i + 4 * a
                          , r = n.matrixWorldInverse;
                        o.getNormalMatrix(r),
                        (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let t = 0, n = i; t !== a; ++t,
                        n += 4)
                            s.copy(e[t]).applyMatrix4(r, o),
                            s.normal.toArray(c, n),
                            c[n + 3] = s.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return t.numPlanes = a,
                t.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(e, t) {
                const n = 0 !== e.length || t || 0 !== i || r;
                return r = t,
                i = e.length,
                n
            }
            ,
            this.beginShadows = function() {
                a = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
                a = !1
            }
            ,
            this.setGlobalState = function(e, t) {
                n = c(e, t, 0)
            }
            ,
            this.setState = function(s, o, h) {
                const d = s.clippingPlanes
                  , u = s.clipIntersection
                  , p = s.clipShadows
                  , f = e.get(s);
                if (!r || null === d || 0 === d.length || a && !p)
                    a ? c(null) : function() {
                        l.value !== n && (l.value = n,
                        l.needsUpdate = i > 0);
                        t.numPlanes = i,
                        t.numIntersection = 0
                    }();
                else {
                    const e = a ? 0 : i
                      , t = 4 * e;
                    let r = f.clippingState || null;
                    l.value = r,
                    r = c(d, o, t, h);
                    for (let e = 0; e !== t; ++e)
                        r[e] = n[e];
                    f.clippingState = r,
                    this.numIntersection = u ? this.numPlanes : 0,
                    this.numPlanes += e
                }
            }
        }
        function Gi(e) {
            let t = new WeakMap;
            function n(e, t) {
                return t === k ? e.mapping = M : t === C && (e.mapping = T),
                e
            }
            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const a = r.mapping;
                        if (a === k || a === C) {
                            if (t.has(r)) {
                                return n(t.get(r).texture, r.mapping)
                            }
                            {
                                const a = r.image;
                                if (a && a.height > 0) {
                                    const s = new Si(a.height / 2);
                                    return s.fromEquirectangularTexture(e, r),
                                    t.set(r, s),
                                    r.addEventListener("dispose", i),
                                    n(s.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class ji extends yi {
            constructor(e=-1, t=1, n=1, i=-1, r=.1, a=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = e,
                this.right = t,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = a,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.left = e.left,
                this.right = e.right,
                this.top = e.top,
                this.bottom = e.bottom,
                this.near = e.near,
                this.far = e.far,
                this.zoom = e.zoom,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this
            }
            setViewOffset(e, t, n, i, r, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = a,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom)
                  , t = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - e
                  , a = n + e
                  , s = i + t
                  , o = i - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += e * this.view.offsetX,
                    a = r + e * this.view.width,
                    s -= t * this.view.offsetY,
                    o = s - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom,
                t.object.left = this.left,
                t.object.right = this.right,
                t.object.top = this.top,
                t.object.bottom = this.bottom,
                t.object.near = this.near,
                t.object.far = this.far,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t
            }
        }
        const Xi = [.125, .215, .35, .446, .526, .582]
          , qi = 20
          , Yi = new ji
          , Zi = new An;
        let Ki = null
          , Ji = 0
          , Qi = 0;
        const $i = (1 + Math.sqrt(5)) / 2
          , er = 1 / $i
          , tr = [new ht(1,1,1), new ht(-1,1,1), new ht(1,1,-1), new ht(-1,1,-1), new ht(0,$i,er), new ht(0,$i,-er), new ht(er,0,$i), new ht(-er,0,$i), new ht($i,er,0), new ht(-$i,er,0)];
        class nr {
            constructor(e) {
                this._renderer = e,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, t=0, n=.1, i=100) {
                Ki = this._renderer.getRenderTarget(),
                Ji = this._renderer.getActiveCubeFace(),
                Qi = this._renderer.getActiveMipmapLevel(),
                this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0,
                this._sceneToCubeUV(e, n, i, r),
                t > 0 && this._blur(r, 0, 0, t),
                this._applyPMREM(r),
                this._cleanup(r),
                r
            }
            fromEquirectangular(e, t=null) {
                return this._fromTexture(e, t)
            }
            fromCubemap(e, t=null) {
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = sr(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = ar(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(Ki, Ji, Qi),
                e.scissorTest = !1,
                rr(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === M || e.mapping === T ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                Ki = this._renderer.getRenderTarget(),
                Ji = this._renderer.getActiveCubeFace(),
                Qi = this._renderer.getActiveMipmapLevel();
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112)
                  , t = 4 * this._cubeSize
                  , n = {
                    magFilter: D,
                    minFilter: D,
                    generateMipmaps: !1,
                    type: G,
                    format: X,
                    colorSpace: ce,
                    depthBuffer: !1
                }
                  , i = ir(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                    this._pingPongRenderTarget = ir(e, t, n);
                    const {_lodMax: i} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                        const t = []
                          , n = []
                          , i = [];
                        let r = e;
                        const a = e - 4 + 1 + Xi.length;
                        for (let s = 0; s < a; s++) {
                            const a = Math.pow(2, r);
                            n.push(a);
                            let o = 1 / a;
                            s > e - 4 ? o = Xi[s - e + 4 - 1] : 0 === s && (o = 0),
                            i.push(o);
                            const l = 1 / (a - 2)
                              , c = -l
                              , h = 1 + l
                              , d = [c, c, h, c, h, h, c, c, h, h, c, h]
                              , u = 6
                              , p = 6
                              , f = 3
                              , m = 2
                              , g = 1
                              , v = new Float32Array(f * p * u)
                              , w = new Float32Array(m * p * u)
                              , y = new Float32Array(g * p * u);
                            for (let e = 0; e < u; e++) {
                                const t = e % 3 * 2 / 3 - 1
                                  , n = e > 2 ? 0 : -1
                                  , i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                v.set(i, f * p * e),
                                w.set(d, m * p * e);
                                const r = [e, e, e, e, e, e];
                                y.set(r, g * p * e)
                            }
                            const _ = new qn;
                            _.setAttribute("position", new Dn(v,f)),
                            _.setAttribute("uv", new Dn(w,m)),
                            _.setAttribute("faceIndex", new Dn(y,g)),
                            t.push(_),
                            r > 4 && r--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)),
                    this._blurMaterial = function(e, t, n) {
                        const i = new Float32Array(qi)
                          , r = new ht(0,1,0)
                          , a = new wi({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: qi,
                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${e}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: or(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        });
                        return a
                    }(i, e, t)
                }
                return i
            }
            _compileMaterial(e) {
                const t = new di(this._lodPlanes[0],e);
                this._renderer.compile(t, Yi)
            }
            _sceneToCubeUV(e, t, n, i) {
                const r = new _i(90,1,t,n)
                  , a = [1, -1, 1, 1, 1, 1]
                  , s = [1, 1, 1, -1, -1, -1]
                  , o = this._renderer
                  , l = o.autoClear
                  , c = o.toneMapping;
                o.getClearColor(Zi),
                o.toneMapping = 0,
                o.autoClear = !1;
                const h = new In({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , d = new di(new pi,h);
                let u = !1;
                const p = e.background;
                p ? p.isColor && (h.color.copy(p),
                e.background = null,
                u = !0) : (h.color.copy(Zi),
                u = !0);
                for (let t = 0; t < 6; t++) {
                    const n = t % 3;
                    0 === n ? (r.up.set(0, a[t], 0),
                    r.lookAt(s[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, a[t]),
                    r.lookAt(0, s[t], 0)) : (r.up.set(0, a[t], 0),
                    r.lookAt(0, 0, s[t]));
                    const l = this._cubeSize;
                    rr(i, n * l, t > 2 ? l : 0, l, l),
                    o.setRenderTarget(i),
                    u && o.render(d, r),
                    o.render(e, r)
                }
                d.geometry.dispose(),
                d.material.dispose(),
                o.toneMapping = c,
                o.autoClear = l,
                e.background = p
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer
                  , i = e.mapping === M || e.mapping === T;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = sr()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = ar());
                const r = i ? this._cubemapMaterial : this._equirectMaterial
                  , a = new di(this._lodPlanes[0],r);
                r.uniforms.envMap.value = e;
                const s = this._cubeSize;
                rr(t, 0, 0, 3 * s, 2 * s),
                n.setRenderTarget(t),
                n.render(a, Yi)
            }
            _applyPMREM(e) {
                const t = this._renderer
                  , n = t.autoClear;
                t.autoClear = !1;
                for (let t = 1; t < this._lodPlanes.length; t++) {
                    const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                      , i = tr[(t - 1) % tr.length];
                    this._blur(e, t - 1, t, n, i)
                }
                t.autoClear = n
            }
            _blur(e, t, n, i, r) {
                const a = this._pingPongRenderTarget;
                this._halfBlur(e, a, t, n, i, "latitudinal", r),
                this._halfBlur(a, e, n, n, i, "longitudinal", r)
            }
            _halfBlur(e, t, n, i, r, a, s) {
                const o = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new di(this._lodPlanes[i],l)
                  , h = l.uniforms
                  , d = this._sizeLods[n] - 1
                  , u = isFinite(r) ? Math.PI / (2 * d) : 2 * Math.PI / 39
                  , p = r / u
                  , f = isFinite(r) ? 1 + Math.floor(3 * p) : qi;
                f > qi && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let e = 0; e < qi; ++e) {
                    const t = e / p
                      , n = Math.exp(-t * t / 2);
                    m.push(n),
                    0 === e ? g += n : e < f && (g += 2 * n)
                }
                for (let e = 0; e < m.length; e++)
                    m[e] = m[e] / g;
                h.envMap.value = e.texture,
                h.samples.value = f,
                h.weights.value = m,
                h.latitudinal.value = "latitudinal" === a,
                s && (h.poleAxis.value = s);
                const {_lodMax: v} = this;
                h.dTheta.value = u,
                h.mipInt.value = v - n;
                const w = this._sizeLods[i];
                rr(t, 3 * w * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - w), 3 * w, 2 * w),
                o.setRenderTarget(t),
                o.render(c, Yi)
            }
        }
        function ir(e, t, n) {
            const i = new st(e,t,n);
            return i.texture.mapping = A,
            i.texture.name = "PMREM.cubeUv",
            i.scissorTest = !0,
            i
        }
        function rr(e, t, n, i, r) {
            e.viewport.set(t, n, i, r),
            e.scissor.set(t, n, i, r)
        }
        function ar() {
            return new wi({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: or(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function sr() {
            return new wi({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: or(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function or() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }
        function lr(e) {
            let t = new WeakMap
              , n = null;
            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const a = r.mapping
                          , s = a === k || a === C
                          , o = a === M || a === T;
                        if (s || o) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let i = t.get(r);
                                return null === n && (n = new nr(e)),
                                i = s ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i),
                                t.set(r, i),
                                i.texture
                            }
                            if (t.has(r))
                                return t.get(r).texture;
                            {
                                const a = r.image;
                                if (s && a && a.height > 0 || o && a && function(e) {
                                    let t = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++)
                                        void 0 !== e[i] && t++;
                                    return t === n
                                }(a)) {
                                    null === n && (n = new nr(e));
                                    const a = s ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return t.set(r, a),
                                    r.addEventListener("dispose", i),
                                    a.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function cr(e) {
            const t = {};
            function n(n) {
                if (void 0 !== t[n])
                    return t[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
                }
                return t[n] = i,
                i
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function(e) {
                    e.isWebGL2 ? (n("EXT_color_buffer_float"),
                    n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"),
                    n("OES_texture_float"),
                    n("OES_texture_half_float"),
                    n("OES_texture_half_float_linear"),
                    n("OES_standard_derivatives"),
                    n("OES_element_index_uint"),
                    n("OES_vertex_array_object"),
                    n("ANGLE_instanced_arrays")),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                    t
                }
            }
        }
        function hr(e, t, n, i) {
            const r = {}
              , a = new WeakMap;
            function s(e) {
                const o = e.target;
                null !== o.index && t.remove(o.index);
                for (const e in o.attributes)
                    t.remove(o.attributes[e]);
                for (const e in o.morphAttributes) {
                    const n = o.morphAttributes[e];
                    for (let e = 0, i = n.length; e < i; e++)
                        t.remove(n[e])
                }
                o.removeEventListener("dispose", s),
                delete r[o.id];
                const l = a.get(o);
                l && (t.remove(l),
                a.delete(o)),
                i.releaseStatesOfGeometry(o),
                !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                n.memory.geometries--
            }
            function o(e) {
                const n = []
                  , i = e.index
                  , r = e.attributes.position;
                let s = 0;
                if (null !== i) {
                    const e = i.array;
                    s = i.version;
                    for (let t = 0, i = e.length; t < i; t += 3) {
                        const i = e[t + 0]
                          , r = e[t + 1]
                          , a = e[t + 2];
                        n.push(i, r, r, a, a, i)
                    }
                } else {
                    if (void 0 === r)
                        return;
                    {
                        const e = r.array;
                        s = r.version;
                        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                            const e = t + 0
                              , i = t + 1
                              , r = t + 2;
                            n.push(e, i, i, r, r, e)
                        }
                    }
                }
                const o = new (ze(n) ? On : Bn)(n,1);
                o.version = s;
                const l = a.get(e);
                l && t.remove(l),
                a.set(e, o)
            }
            return {
                get: function(e, t) {
                    return !0 === r[t.id] || (t.addEventListener("dispose", s),
                    r[t.id] = !0,
                    n.memory.geometries++),
                    t
                },
                update: function(n) {
                    const i = n.attributes;
                    for (const n in i)
                        t.update(i[n], e.ARRAY_BUFFER);
                    const r = n.morphAttributes;
                    for (const n in r) {
                        const i = r[n];
                        for (let n = 0, r = i.length; n < r; n++)
                            t.update(i[n], e.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(e) {
                    const t = a.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && o(e)
                    } else
                        o(e);
                    return a.get(e)
                }
            }
        }
        function dr(e, t, n, i) {
            const r = i.isWebGL2;
            let a, s, o;
            this.setMode = function(e) {
                a = e
            }
            ,
            this.setIndex = function(e) {
                s = e.type,
                o = e.bytesPerElement
            }
            ,
            this.render = function(t, i) {
                e.drawElements(a, i, s, t * o),
                n.update(i, a, 1)
            }
            ,
            this.renderInstances = function(i, l, c) {
                if (0 === c)
                    return;
                let h, d;
                if (r)
                    h = e,
                    d = "drawElementsInstanced";
                else if (h = t.get("ANGLE_instanced_arrays"),
                d = "drawElementsInstancedANGLE",
                null === h)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[d](a, l, s, i * o, c),
                n.update(l, a, c)
            }
            ,
            this.renderMultiDraw = function(e, i, r) {
                if (0 === r)
                    return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < r; t++)
                        this.render(e[t] / o, i[t]);
                else {
                    l.multiDrawElementsWEBGL(a, i, 0, s, e, 0, r);
                    let t = 0;
                    for (let e = 0; e < r; e++)
                        t += i[e];
                    n.update(t, a, 1)
                }
            }
        }
        function ur(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.calls = 0,
                    t.triangles = 0,
                    t.points = 0,
                    t.lines = 0
                },
                update: function(n, i, r) {
                    switch (t.calls++,
                    i) {
                    case e.TRIANGLES:
                        t.triangles += r * (n / 3);
                        break;
                    case e.LINES:
                        t.lines += r * (n / 2);
                        break;
                    case e.LINE_STRIP:
                        t.lines += r * (n - 1);
                        break;
                    case e.LINE_LOOP:
                        t.lines += r * n;
                        break;
                    case e.POINTS:
                        t.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }
        function pr(e, t) {
            return e[0] - t[0]
        }
        function fr(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1])
        }
        function mr(e, t, n) {
            const i = {}
              , r = new Float32Array(8)
              , a = new WeakMap
              , s = new rt
              , o = [];
            for (let e = 0; e < 8; e++)
                o[e] = [e, 0];
            return {
                update: function(l, c, h) {
                    const d = l.morphTargetInfluences;
                    if (!0 === t.isWebGL2) {
                        const u = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
                          , p = void 0 !== u ? u.length : 0;
                        let f = a.get(c);
                        if (void 0 === f || f.count !== p) {
                            void 0 !== f && f.texture.dispose();
                            const v = void 0 !== c.morphAttributes.position
                              , w = void 0 !== c.morphAttributes.normal
                              , y = void 0 !== c.morphAttributes.color
                              , _ = c.morphAttributes.position || []
                              , x = c.morphAttributes.normal || []
                              , b = c.morphAttributes.color || [];
                            let E = 0;
                            !0 === v && (E = 1),
                            !0 === w && (E = 2),
                            !0 === y && (E = 3);
                            let S = c.attributes.position.count * E
                              , M = 1;
                            S > t.maxTextureSize && (M = Math.ceil(S / t.maxTextureSize),
                            S = t.maxTextureSize);
                            const T = new Float32Array(S * M * 4 * p)
                              , k = new ot(T,S,M,p);
                            k.type = V,
                            k.needsUpdate = !0;
                            const C = 4 * E;
                            for (let P = 0; P < p; P++) {
                                const R = _[P]
                                  , L = x[P]
                                  , I = b[P]
                                  , N = S * M * 4 * P;
                                for (let U = 0; U < R.count; U++) {
                                    const D = U * C;
                                    !0 === v && (s.fromBufferAttribute(R, U),
                                    T[N + D + 0] = s.x,
                                    T[N + D + 1] = s.y,
                                    T[N + D + 2] = s.z,
                                    T[N + D + 3] = 0),
                                    !0 === w && (s.fromBufferAttribute(L, U),
                                    T[N + D + 4] = s.x,
                                    T[N + D + 5] = s.y,
                                    T[N + D + 6] = s.z,
                                    T[N + D + 7] = 0),
                                    !0 === y && (s.fromBufferAttribute(I, U),
                                    T[N + D + 8] = s.x,
                                    T[N + D + 9] = s.y,
                                    T[N + D + 10] = s.z,
                                    T[N + D + 11] = 4 === I.itemSize ? s.w : 1)
                                }
                            }
                            function A() {
                                k.dispose(),
                                a.delete(c),
                                c.removeEventListener("dispose", A)
                            }
                            f = {
                                count: p,
                                texture: k,
                                size: new De(S,M)
                            },
                            a.set(c, f),
                            c.addEventListener("dispose", A)
                        }
                        let m = 0;
                        for (let B = 0; B < d.length; B++)
                            m += d[B];
                        const g = c.morphTargetsRelative ? 1 : 1 - m;
                        h.getUniforms().setValue(e, "morphTargetBaseInfluence", g),
                        h.getUniforms().setValue(e, "morphTargetInfluences", d),
                        h.getUniforms().setValue(e, "morphTargetsTexture", f.texture, n),
                        h.getUniforms().setValue(e, "morphTargetsTextureSize", f.size)
                    } else {
                        const O = void 0 === d ? 0 : d.length;
                        let z = i[c.id];
                        if (void 0 === z || z.length !== O) {
                            z = [];
                            for (let j = 0; j < O; j++)
                                z[j] = [j, 0];
                            i[c.id] = z
                        }
                        for (let X = 0; X < O; X++) {
                            const q = z[X];
                            q[0] = X,
                            q[1] = d[X]
                        }
                        z.sort(fr);
                        for (let Y = 0; Y < 8; Y++)
                            Y < O && z[Y][1] ? (o[Y][0] = z[Y][0],
                            o[Y][1] = z[Y][1]) : (o[Y][0] = Number.MAX_SAFE_INTEGER,
                            o[Y][1] = 0);
                        o.sort(pr);
                        const F = c.morphAttributes.position
                          , W = c.morphAttributes.normal;
                        let H = 0;
                        for (let Z = 0; Z < 8; Z++) {
                            const K = o[Z]
                              , J = K[0]
                              , Q = K[1];
                            J !== Number.MAX_SAFE_INTEGER && Q ? (F && c.getAttribute("morphTarget" + Z) !== F[J] && c.setAttribute("morphTarget" + Z, F[J]),
                            W && c.getAttribute("morphNormal" + Z) !== W[J] && c.setAttribute("morphNormal" + Z, W[J]),
                            r[Z] = Q,
                            H += Q) : (F && !0 === c.hasAttribute("morphTarget" + Z) && c.deleteAttribute("morphTarget" + Z),
                            W && !0 === c.hasAttribute("morphNormal" + Z) && c.deleteAttribute("morphNormal" + Z),
                            r[Z] = 0)
                        }
                        const G = c.morphTargetsRelative ? 1 : 1 - H;
                        h.getUniforms().setValue(e, "morphTargetBaseInfluence", G),
                        h.getUniforms().setValue(e, "morphTargetInfluences", r)
                    }
                }
            }
        }
        function gr(e, t, n, i) {
            let r = new WeakMap;
            function a(e) {
                const t = e.target;
                t.removeEventListener("dispose", a),
                n.remove(t.instanceMatrix),
                null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(s) {
                    const o = i.render.frame
                      , l = s.geometry
                      , c = t.get(s, l);
                    if (r.get(c) !== o && (t.update(c),
                    r.set(c, o)),
                    s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a),
                    r.get(s) !== o && (n.update(s.instanceMatrix, e.ARRAY_BUFFER),
                    null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER),
                    r.set(s, o))),
                    s.isSkinnedMesh) {
                        const e = s.skeleton;
                        r.get(e) !== o && (e.update(),
                        r.set(e, o))
                    }
                    return c
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        class vr extends it {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                if ((c = void 0 !== c ? c : q) !== q && c !== Y)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === q && (n = H),
                void 0 === n && c === Y && (n = j),
                super(null, i, r, a, s, o, c, n, l),
                this.isDepthTexture = !0,
                this.image = {
                    width: e,
                    height: t
                },
                this.magFilter = void 0 !== s ? s : I,
                this.minFilter = void 0 !== o ? o : I,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(e) {
                return super.copy(e),
                this.compareFunction = e.compareFunction,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                t
            }
        }
        const wr = new it
          , yr = new vr(1,1);
        yr.compareFunction = 515;
        const _r = new ot
          , xr = new lt
          , br = new Ei
          , Er = []
          , Sr = []
          , Mr = new Float32Array(16)
          , Tr = new Float32Array(9)
          , kr = new Float32Array(4);
        function Cr(e, t, n) {
            const i = e[0];
            if (i <= 0 || i > 0)
                return e;
            const r = t * n;
            let a = Er[r];
            if (void 0 === a && (a = new Float32Array(r),
            Er[r] = a),
            0 !== t) {
                i.toArray(a, 0);
                for (let i = 1, r = 0; i !== t; ++i)
                    r += n,
                    e[i].toArray(a, r)
            }
            return a
        }
        function Ar(e, t) {
            if (e.length !== t.length)
                return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] !== t[n])
                    return !1;
            return !0
        }
        function Pr(e, t) {
            for (let n = 0, i = t.length; n < i; n++)
                e[n] = t[n]
        }
        function Rr(e, t) {
            let n = Sr[t];
            void 0 === n && (n = new Int32Array(t),
            Sr[t] = n);
            for (let i = 0; i !== t; ++i)
                n[i] = e.allocateTextureUnit();
            return n
        }
        function Lr(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t),
            n[0] = t)
        }
        function Ir(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Ar(n, t))
                    return;
                e.uniform2fv(this.addr, t),
                Pr(n, t)
            }
        }
        function Nr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else if (void 0 !== t.r)
                n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                n[0] = t.r,
                n[1] = t.g,
                n[2] = t.b);
            else {
                if (Ar(n, t))
                    return;
                e.uniform3fv(this.addr, t),
                Pr(n, t)
            }
        }
        function Ur(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Ar(n, t))
                    return;
                e.uniform4fv(this.addr, t),
                Pr(n, t)
            }
        }
        function Dr(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (Ar(n, t))
                    return;
                e.uniformMatrix2fv(this.addr, !1, t),
                Pr(n, t)
            } else {
                if (Ar(n, i))
                    return;
                kr.set(i),
                e.uniformMatrix2fv(this.addr, !1, kr),
                Pr(n, i)
            }
        }
        function Br(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (Ar(n, t))
                    return;
                e.uniformMatrix3fv(this.addr, !1, t),
                Pr(n, t)
            } else {
                if (Ar(n, i))
                    return;
                Tr.set(i),
                e.uniformMatrix3fv(this.addr, !1, Tr),
                Pr(n, i)
            }
        }
        function Or(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (Ar(n, t))
                    return;
                e.uniformMatrix4fv(this.addr, !1, t),
                Pr(n, t)
            } else {
                if (Ar(n, i))
                    return;
                Mr.set(i),
                e.uniformMatrix4fv(this.addr, !1, Mr),
                Pr(n, i)
            }
        }
        function zr(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t),
            n[0] = t)
        }
        function Fr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Ar(n, t))
                    return;
                e.uniform2iv(this.addr, t),
                Pr(n, t)
            }
        }
        function Wr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (Ar(n, t))
                    return;
                e.uniform3iv(this.addr, t),
                Pr(n, t)
            }
        }
        function Hr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Ar(n, t))
                    return;
                e.uniform4iv(this.addr, t),
                Pr(n, t)
            }
        }
        function Vr(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t),
            n[0] = t)
        }
        function Gr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Ar(n, t))
                    return;
                e.uniform2uiv(this.addr, t),
                Pr(n, t)
            }
        }
        function jr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (Ar(n, t))
                    return;
                e.uniform3uiv(this.addr, t),
                Pr(n, t)
            }
        }
        function Xr(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Ar(n, t))
                    return;
                e.uniform4uiv(this.addr, t),
                Pr(n, t)
            }
        }
        function qr(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r);
            const a = this.type === e.SAMPLER_2D_SHADOW ? yr : wr;
            n.setTexture2D(t || a, r)
        }
        function Yr(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(t || xr, r)
        }
        function Zr(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTextureCube(t || br, r)
        }
        function Kr(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(t || _r, r)
        }
        function Jr(e, t) {
            e.uniform1fv(this.addr, t)
        }
        function Qr(e, t) {
            const n = Cr(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }
        function $r(e, t) {
            const n = Cr(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }
        function ea(e, t) {
            const n = Cr(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }
        function ta(e, t) {
            const n = Cr(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }
        function na(e, t) {
            const n = Cr(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }
        function ia(e, t) {
            const n = Cr(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }
        function ra(e, t) {
            e.uniform1iv(this.addr, t)
        }
        function aa(e, t) {
            e.uniform2iv(this.addr, t)
        }
        function sa(e, t) {
            e.uniform3iv(this.addr, t)
        }
        function oa(e, t) {
            e.uniform4iv(this.addr, t)
        }
        function la(e, t) {
            e.uniform1uiv(this.addr, t)
        }
        function ca(e, t) {
            e.uniform2uiv(this.addr, t)
        }
        function ha(e, t) {
            e.uniform3uiv(this.addr, t)
        }
        function da(e, t) {
            e.uniform4uiv(this.addr, t)
        }
        function ua(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = Rr(n, r);
            Ar(i, a) || (e.uniform1iv(this.addr, a),
            Pr(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTexture2D(t[e] || wr, a[e])
        }
        function pa(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = Rr(n, r);
            Ar(i, a) || (e.uniform1iv(this.addr, a),
            Pr(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTexture3D(t[e] || xr, a[e])
        }
        function fa(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = Rr(n, r);
            Ar(i, a) || (e.uniform1iv(this.addr, a),
            Pr(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTextureCube(t[e] || br, a[e])
        }
        function ma(e, t, n) {
            const i = this.cache
              , r = t.length
              , a = Rr(n, r);
            Ar(i, a) || (e.uniform1iv(this.addr, a),
            Pr(i, a));
            for (let e = 0; e !== r; ++e)
                n.setTexture2DArray(t[e] || _r, a[e])
        }
        class ga {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return Lr;
                    case 35664:
                        return Ir;
                    case 35665:
                        return Nr;
                    case 35666:
                        return Ur;
                    case 35674:
                        return Dr;
                    case 35675:
                        return Br;
                    case 35676:
                        return Or;
                    case 5124:
                    case 35670:
                        return zr;
                    case 35667:
                    case 35671:
                        return Fr;
                    case 35668:
                    case 35672:
                        return Wr;
                    case 35669:
                    case 35673:
                        return Hr;
                    case 5125:
                        return Vr;
                    case 36294:
                        return Gr;
                    case 36295:
                        return jr;
                    case 36296:
                        return Xr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return qr;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Yr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Zr;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Kr
                    }
                }(t.type)
            }
        }
        class va {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.size = t.size,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return Jr;
                    case 35664:
                        return Qr;
                    case 35665:
                        return $r;
                    case 35666:
                        return ea;
                    case 35674:
                        return ta;
                    case 35675:
                        return na;
                    case 35676:
                        return ia;
                    case 5124:
                    case 35670:
                        return ra;
                    case 35667:
                    case 35671:
                        return aa;
                    case 35668:
                    case 35672:
                        return sa;
                    case 35669:
                    case 35673:
                        return oa;
                    case 5125:
                        return la;
                    case 36294:
                        return ca;
                    case 36295:
                        return ha;
                    case 36296:
                        return da;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return ua;
                    case 35679:
                    case 36299:
                    case 36307:
                        return pa;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return fa;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return ma
                    }
                }(t.type)
            }
        }
        class wa {
            constructor(e) {
                this.id = e,
                this.seq = [],
                this.map = {}
            }
            setValue(e, t, n) {
                const i = this.seq;
                for (let r = 0, a = i.length; r !== a; ++r) {
                    const a = i[r];
                    a.setValue(e, t[a.id], n)
                }
            }
        }
        const ya = /(\w+)(\])?(\[|\.)?/g;
        function _a(e, t) {
            e.seq.push(t),
            e.map[t.id] = t
        }
        function xa(e, t, n) {
            const i = e.name
              , r = i.length;
            for (ya.lastIndex = 0; ; ) {
                const a = ya.exec(i)
                  , s = ya.lastIndex;
                let o = a[1];
                const l = "]" === a[2]
                  , c = a[3];
                if (l && (o |= 0),
                void 0 === c || "[" === c && s + 2 === r) {
                    _a(n, void 0 === c ? new ga(o,e,t) : new va(o,e,t));
                    break
                }
                {
                    let e = n.map[o];
                    void 0 === e && (e = new wa(o),
                    _a(n, e)),
                    n = e
                }
            }
        }
        class ba {
            constructor(e, t) {
                this.seq = [],
                this.map = {};
                const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    xa(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }
            setOptional(e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }
            static upload(e, t, n, i) {
                for (let r = 0, a = t.length; r !== a; ++r) {
                    const a = t[r]
                      , s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, i)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            }
        }
        function Ea(e, t, n) {
            const i = e.createShader(t);
            return e.shaderSource(i, n),
            e.compileShader(i),
            i
        }
        let Sa = 0;
        function Ma(e, t, n) {
            const i = e.getShaderParameter(t, e.COMPILE_STATUS)
              , r = e.getShaderInfoLog(t).trim();
            if (i && "" === r)
                return "";
            const a = /ERROR: 0:(\d+)/.exec(r);
            if (a) {
                const i = parseInt(a[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                    const n = e.split("\n")
                      , i = []
                      , r = Math.max(t - 6, 0)
                      , a = Math.min(t + 6, n.length);
                    for (let e = r; e < a; e++) {
                        const r = e + 1;
                        i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`)
                    }
                    return i.join("\n")
                }(e.getShaderSource(t), i)
            }
            return r
        }
        function Ta(e, t) {
            const n = function(e) {
                const t = Ye.getPrimaries(Ye.workingColorSpace)
                  , n = Ye.getPrimaries(e);
                let i;
                switch (t === n ? i = "" : t === me && n === fe ? i = "LinearDisplayP3ToLinearSRGB" : t === fe && n === me && (i = "LinearSRGBToLinearDisplayP3"),
                e) {
                case ce:
                case de:
                    return [i, "LinearTransferOETF"];
                case le:
                case he:
                    return [i, "sRGBTransferOETF"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", e),
                    [i, "LinearTransferOETF"]
                }
            }(t);
            return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }
        function ka(e, t) {
            let n;
            switch (t) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "OptimizedCineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 6:
                n = "AgX";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function Ca(e) {
            return "" !== e
        }
        function Aa(e, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }
        function Pa(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const Ra = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function La(e) {
            return e.replace(Ra, Na)
        }
        const Ia = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
        function Na(e, t) {
            let n = Ui[t];
            if (void 0 === n) {
                const e = Ia.get(t);
                if (void 0 === e)
                    throw new Error("Can not resolve #include <" + t + ">");
                n = Ui[e],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
            }
            return La(n)
        }
        const Ua = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function Da(e) {
            return e.replace(Ua, Ba)
        }
        function Ba(e, t, n, i) {
            let r = "";
            for (let e = parseInt(t); e < parseInt(n); e++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
            return r
        }
        function Oa(e) {
            let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
            t
        }
        function za(e, t, n, i) {
            const r = e.getContext()
              , a = n.defines;
            let s = n.vertexShader
              , o = n.fragmentShader;
            const l = function(e) {
                let t = "SHADOWMAP_TYPE_BASIC";
                return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
                t
            }(n)
              , c = function(e) {
                let t = "ENVMAP_TYPE_CUBE";
                if (e.envMap)
                    switch (e.envMapMode) {
                    case M:
                    case T:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case A:
                        t = "ENVMAP_TYPE_CUBE_UV"
                    }
                return t
            }(n)
              , h = function(e) {
                let t = "ENVMAP_MODE_REFLECTION";
                e.envMap && e.envMapMode === T && (t = "ENVMAP_MODE_REFRACTION");
                return t
            }(n)
              , d = function(e) {
                let t = "ENVMAP_BLENDING_NONE";
                if (e.envMap)
                    switch (e.combine) {
                    case 0:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        t = "ENVMAP_BLENDING_ADD"
                    }
                return t
            }(n)
              , u = function(e) {
                const t = e.envMapCubeUVHeight;
                if (null === t)
                    return null;
                const n = Math.log2(t) - 2
                  , i = 1 / t;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: i,
                    maxMip: n
                }
            }(n)
              , p = n.isWebGL2 ? "" : function(e) {
                return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.normalMapTangentSpace || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ca).join("\n")
            }(n)
              , f = function(e) {
                return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""].filter(Ca).join("\n")
            }(n)
              , m = function(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    !1 !== i && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }(a)
              , g = r.createProgram();
            let v, w, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Ca).join("\n"),
            v.length > 0 && (v += "\n"),
            w = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Ca).join("\n"),
            w.length > 0 && (w += "\n")) : (v = [Oa(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ca).join("\n"),
            w = [p, Oa(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Ui.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? ka("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Ui.colorspace_pars_fragment, Ta("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ca).join("\n")),
            s = La(s),
            s = Aa(s, n),
            s = Pa(s, n),
            o = La(o),
            o = Aa(o, n),
            o = Pa(o, n),
            s = Da(s),
            o = Da(o),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
            v = [f, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v,
            w = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === we ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === we ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + w);
            const _ = y + v + s
              , x = y + w + o
              , b = Ea(r, r.VERTEX_SHADER, _)
              , E = Ea(r, r.FRAGMENT_SHADER, x);
            function S(t) {
                if (e.debug.checkShaderErrors) {
                    const n = r.getProgramInfoLog(g).trim()
                      , i = r.getShaderInfoLog(b).trim()
                      , a = r.getShaderInfoLog(E).trim();
                    let s = !0
                      , o = !0;
                    if (!1 === r.getProgramParameter(g, r.LINK_STATUS))
                        if (s = !1,
                        "function" == typeof e.debug.onShaderError)
                            e.debug.onShaderError(r, g, b, E);
                        else {
                            const e = Ma(r, b, "vertex")
                              , t = Ma(r, E, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + t)
                        }
                    else
                        "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== a || (o = !1);
                    o && (t.diagnostics = {
                        runnable: s,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: v
                        },
                        fragmentShader: {
                            log: a,
                            prefix: w
                        }
                    })
                }
                r.deleteShader(b),
                r.deleteShader(E),
                k = new ba(r,g),
                C = function(e, t) {
                    const n = {}
                      , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = e.getActiveAttrib(t, r)
                          , a = i.name;
                        let s = 1;
                        i.type === e.FLOAT_MAT2 && (s = 2),
                        i.type === e.FLOAT_MAT3 && (s = 3),
                        i.type === e.FLOAT_MAT4 && (s = 4),
                        n[a] = {
                            type: i.type,
                            location: e.getAttribLocation(t, a),
                            locationSize: s
                        }
                    }
                    return n
                }(r, g)
            }
            let k, C;
            r.attachShader(g, b),
            r.attachShader(g, E),
            void 0 !== n.index0AttributeName ? r.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(g, 0, "position"),
            r.linkProgram(g),
            this.getUniforms = function() {
                return void 0 === k && S(this),
                k
            }
            ,
            this.getAttributes = function() {
                return void 0 === C && S(this),
                C
            }
            ;
            let P = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === P && (P = r.getProgramParameter(g, 37297)),
                P
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                r.deleteProgram(g),
                this.program = void 0
            }
            ,
            this.type = n.shaderType,
            this.name = n.shaderName,
            this.id = Sa++,
            this.cacheKey = t,
            this.usedTimes = 1,
            this.program = g,
            this.vertexShader = b,
            this.fragmentShader = E,
            this
        }
        let Fa = 0;
        class Wa {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader
                  , n = e.fragmentShader
                  , i = this._getShaderStage(t)
                  , r = this._getShaderStage(n)
                  , a = this._getShaderCacheForMaterial(e);
                return !1 === a.has(i) && (a.add(i),
                i.usedTimes++),
                !1 === a.has(r) && (a.add(r),
                r.usedTimes++),
                this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const e of t)
                    e.usedTimes--,
                    0 === e.usedTimes && this.shaderCache.delete(e.code);
                return this.materialCache.delete(e),
                this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                let n = t.get(e);
                return void 0 === n && (n = new Set,
                t.set(e, n)),
                n
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                let n = t.get(e);
                return void 0 === n && (n = new Ha(e),
                t.set(e, n)),
                n
            }
        }
        class Ha {
            constructor(e) {
                this.id = Fa++,
                this.code = e,
                this.usedTimes = 0
            }
        }
        function Va(e, t, n, i, r, a, s) {
            const o = new Jt
              , l = new Wa
              , c = []
              , h = r.isWebGL2
              , d = r.logarithmicDepthBuffer
              , u = r.vertexTextures;
            let p = r.precision;
            const f = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function m(e) {
                return 0 === e ? "uv" : `uv${e}`
            }
            return {
                getParameters: function(a, o, c, g, v) {
                    const w = g.fog
                      , y = v.geometry
                      , _ = a.isMeshStandardMaterial ? g.environment : null
                      , x = (a.isMeshStandardMaterial ? n : t).get(a.envMap || _)
                      , b = x && x.mapping === A ? x.image.height : null
                      , E = f[a.type];
                    null !== a.precision && (p = r.getMaxPrecision(a.precision),
                    p !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", p, "instead."));
                    const S = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color
                      , M = void 0 !== S ? S.length : 0;
                    let T, k, C, P, R = 0;
                    if (void 0 !== y.morphAttributes.position && (R = 1),
                    void 0 !== y.morphAttributes.normal && (R = 2),
                    void 0 !== y.morphAttributes.color && (R = 3),
                    E) {
                        const e = Bi[E];
                        T = e.vertexShader,
                        k = e.fragmentShader
                    } else
                        T = a.vertexShader,
                        k = a.fragmentShader,
                        l.update(a),
                        C = l.getVertexShaderID(a),
                        P = l.getFragmentShaderID(a);
                    const L = e.getRenderTarget()
                      , I = !0 === v.isInstancedMesh
                      , N = !0 === v.isBatchedMesh
                      , U = !!a.map
                      , D = !!a.matcap
                      , B = !!x
                      , O = !!a.aoMap
                      , z = !!a.lightMap
                      , F = !!a.bumpMap
                      , W = !!a.normalMap
                      , H = !!a.displacementMap
                      , V = !!a.emissiveMap
                      , G = !!a.metalnessMap
                      , j = !!a.roughnessMap
                      , X = a.anisotropy > 0
                      , q = a.clearcoat > 0
                      , Y = a.iridescence > 0
                      , Z = a.sheen > 0
                      , K = a.transmission > 0
                      , J = X && !!a.anisotropyMap
                      , Q = q && !!a.clearcoatMap
                      , $ = q && !!a.clearcoatNormalMap
                      , ee = q && !!a.clearcoatRoughnessMap
                      , te = Y && !!a.iridescenceMap
                      , ne = Y && !!a.iridescenceThicknessMap
                      , ie = Z && !!a.sheenColorMap
                      , re = Z && !!a.sheenRoughnessMap
                      , ae = !!a.specularMap
                      , se = !!a.specularColorMap
                      , oe = !!a.specularIntensityMap
                      , le = K && !!a.transmissionMap
                      , he = K && !!a.thicknessMap
                      , de = !!a.gradientMap
                      , ue = !!a.alphaMap
                      , fe = a.alphaTest > 0
                      , me = !!a.alphaHash
                      , ge = !!a.extensions
                      , ve = !!y.attributes.uv1
                      , we = !!y.attributes.uv2
                      , ye = !!y.attributes.uv3;
                    let _e = 0;
                    return a.toneMapped && (null !== L && !0 !== L.isXRRenderTarget || (_e = e.toneMapping)),
                    {
                        isWebGL2: h,
                        shaderID: E,
                        shaderType: a.type,
                        shaderName: a.name,
                        vertexShader: T,
                        fragmentShader: k,
                        defines: a.defines,
                        customVertexShaderID: C,
                        customFragmentShaderID: P,
                        isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                        glslVersion: a.glslVersion,
                        precision: p,
                        batching: N,
                        instancing: I,
                        instancingColor: I && null !== v.instanceColor,
                        supportsVertexTextures: u,
                        outputColorSpace: null === L ? e.outputColorSpace : !0 === L.isXRRenderTarget ? L.texture.colorSpace : ce,
                        map: U,
                        matcap: D,
                        envMap: B,
                        envMapMode: B && x.mapping,
                        envMapCubeUVHeight: b,
                        aoMap: O,
                        lightMap: z,
                        bumpMap: F,
                        normalMap: W,
                        displacementMap: u && H,
                        emissiveMap: V,
                        normalMapObjectSpace: W && 1 === a.normalMapType,
                        normalMapTangentSpace: W && 0 === a.normalMapType,
                        metalnessMap: G,
                        roughnessMap: j,
                        anisotropy: X,
                        anisotropyMap: J,
                        clearcoat: q,
                        clearcoatMap: Q,
                        clearcoatNormalMap: $,
                        clearcoatRoughnessMap: ee,
                        iridescence: Y,
                        iridescenceMap: te,
                        iridescenceThicknessMap: ne,
                        sheen: Z,
                        sheenColorMap: ie,
                        sheenRoughnessMap: re,
                        specularMap: ae,
                        specularColorMap: se,
                        specularIntensityMap: oe,
                        transmission: K,
                        transmissionMap: le,
                        thicknessMap: he,
                        gradientMap: de,
                        opaque: !1 === a.transparent && 1 === a.blending,
                        alphaMap: ue,
                        alphaTest: fe,
                        alphaHash: me,
                        combine: a.combine,
                        mapUv: U && m(a.map.channel),
                        aoMapUv: O && m(a.aoMap.channel),
                        lightMapUv: z && m(a.lightMap.channel),
                        bumpMapUv: F && m(a.bumpMap.channel),
                        normalMapUv: W && m(a.normalMap.channel),
                        displacementMapUv: H && m(a.displacementMap.channel),
                        emissiveMapUv: V && m(a.emissiveMap.channel),
                        metalnessMapUv: G && m(a.metalnessMap.channel),
                        roughnessMapUv: j && m(a.roughnessMap.channel),
                        anisotropyMapUv: J && m(a.anisotropyMap.channel),
                        clearcoatMapUv: Q && m(a.clearcoatMap.channel),
                        clearcoatNormalMapUv: $ && m(a.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: ee && m(a.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: te && m(a.iridescenceMap.channel),
                        iridescenceThicknessMapUv: ne && m(a.iridescenceThicknessMap.channel),
                        sheenColorMapUv: ie && m(a.sheenColorMap.channel),
                        sheenRoughnessMapUv: re && m(a.sheenRoughnessMap.channel),
                        specularMapUv: ae && m(a.specularMap.channel),
                        specularColorMapUv: se && m(a.specularColorMap.channel),
                        specularIntensityMapUv: oe && m(a.specularIntensityMap.channel),
                        transmissionMapUv: le && m(a.transmissionMap.channel),
                        thicknessMapUv: he && m(a.thicknessMap.channel),
                        alphaMapUv: ue && m(a.alphaMap.channel),
                        vertexTangents: !!y.attributes.tangent && (W || X),
                        vertexColors: a.vertexColors,
                        vertexAlphas: !0 === a.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                        vertexUv1s: ve,
                        vertexUv2s: we,
                        vertexUv3s: ye,
                        pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (U || ue),
                        fog: !!w,
                        useFog: !0 === a.fog,
                        fogExp2: w && w.isFogExp2,
                        flatShading: !0 === a.flatShading,
                        sizeAttenuation: !0 === a.sizeAttenuation,
                        logarithmicDepthBuffer: d,
                        skinning: !0 === v.isSkinnedMesh,
                        morphTargets: void 0 !== y.morphAttributes.position,
                        morphNormals: void 0 !== y.morphAttributes.normal,
                        morphColors: void 0 !== y.morphAttributes.color,
                        morphTargetsCount: M,
                        morphTextureStride: R,
                        numDirLights: o.directional.length,
                        numPointLights: o.point.length,
                        numSpotLights: o.spot.length,
                        numSpotLightMaps: o.spotLightMap.length,
                        numRectAreaLights: o.rectArea.length,
                        numHemiLights: o.hemi.length,
                        numDirLightShadows: o.directionalShadowMap.length,
                        numPointLightShadows: o.pointShadowMap.length,
                        numSpotLightShadows: o.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                        numLightProbes: o.numLightProbes,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: a.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: _e,
                        useLegacyLights: e._useLegacyLights,
                        decodeVideoTexture: U && !0 === a.map.isVideoTexture && Ye.getTransfer(a.map.colorSpace) === pe,
                        premultipliedAlpha: a.premultipliedAlpha,
                        doubleSided: 2 === a.side,
                        flipSided: 1 === a.side,
                        useDepthPacking: a.depthPacking >= 0,
                        depthPacking: a.depthPacking || 0,
                        index0AttributeName: a.index0AttributeName,
                        extensionDerivatives: ge && !0 === a.extensions.derivatives,
                        extensionFragDepth: ge && !0 === a.extensions.fragDepth,
                        extensionDrawBuffers: ge && !0 === a.extensions.drawBuffers,
                        extensionShaderTextureLOD: ge && !0 === a.extensions.shaderTextureLOD,
                        extensionClipCullDistance: ge && a.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                        rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
                        rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: a.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                    n.push(t.customFragmentShaderID)),
                    void 0 !== t.defines)
                        for (const e in t.defines)
                            n.push(e),
                            n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (!function(e, t) {
                        e.push(t.precision),
                        e.push(t.outputColorSpace),
                        e.push(t.envMapMode),
                        e.push(t.envMapCubeUVHeight),
                        e.push(t.mapUv),
                        e.push(t.alphaMapUv),
                        e.push(t.lightMapUv),
                        e.push(t.aoMapUv),
                        e.push(t.bumpMapUv),
                        e.push(t.normalMapUv),
                        e.push(t.displacementMapUv),
                        e.push(t.emissiveMapUv),
                        e.push(t.metalnessMapUv),
                        e.push(t.roughnessMapUv),
                        e.push(t.anisotropyMapUv),
                        e.push(t.clearcoatMapUv),
                        e.push(t.clearcoatNormalMapUv),
                        e.push(t.clearcoatRoughnessMapUv),
                        e.push(t.iridescenceMapUv),
                        e.push(t.iridescenceThicknessMapUv),
                        e.push(t.sheenColorMapUv),
                        e.push(t.sheenRoughnessMapUv),
                        e.push(t.specularMapUv),
                        e.push(t.specularColorMapUv),
                        e.push(t.specularIntensityMapUv),
                        e.push(t.transmissionMapUv),
                        e.push(t.thicknessMapUv),
                        e.push(t.combine),
                        e.push(t.fogExp2),
                        e.push(t.sizeAttenuation),
                        e.push(t.morphTargetsCount),
                        e.push(t.morphAttributeCount),
                        e.push(t.numDirLights),
                        e.push(t.numPointLights),
                        e.push(t.numSpotLights),
                        e.push(t.numSpotLightMaps),
                        e.push(t.numHemiLights),
                        e.push(t.numRectAreaLights),
                        e.push(t.numDirLightShadows),
                        e.push(t.numPointLightShadows),
                        e.push(t.numSpotLightShadows),
                        e.push(t.numSpotLightShadowsWithMaps),
                        e.push(t.numLightProbes),
                        e.push(t.shadowMapType),
                        e.push(t.toneMapping),
                        e.push(t.numClippingPlanes),
                        e.push(t.numClipIntersection),
                        e.push(t.depthPacking)
                    }(n, t),
                    function(e, t) {
                        o.disableAll(),
                        t.isWebGL2 && o.enable(0);
                        t.supportsVertexTextures && o.enable(1);
                        t.instancing && o.enable(2);
                        t.instancingColor && o.enable(3);
                        t.matcap && o.enable(4);
                        t.envMap && o.enable(5);
                        t.normalMapObjectSpace && o.enable(6);
                        t.normalMapTangentSpace && o.enable(7);
                        t.clearcoat && o.enable(8);
                        t.iridescence && o.enable(9);
                        t.alphaTest && o.enable(10);
                        t.vertexColors && o.enable(11);
                        t.vertexAlphas && o.enable(12);
                        t.vertexUv1s && o.enable(13);
                        t.vertexUv2s && o.enable(14);
                        t.vertexUv3s && o.enable(15);
                        t.vertexTangents && o.enable(16);
                        t.anisotropy && o.enable(17);
                        t.alphaHash && o.enable(18);
                        t.batching && o.enable(19);
                        e.push(o.mask),
                        o.disableAll(),
                        t.fog && o.enable(0);
                        t.useFog && o.enable(1);
                        t.flatShading && o.enable(2);
                        t.logarithmicDepthBuffer && o.enable(3);
                        t.skinning && o.enable(4);
                        t.morphTargets && o.enable(5);
                        t.morphNormals && o.enable(6);
                        t.morphColors && o.enable(7);
                        t.premultipliedAlpha && o.enable(8);
                        t.shadowMapEnabled && o.enable(9);
                        t.useLegacyLights && o.enable(10);
                        t.doubleSided && o.enable(11);
                        t.flipSided && o.enable(12);
                        t.useDepthPacking && o.enable(13);
                        t.dithering && o.enable(14);
                        t.transmission && o.enable(15);
                        t.sheen && o.enable(16);
                        t.opaque && o.enable(17);
                        t.pointsUvs && o.enable(18);
                        t.decodeVideoTexture && o.enable(19);
                        e.push(o.mask)
                    }(n, t),
                    n.push(e.outputColorSpace)),
                    n.push(t.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(e) {
                    const t = f[e.type];
                    let n;
                    if (t) {
                        const e = Bi[t];
                        n = vi.clone(e.uniforms)
                    } else
                        n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let i;
                    for (let e = 0, t = c.length; e < t; e++) {
                        const t = c[e];
                        if (t.cacheKey === n) {
                            i = t,
                            ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new za(e,n,t,a),
                    c.push(i)),
                    i
                },
                releaseProgram: function(e) {
                    if (0 == --e.usedTimes) {
                        const t = c.indexOf(e);
                        c[t] = c[c.length - 1],
                        c.pop(),
                        e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    l.remove(e)
                },
                programs: c,
                dispose: function() {
                    l.dispose()
                }
            }
        }
        function Ga() {
            let e = new WeakMap;
            return {
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {},
                    e.set(t, n)),
                    n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, i) {
                    e.get(t)[n] = i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function ja(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }
        function Xa(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }
        function qa() {
            const e = [];
            let t = 0;
            const n = []
              , i = []
              , r = [];
            function a(n, i, r, a, s, o) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: a,
                    renderOrder: n.renderOrder,
                    z: s,
                    group: o
                },
                e[t] = l) : (l.id = n.id,
                l.object = n,
                l.geometry = i,
                l.material = r,
                l.groupOrder = a,
                l.renderOrder = n.renderOrder,
                l.z = s,
                l.group = o),
                t++,
                l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    t = 0,
                    n.length = 0,
                    i.length = 0,
                    r.length = 0
                },
                push: function(e, t, s, o, l, c) {
                    const h = a(e, t, s, o, l, c);
                    s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
                },
                unshift: function(e, t, s, o, l, c) {
                    const h = a(e, t, s, o, l, c);
                    s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
                },
                finish: function() {
                    for (let n = t, i = e.length; n < i; n++) {
                        const t = e[n];
                        if (null === t.id)
                            break;
                        t.id = null,
                        t.object = null,
                        t.geometry = null,
                        t.material = null,
                        t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || ja),
                    i.length > 1 && i.sort(t || Xa),
                    r.length > 1 && r.sort(t || Xa)
                }
            }
        }
        function Ya() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    const i = e.get(t);
                    let r;
                    return void 0 === i ? (r = new qa,
                    e.set(t, [r])) : n >= i.length ? (r = new qa,
                    i.push(r)) : r = i[n],
                    r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function Za() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    let n;
                    switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new ht,
                            color: new An
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new ht,
                            direction: new ht,
                            color: new An,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new ht,
                            color: new An,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new ht,
                            skyColor: new An,
                            groundColor: new An
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new An,
                            position: new ht,
                            halfWidth: new ht,
                            halfHeight: new ht
                        }
                    }
                    return e[t.id] = n,
                    n
                }
            }
        }
        let Ka = 0;
        function Ja(e, t) {
            return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
        }
        function Qa(e, t) {
            const n = new Za
              , i = function() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id])
                            return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new De
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new De,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return e[t.id] = n,
                        n
                    }
                }
            }()
              , r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let e = 0; e < 9; e++)
                r.probe.push(new ht);
            const a = new ht
              , s = new Ft
              , o = new Ft;
            return {
                setup: function(a, s) {
                    let o = 0
                      , l = 0
                      , c = 0;
                    for (let e = 0; e < 9; e++)
                        r.probe[e].set(0, 0, 0);
                    let h = 0
                      , d = 0
                      , u = 0
                      , p = 0
                      , f = 0
                      , m = 0
                      , g = 0
                      , v = 0
                      , w = 0
                      , y = 0
                      , _ = 0;
                    a.sort(Ja);
                    const x = !0 === s ? Math.PI : 1;
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = a[e]
                          , s = t.color
                          , b = t.intensity
                          , E = t.distance
                          , S = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                        if (t.isAmbientLight)
                            o += s.r * b * x,
                            l += s.g * b * x,
                            c += s.b * b * x;
                        else if (t.isLightProbe) {
                            for (let e = 0; e < 9; e++)
                                r.probe[e].addScaledVector(t.sh.coefficients[e], b);
                            _++
                        } else if (t.isDirectionalLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * x),
                            t.castShadow) {
                                const e = t.shadow
                                  , n = i.get(t);
                                n.shadowBias = e.bias,
                                n.shadowNormalBias = e.normalBias,
                                n.shadowRadius = e.radius,
                                n.shadowMapSize = e.mapSize,
                                r.directionalShadow[h] = n,
                                r.directionalShadowMap[h] = S,
                                r.directionalShadowMatrix[h] = t.shadow.matrix,
                                m++
                            }
                            r.directional[h] = e,
                            h++
                        } else if (t.isSpotLight) {
                            const e = n.get(t);
                            e.position.setFromMatrixPosition(t.matrixWorld),
                            e.color.copy(s).multiplyScalar(b * x),
                            e.distance = E,
                            e.coneCos = Math.cos(t.angle),
                            e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                            e.decay = t.decay,
                            r.spot[u] = e;
                            const a = t.shadow;
                            if (t.map && (r.spotLightMap[w] = t.map,
                            w++,
                            a.updateMatrices(t),
                            t.castShadow && y++),
                            r.spotLightMatrix[u] = a.matrix,
                            t.castShadow) {
                                const e = i.get(t);
                                e.shadowBias = a.bias,
                                e.shadowNormalBias = a.normalBias,
                                e.shadowRadius = a.radius,
                                e.shadowMapSize = a.mapSize,
                                r.spotShadow[u] = e,
                                r.spotShadowMap[u] = S,
                                v++
                            }
                            u++
                        } else if (t.isRectAreaLight) {
                            const e = n.get(t);
                            e.color.copy(s).multiplyScalar(b),
                            e.halfWidth.set(.5 * t.width, 0, 0),
                            e.halfHeight.set(0, .5 * t.height, 0),
                            r.rectArea[p] = e,
                            p++
                        } else if (t.isPointLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * x),
                            e.distance = t.distance,
                            e.decay = t.decay,
                            t.castShadow) {
                                const e = t.shadow
                                  , n = i.get(t);
                                n.shadowBias = e.bias,
                                n.shadowNormalBias = e.normalBias,
                                n.shadowRadius = e.radius,
                                n.shadowMapSize = e.mapSize,
                                n.shadowCameraNear = e.camera.near,
                                n.shadowCameraFar = e.camera.far,
                                r.pointShadow[d] = n,
                                r.pointShadowMap[d] = S,
                                r.pointShadowMatrix[d] = t.shadow.matrix,
                                g++
                            }
                            r.point[d] = e,
                            d++
                        } else if (t.isHemisphereLight) {
                            const e = n.get(t);
                            e.skyColor.copy(t.color).multiplyScalar(b * x),
                            e.groundColor.copy(t.groundColor).multiplyScalar(b * x),
                            r.hemi[f] = e,
                            f++
                        }
                    }
                    p > 0 && (t.isWebGL2 ? !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Di.LTC_FLOAT_1,
                    r.rectAreaLTC2 = Di.LTC_FLOAT_2) : (r.rectAreaLTC1 = Di.LTC_HALF_1,
                    r.rectAreaLTC2 = Di.LTC_HALF_2) : !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Di.LTC_FLOAT_1,
                    r.rectAreaLTC2 = Di.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Di.LTC_HALF_1,
                    r.rectAreaLTC2 = Di.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    r.ambient[0] = o,
                    r.ambient[1] = l,
                    r.ambient[2] = c;
                    const b = r.hash;
                    b.directionalLength === h && b.pointLength === d && b.spotLength === u && b.rectAreaLength === p && b.hemiLength === f && b.numDirectionalShadows === m && b.numPointShadows === g && b.numSpotShadows === v && b.numSpotMaps === w && b.numLightProbes === _ || (r.directional.length = h,
                    r.spot.length = u,
                    r.rectArea.length = p,
                    r.point.length = d,
                    r.hemi.length = f,
                    r.directionalShadow.length = m,
                    r.directionalShadowMap.length = m,
                    r.pointShadow.length = g,
                    r.pointShadowMap.length = g,
                    r.spotShadow.length = v,
                    r.spotShadowMap.length = v,
                    r.directionalShadowMatrix.length = m,
                    r.pointShadowMatrix.length = g,
                    r.spotLightMatrix.length = v + w - y,
                    r.spotLightMap.length = w,
                    r.numSpotLightShadowsWithMaps = y,
                    r.numLightProbes = _,
                    b.directionalLength = h,
                    b.pointLength = d,
                    b.spotLength = u,
                    b.rectAreaLength = p,
                    b.hemiLength = f,
                    b.numDirectionalShadows = m,
                    b.numPointShadows = g,
                    b.numSpotShadows = v,
                    b.numSpotMaps = w,
                    b.numLightProbes = _,
                    r.version = Ka++)
                },
                setupView: function(e, t) {
                    let n = 0
                      , i = 0
                      , l = 0
                      , c = 0
                      , h = 0;
                    const d = t.matrixWorldInverse;
                    for (let t = 0, u = e.length; t < u; t++) {
                        const u = e[t];
                        if (u.isDirectionalLight) {
                            const e = r.directional[n];
                            e.direction.setFromMatrixPosition(u.matrixWorld),
                            a.setFromMatrixPosition(u.target.matrixWorld),
                            e.direction.sub(a),
                            e.direction.transformDirection(d),
                            n++
                        } else if (u.isSpotLight) {
                            const e = r.spot[l];
                            e.position.setFromMatrixPosition(u.matrixWorld),
                            e.position.applyMatrix4(d),
                            e.direction.setFromMatrixPosition(u.matrixWorld),
                            a.setFromMatrixPosition(u.target.matrixWorld),
                            e.direction.sub(a),
                            e.direction.transformDirection(d),
                            l++
                        } else if (u.isRectAreaLight) {
                            const e = r.rectArea[c];
                            e.position.setFromMatrixPosition(u.matrixWorld),
                            e.position.applyMatrix4(d),
                            o.identity(),
                            s.copy(u.matrixWorld),
                            s.premultiply(d),
                            o.extractRotation(s),
                            e.halfWidth.set(.5 * u.width, 0, 0),
                            e.halfHeight.set(0, .5 * u.height, 0),
                            e.halfWidth.applyMatrix4(o),
                            e.halfHeight.applyMatrix4(o),
                            c++
                        } else if (u.isPointLight) {
                            const e = r.point[i];
                            e.position.setFromMatrixPosition(u.matrixWorld),
                            e.position.applyMatrix4(d),
                            i++
                        } else if (u.isHemisphereLight) {
                            const e = r.hemi[h];
                            e.direction.setFromMatrixPosition(u.matrixWorld),
                            e.direction.transformDirection(d),
                            h++
                        }
                    }
                },
                state: r
            }
        }
        function $a(e, t) {
            const n = new Qa(e,t)
              , i = []
              , r = [];
            return {
                init: function() {
                    i.length = 0,
                    r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function(e) {
                    n.setup(i, e)
                },
                setupLightsView: function(e) {
                    n.setupView(i, e)
                },
                pushLight: function(e) {
                    i.push(e)
                },
                pushShadow: function(e) {
                    r.push(e)
                }
            }
        }
        function es(e, t) {
            let n = new WeakMap;
            return {
                get: function(i, r=0) {
                    const a = n.get(i);
                    let s;
                    return void 0 === a ? (s = new $a(e,t),
                    n.set(i, [s])) : r >= a.length ? (s = new $a(e,t),
                    a.push(s)) : s = a[r],
                    s
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class ts extends Ln {
            constructor(e) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = 3200,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.depthPacking = e.depthPacking,
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this
            }
        }
        class ns extends Ln {
            constructor(e) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this
            }
        }
        function is(e, t, n) {
            let i = new Ri;
            const r = new De
              , a = new De
              , s = new rt
              , o = new ts({
                depthPacking: 3201
            })
              , l = new ns
              , c = {}
              , h = n.maxTextureSize
              , d = {
                0: 1,
                1: 0,
                2: 2
            }
              , u = new wi({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new De
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , p = u.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new qn;
            f.setAttribute("position", new Dn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const m = new di(f,u)
              , g = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = 1;
            let v = this.type;
            function w(n, i) {
                const a = t.update(m);
                u.defines.VSM_SAMPLES !== n.blurSamples && (u.defines.VSM_SAMPLES = n.blurSamples,
                p.defines.VSM_SAMPLES = n.blurSamples,
                u.needsUpdate = !0,
                p.needsUpdate = !0),
                null === n.mapPass && (n.mapPass = new st(r.x,r.y)),
                u.uniforms.shadow_pass.value = n.map.texture,
                u.uniforms.resolution.value = n.mapSize,
                u.uniforms.radius.value = n.radius,
                e.setRenderTarget(n.mapPass),
                e.clear(),
                e.renderBufferDirect(i, null, a, u, m, null),
                p.uniforms.shadow_pass.value = n.mapPass.texture,
                p.uniforms.resolution.value = n.mapSize,
                p.uniforms.radius.value = n.radius,
                e.setRenderTarget(n.map),
                e.clear(),
                e.renderBufferDirect(i, null, a, p, m, null)
            }
            function y(t, n, i, r) {
                let a = null;
                const s = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== s)
                    a = s;
                else if (a = !0 === i.isPointLight ? l : o,
                e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const e = a.uuid
                      , t = n.uuid;
                    let i = c[e];
                    void 0 === i && (i = {},
                    c[e] = i);
                    let r = i[t];
                    void 0 === r && (r = a.clone(),
                    i[t] = r,
                    n.addEventListener("dispose", x)),
                    a = r
                }
                if (a.visible = n.visible,
                a.wireframe = n.wireframe,
                a.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side],
                a.alphaMap = n.alphaMap,
                a.alphaTest = n.alphaTest,
                a.map = n.map,
                a.clipShadows = n.clipShadows,
                a.clippingPlanes = n.clippingPlanes,
                a.clipIntersection = n.clipIntersection,
                a.displacementMap = n.displacementMap,
                a.displacementScale = n.displacementScale,
                a.displacementBias = n.displacementBias,
                a.wireframeLinewidth = n.wireframeLinewidth,
                a.linewidth = n.linewidth,
                !0 === i.isPointLight && !0 === a.isMeshDistanceMaterial) {
                    e.properties.get(a).light = i
                }
                return a
            }
            function _(n, r, a, s, o) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                    const i = t.update(n)
                      , l = n.material;
                    if (Array.isArray(l)) {
                        const t = i.groups;
                        for (let c = 0, h = t.length; c < h; c++) {
                            const h = t[c]
                              , d = l[h.materialIndex];
                            if (d && d.visible) {
                                const t = y(n, d, s, o);
                                n.onBeforeShadow(e, n, r, a, i, t, h),
                                e.renderBufferDirect(a, null, i, t, n, h),
                                n.onAfterShadow(e, n, r, a, i, t, h)
                            }
                        }
                    } else if (l.visible) {
                        const t = y(n, l, s, o);
                        n.onBeforeShadow(e, n, r, a, i, t, null),
                        e.renderBufferDirect(a, null, i, t, n, null),
                        n.onAfterShadow(e, n, r, a, i, t, null)
                    }
                }
                const l = n.children;
                for (let e = 0, t = l.length; e < t; e++)
                    _(l[e], r, a, s, o)
            }
            function x(e) {
                e.target.removeEventListener("dispose", x);
                for (const t in c) {
                    const n = c[t]
                      , i = e.target.uuid;
                    if (i in n) {
                        n[i].dispose(),
                        delete n[i]
                    }
                }
            }
            this.render = function(t, n, o) {
                if (!1 === g.enabled)
                    return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                    return;
                if (0 === t.length)
                    return;
                const l = e.getRenderTarget()
                  , c = e.getActiveCubeFace()
                  , d = e.getActiveMipmapLevel()
                  , u = e.state;
                u.setBlending(0),
                u.buffers.color.setClear(1, 1, 1, 1),
                u.buffers.depth.setTest(!0),
                u.setScissorTest(!1);
                const p = 3 !== v && 3 === this.type
                  , f = 3 === v && 3 !== this.type;
                for (let l = 0, c = t.length; l < c; l++) {
                    const c = t[l]
                      , d = c.shadow;
                    if (void 0 === d) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === d.autoUpdate && !1 === d.needsUpdate)
                        continue;
                    r.copy(d.mapSize);
                    const m = d.getFrameExtents();
                    if (r.multiply(m),
                    a.copy(d.mapSize),
                    (r.x > h || r.y > h) && (r.x > h && (a.x = Math.floor(h / m.x),
                    r.x = a.x * m.x,
                    d.mapSize.x = a.x),
                    r.y > h && (a.y = Math.floor(h / m.y),
                    r.y = a.y * m.y,
                    d.mapSize.y = a.y)),
                    null === d.map || !0 === p || !0 === f) {
                        const e = 3 !== this.type ? {
                            minFilter: I,
                            magFilter: I
                        } : {};
                        null !== d.map && d.map.dispose(),
                        d.map = new st(r.x,r.y,e),
                        d.map.texture.name = c.name + ".shadowMap",
                        d.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(d.map),
                    e.clear();
                    const g = d.getViewportCount();
                    for (let e = 0; e < g; e++) {
                        const t = d.getViewport(e);
                        s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w),
                        u.viewport(s),
                        d.updateMatrices(c, e),
                        i = d.getFrustum(),
                        _(n, o, d.camera, c, this.type)
                    }
                    !0 !== d.isPointLightShadow && 3 === this.type && w(d, o),
                    d.needsUpdate = !1
                }
                v = this.type,
                g.needsUpdate = !1,
                e.setRenderTarget(l, c, d)
            }
        }
        function rs(e, t, n) {
            const i = n.isWebGL2;
            const r = new function() {
                let t = !1;
                const n = new rt;
                let i = null;
                const r = new rt(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || t || (e.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, i, a, s, o) {
                        !0 === o && (t *= s,
                        i *= s,
                        a *= s),
                        n.set(t, i, a, s),
                        !1 === r.equals(n) && (e.clearColor(t, i, a, s),
                        r.copy(n))
                    },
                    reset: function() {
                        t = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , a = new function() {
                let t = !1
                  , n = null
                  , i = null
                  , r = null;
                return {
                    setTest: function(t) {
                        t ? V(e.DEPTH_TEST) : G(e.DEPTH_TEST)
                    },
                    setMask: function(i) {
                        n === i || t || (e.depthMask(i),
                        n = i)
                    },
                    setFunc: function(t) {
                        if (i !== t) {
                            switch (t) {
                            case 0:
                                e.depthFunc(e.NEVER);
                                break;
                            case 1:
                                e.depthFunc(e.ALWAYS);
                                break;
                            case 2:
                                e.depthFunc(e.LESS);
                                break;
                            case 3:
                            default:
                                e.depthFunc(e.LEQUAL);
                                break;
                            case 4:
                                e.depthFunc(e.EQUAL);
                                break;
                            case 5:
                                e.depthFunc(e.GEQUAL);
                                break;
                            case 6:
                                e.depthFunc(e.GREATER);
                                break;
                            case 7:
                                e.depthFunc(e.NOTEQUAL)
                            }
                            i = t
                        }
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        r !== t && (e.clearDepth(t),
                        r = t)
                    },
                    reset: function() {
                        t = !1,
                        n = null,
                        i = null,
                        r = null
                    }
                }
            }
              , s = new function() {
                let t = !1
                  , n = null
                  , i = null
                  , r = null
                  , a = null
                  , s = null
                  , o = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(n) {
                        t || (n ? V(e.STENCIL_TEST) : G(e.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || t || (e.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(t, n, s) {
                        i === t && r === n && a === s || (e.stencilFunc(t, n, s),
                        i = t,
                        r = n,
                        a = s)
                    },
                    setOp: function(t, n, i) {
                        s === t && o === n && l === i || (e.stencilOp(t, n, i),
                        s = t,
                        o = n,
                        l = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        c !== t && (e.clearStencil(t),
                        c = t)
                    },
                    reset: function() {
                        t = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        s = null,
                        o = null,
                        l = null,
                        c = null
                    }
                }
            }
              , o = new WeakMap
              , l = new WeakMap;
            let c = {}
              , h = {}
              , d = new WeakMap
              , u = []
              , p = null
              , f = !1
              , m = null
              , g = null
              , v = null
              , w = null
              , y = null
              , _ = null
              , x = null
              , b = new An(0,0,0)
              , S = 0
              , M = !1
              , T = null
              , k = null
              , C = null
              , A = null
              , P = null;
            const R = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let L = !1
              , I = 0;
            const N = e.getParameter(e.VERSION);
            -1 !== N.indexOf("WebGL") ? (I = parseFloat(/^WebGL (\d)/.exec(N)[1]),
            L = I >= 1) : -1 !== N.indexOf("OpenGL ES") && (I = parseFloat(/^OpenGL ES (\d)/.exec(N)[1]),
            L = I >= 2);
            let U = null
              , D = {};
            const B = e.getParameter(e.SCISSOR_BOX)
              , O = e.getParameter(e.VIEWPORT)
              , z = (new rt).fromArray(B)
              , F = (new rt).fromArray(O);
            function W(t, n, r, a) {
                const s = new Uint8Array(4)
                  , o = e.createTexture();
                e.bindTexture(t, o),
                e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                for (let o = 0; o < r; o++)
                    !i || t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY ? e.texImage2D(n + o, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage3D(n, 0, e.RGBA, 1, 1, a, 0, e.RGBA, e.UNSIGNED_BYTE, s);
                return o
            }
            const H = {};
            function V(t) {
                !0 !== c[t] && (e.enable(t),
                c[t] = !0)
            }
            function G(t) {
                !1 !== c[t] && (e.disable(t),
                c[t] = !1)
            }
            H[e.TEXTURE_2D] = W(e.TEXTURE_2D, e.TEXTURE_2D, 1),
            H[e.TEXTURE_CUBE_MAP] = W(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            i && (H[e.TEXTURE_2D_ARRAY] = W(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
            H[e.TEXTURE_3D] = W(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)),
            r.setClear(0, 0, 0, 1),
            a.setClear(1),
            s.setClear(0),
            V(e.DEPTH_TEST),
            a.setFunc(3),
            Y(!1),
            Z(1),
            V(e.CULL_FACE),
            q(0);
            const j = {
                [E]: e.FUNC_ADD,
                101: e.FUNC_SUBTRACT,
                102: e.FUNC_REVERSE_SUBTRACT
            };
            if (i)
                j[103] = e.MIN,
                j[104] = e.MAX;
            else {
                const e = t.get("EXT_blend_minmax");
                null !== e && (j[103] = e.MIN_EXT,
                j[104] = e.MAX_EXT)
            }
            const X = {
                200: e.ZERO,
                201: e.ONE,
                202: e.SRC_COLOR,
                204: e.SRC_ALPHA,
                210: e.SRC_ALPHA_SATURATE,
                208: e.DST_COLOR,
                206: e.DST_ALPHA,
                203: e.ONE_MINUS_SRC_COLOR,
                205: e.ONE_MINUS_SRC_ALPHA,
                209: e.ONE_MINUS_DST_COLOR,
                207: e.ONE_MINUS_DST_ALPHA,
                211: e.CONSTANT_COLOR,
                212: e.ONE_MINUS_CONSTANT_COLOR,
                213: e.CONSTANT_ALPHA,
                214: e.ONE_MINUS_CONSTANT_ALPHA
            };
            function q(t, n, i, r, a, s, o, l, c, h) {
                if (0 !== t) {
                    if (!1 === f && (V(e.BLEND),
                    f = !0),
                    5 === t)
                        a = a || n,
                        s = s || i,
                        o = o || r,
                        n === g && a === y || (e.blendEquationSeparate(j[n], j[a]),
                        g = n,
                        y = a),
                        i === v && r === w && s === _ && o === x || (e.blendFuncSeparate(X[i], X[r], X[s], X[o]),
                        v = i,
                        w = r,
                        _ = s,
                        x = o),
                        !1 !== l.equals(b) && c === S || (e.blendColor(l.r, l.g, l.b, c),
                        b.copy(l),
                        S = c),
                        m = t,
                        M = !1;
                    else if (t !== m || h !== M) {
                        if (g === E && y === E || (e.blendEquation(e.FUNC_ADD),
                        g = E,
                        y = E),
                        h)
                            switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.ONE, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        else
                            switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        v = null,
                        w = null,
                        _ = null,
                        x = null,
                        b.set(0, 0, 0),
                        S = 0,
                        m = t,
                        M = h
                    }
                } else
                    !0 === f && (G(e.BLEND),
                    f = !1)
            }
            function Y(t) {
                T !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                T = t)
            }
            function Z(t) {
                0 !== t ? (V(e.CULL_FACE),
                t !== k && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : G(e.CULL_FACE),
                k = t
            }
            function K(t, n, i) {
                t ? (V(e.POLYGON_OFFSET_FILL),
                A === n && P === i || (e.polygonOffset(n, i),
                A = n,
                P = i)) : G(e.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: r,
                    depth: a,
                    stencil: s
                },
                enable: V,
                disable: G,
                bindFramebuffer: function(t, n) {
                    return h[t] !== n && (e.bindFramebuffer(t, n),
                    h[t] = n,
                    i && (t === e.DRAW_FRAMEBUFFER && (h[e.FRAMEBUFFER] = n),
                    t === e.FRAMEBUFFER && (h[e.DRAW_FRAMEBUFFER] = n)),
                    !0)
                },
                drawBuffers: function(i, r) {
                    let a = u
                      , s = !1;
                    if (i)
                        if (a = d.get(r),
                        void 0 === a && (a = [],
                        d.set(r, a)),
                        i.isWebGLMultipleRenderTargets) {
                            const t = i.texture;
                            if (a.length !== t.length || a[0] !== e.COLOR_ATTACHMENT0) {
                                for (let n = 0, i = t.length; n < i; n++)
                                    a[n] = e.COLOR_ATTACHMENT0 + n;
                                a.length = t.length,
                                s = !0
                            }
                        } else
                            a[0] !== e.COLOR_ATTACHMENT0 && (a[0] = e.COLOR_ATTACHMENT0,
                            s = !0);
                    else
                        a[0] !== e.BACK && (a[0] = e.BACK,
                        s = !0);
                    s && (n.isWebGL2 ? e.drawBuffers(a) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))
                },
                useProgram: function(t) {
                    return p !== t && (e.useProgram(t),
                    p = t,
                    !0)
                },
                setBlending: q,
                setMaterial: function(t, n) {
                    2 === t.side ? G(e.CULL_FACE) : V(e.CULL_FACE);
                    let i = 1 === t.side;
                    n && (i = !i),
                    Y(i),
                    1 === t.blending && !1 === t.transparent ? q(0) : q(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                    a.setFunc(t.depthFunc),
                    a.setTest(t.depthTest),
                    a.setMask(t.depthWrite),
                    r.setMask(t.colorWrite);
                    const o = t.stencilWrite;
                    s.setTest(o),
                    o && (s.setMask(t.stencilWriteMask),
                    s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    K(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? V(e.SAMPLE_ALPHA_TO_COVERAGE) : G(e.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: Y,
                setCullFace: Z,
                setLineWidth: function(t) {
                    t !== C && (L && e.lineWidth(t),
                    C = t)
                },
                setPolygonOffset: K,
                setScissorTest: function(t) {
                    t ? V(e.SCISSOR_TEST) : G(e.SCISSOR_TEST)
                },
                activeTexture: function(t) {
                    void 0 === t && (t = e.TEXTURE0 + R - 1),
                    U !== t && (e.activeTexture(t),
                    U = t)
                },
                bindTexture: function(t, n, i) {
                    void 0 === i && (i = null === U ? e.TEXTURE0 + R - 1 : U);
                    let r = D[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    },
                    D[i] = r),
                    r.type === t && r.texture === n || (U !== i && (e.activeTexture(i),
                    U = i),
                    e.bindTexture(t, n || H[t]),
                    r.type = t,
                    r.texture = n)
                },
                unbindTexture: function() {
                    const t = D[U];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                    t.type = void 0,
                    t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        e.compressedTexImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                updateUBOMapping: function(t, n) {
                    let i = l.get(n);
                    void 0 === i && (i = new WeakMap,
                    l.set(n, i));
                    let r = i.get(t);
                    void 0 === r && (r = e.getUniformBlockIndex(n, t.name),
                    i.set(t, r))
                },
                uniformBlockBinding: function(t, n) {
                    const i = l.get(n).get(t);
                    o.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex),
                    o.set(n, i))
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        e.compressedTexSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                scissor: function(t) {
                    !1 === z.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                    z.copy(t))
                },
                viewport: function(t) {
                    !1 === F.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                    F.copy(t))
                },
                reset: function() {
                    e.disable(e.BLEND),
                    e.disable(e.CULL_FACE),
                    e.disable(e.DEPTH_TEST),
                    e.disable(e.POLYGON_OFFSET_FILL),
                    e.disable(e.SCISSOR_TEST),
                    e.disable(e.STENCIL_TEST),
                    e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                    e.blendEquation(e.FUNC_ADD),
                    e.blendFunc(e.ONE, e.ZERO),
                    e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                    e.blendColor(0, 0, 0, 0),
                    e.colorMask(!0, !0, !0, !0),
                    e.clearColor(0, 0, 0, 0),
                    e.depthMask(!0),
                    e.depthFunc(e.LESS),
                    e.clearDepth(1),
                    e.stencilMask(4294967295),
                    e.stencilFunc(e.ALWAYS, 0, 4294967295),
                    e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                    e.clearStencil(0),
                    e.cullFace(e.BACK),
                    e.frontFace(e.CCW),
                    e.polygonOffset(0, 0),
                    e.activeTexture(e.TEXTURE0),
                    e.bindFramebuffer(e.FRAMEBUFFER, null),
                    !0 === i && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                    e.bindFramebuffer(e.READ_FRAMEBUFFER, null)),
                    e.useProgram(null),
                    e.lineWidth(1),
                    e.scissor(0, 0, e.canvas.width, e.canvas.height),
                    e.viewport(0, 0, e.canvas.width, e.canvas.height),
                    c = {},
                    U = null,
                    D = {},
                    h = {},
                    d = new WeakMap,
                    u = [],
                    p = null,
                    f = !1,
                    m = null,
                    g = null,
                    v = null,
                    w = null,
                    y = null,
                    _ = null,
                    x = null,
                    b = new An(0,0,0),
                    S = 0,
                    M = !1,
                    T = null,
                    k = null,
                    C = null,
                    A = null,
                    P = null,
                    z.set(0, 0, e.canvas.width, e.canvas.height),
                    F.set(0, 0, e.canvas.width, e.canvas.height),
                    r.reset(),
                    a.reset(),
                    s.reset()
                }
            }
        }
        function as(e, t, n, i, r, a, s) {
            const o = r.isWebGL2
              , l = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
              , c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
              , h = new WeakMap;
            let d;
            const u = new WeakMap;
            let p = !1;
            try {
                p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (e) {}
            function f(e, t) {
                return p ? new OffscreenCanvas(e,t) : Fe("canvas")
            }
            function m(e, t, n, i) {
                let r = 1;
                if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)),
                r < 1 || !0 === t) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const i = t ? Le : Math.floor
                          , a = i(r * e.width)
                          , s = i(r * e.height);
                        void 0 === d && (d = f(a, s));
                        const o = n ? f(a, s) : d;
                        o.width = a,
                        o.height = s;
                        return o.getContext("2d").drawImage(e, 0, 0, a, s),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + s + ")."),
                        o
                    }
                    return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                    e
                }
                return e
            }
            function g(e) {
                return Re(e.width) && Re(e.height)
            }
            function v(e, t) {
                return e.generateMipmaps && t && e.minFilter !== I && e.minFilter !== D
            }
            function w(t) {
                e.generateMipmap(t)
            }
            function y(n, i, r, a, s=!1) {
                if (!1 === o)
                    return i;
                if (null !== n) {
                    if (void 0 !== e[n])
                        return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = i;
                if (i === e.RED && (r === e.FLOAT && (l = e.R32F),
                r === e.HALF_FLOAT && (l = e.R16F),
                r === e.UNSIGNED_BYTE && (l = e.R8)),
                i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (l = e.R8UI),
                r === e.UNSIGNED_SHORT && (l = e.R16UI),
                r === e.UNSIGNED_INT && (l = e.R32UI),
                r === e.BYTE && (l = e.R8I),
                r === e.SHORT && (l = e.R16I),
                r === e.INT && (l = e.R32I)),
                i === e.RG && (r === e.FLOAT && (l = e.RG32F),
                r === e.HALF_FLOAT && (l = e.RG16F),
                r === e.UNSIGNED_BYTE && (l = e.RG8)),
                i === e.RGBA) {
                    const t = s ? ue : Ye.getTransfer(a);
                    r === e.FLOAT && (l = e.RGBA32F),
                    r === e.HALF_FLOAT && (l = e.RGBA16F),
                    r === e.UNSIGNED_BYTE && (l = t === pe ? e.SRGB8_ALPHA8 : e.RGBA8),
                    r === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4),
                    r === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1)
                }
                return l !== e.R16F && l !== e.R32F && l !== e.RG16F && l !== e.RG32F && l !== e.RGBA16F && l !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                l
            }
            function _(e, t, n) {
                return !0 === v(e, n) || e.isFramebufferTexture && e.minFilter !== I && e.minFilter !== D ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }
            function x(t) {
                return t === I || t === N || t === U ? e.NEAREST : e.LINEAR
            }
            function b(e) {
                const t = e.target;
                t.removeEventListener("dispose", b),
                function(e) {
                    const t = i.get(e);
                    if (void 0 === t.__webglInit)
                        return;
                    const n = e.source
                      , r = u.get(n);
                    if (r) {
                        const i = r[t.__cacheKey];
                        i.usedTimes--,
                        0 === i.usedTimes && S(e),
                        0 === Object.keys(r).length && u.delete(n)
                    }
                    i.remove(e)
                }(t),
                t.isVideoTexture && h.delete(t)
            }
            function E(t) {
                const n = t.target;
                n.removeEventListener("dispose", E),
                function(t) {
                    const n = t.texture
                      , r = i.get(t)
                      , a = i.get(n);
                    void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture),
                    s.memory.textures--);
                    t.depthTexture && t.depthTexture.dispose();
                    if (t.isWebGLCubeRenderTarget)
                        for (let t = 0; t < 6; t++) {
                            if (Array.isArray(r.__webglFramebuffer[t]))
                                for (let n = 0; n < r.__webglFramebuffer[t].length; n++)
                                    e.deleteFramebuffer(r.__webglFramebuffer[t][n]);
                            else
                                e.deleteFramebuffer(r.__webglFramebuffer[t]);
                            r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t])
                        }
                    else {
                        if (Array.isArray(r.__webglFramebuffer))
                            for (let t = 0; t < r.__webglFramebuffer.length; t++)
                                e.deleteFramebuffer(r.__webglFramebuffer[t]);
                        else
                            e.deleteFramebuffer(r.__webglFramebuffer);
                        if (r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer),
                        r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                        r.__webglColorRenderbuffer)
                            for (let t = 0; t < r.__webglColorRenderbuffer.length; t++)
                                r.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(r.__webglColorRenderbuffer[t]);
                        r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                    }
                    if (t.isWebGLMultipleRenderTargets)
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = i.get(n[t]);
                            r.__webglTexture && (e.deleteTexture(r.__webglTexture),
                            s.memory.textures--),
                            i.remove(n[t])
                        }
                    i.remove(n),
                    i.remove(t)
                }(n)
            }
            function S(t) {
                const n = i.get(t);
                e.deleteTexture(n.__webglTexture);
                const r = t.source;
                delete u.get(r)[n.__cacheKey],
                s.memory.textures--
            }
            let M = 0;
            function T(t, r) {
                const a = i.get(t);
                if (t.isVideoTexture && function(e) {
                    const t = s.render.frame;
                    h.get(e) !== t && (h.set(e, t),
                    e.update())
                }(t),
                !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) {
                    const e = t.image;
                    if (null === e)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== e.complete)
                            return void K(a, t, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + r)
            }
            const k = {
                [P]: e.REPEAT,
                [R]: e.CLAMP_TO_EDGE,
                [L]: e.MIRRORED_REPEAT
            }
              , C = {
                [I]: e.NEAREST,
                [N]: e.NEAREST_MIPMAP_NEAREST,
                [U]: e.NEAREST_MIPMAP_LINEAR,
                [D]: e.LINEAR,
                [B]: e.LINEAR_MIPMAP_NEAREST,
                [O]: e.LINEAR_MIPMAP_LINEAR
            }
              , A = {
                512: e.NEVER,
                519: e.ALWAYS,
                513: e.LESS,
                515: e.LEQUAL,
                514: e.EQUAL,
                518: e.GEQUAL,
                516: e.GREATER,
                517: e.NOTEQUAL
            };
            function W(n, a, s) {
                if (s ? (e.texParameteri(n, e.TEXTURE_WRAP_S, k[a.wrapS]),
                e.texParameteri(n, e.TEXTURE_WRAP_T, k[a.wrapT]),
                n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, k[a.wrapR]),
                e.texParameteri(n, e.TEXTURE_MAG_FILTER, C[a.magFilter]),
                e.texParameteri(n, e.TEXTURE_MIN_FILTER, C[a.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE),
                a.wrapS === R && a.wrapT === R || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                e.texParameteri(n, e.TEXTURE_MAG_FILTER, x(a.magFilter)),
                e.texParameteri(n, e.TEXTURE_MIN_FILTER, x(a.minFilter)),
                a.minFilter !== I && a.minFilter !== D && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, A[a.compareFunction])),
                !0 === t.has("EXT_texture_filter_anisotropic")) {
                    const s = t.get("EXT_texture_filter_anisotropic");
                    if (a.magFilter === I)
                        return;
                    if (a.minFilter !== U && a.minFilter !== O)
                        return;
                    if (a.type === V && !1 === t.has("OES_texture_float_linear"))
                        return;
                    if (!1 === o && a.type === G && !1 === t.has("OES_texture_half_float_linear"))
                        return;
                    (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
                    i.get(a).__currentAnisotropy = a.anisotropy)
                }
            }
            function Z(t, n) {
                let i = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0,
                n.addEventListener("dispose", b));
                const r = n.source;
                let a = u.get(r);
                void 0 === a && (a = {},
                u.set(r, a));
                const o = function(e) {
                    const t = [];
                    return t.push(e.wrapS),
                    t.push(e.wrapT),
                    t.push(e.wrapR || 0),
                    t.push(e.magFilter),
                    t.push(e.minFilter),
                    t.push(e.anisotropy),
                    t.push(e.internalFormat),
                    t.push(e.format),
                    t.push(e.type),
                    t.push(e.generateMipmaps),
                    t.push(e.premultiplyAlpha),
                    t.push(e.flipY),
                    t.push(e.unpackAlignment),
                    t.push(e.colorSpace),
                    t.join()
                }(n);
                if (o !== t.__cacheKey) {
                    void 0 === a[o] && (a[o] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    },
                    s.memory.textures++,
                    i = !0),
                    a[o].usedTimes++;
                    const r = a[t.__cacheKey];
                    void 0 !== r && (a[t.__cacheKey].usedTimes--,
                    0 === r.usedTimes && S(n)),
                    t.__cacheKey = o,
                    t.__webglTexture = a[o].texture
                }
                return i
            }
            function K(t, s, l) {
                let c = e.TEXTURE_2D;
                (s.isDataArrayTexture || s.isCompressedArrayTexture) && (c = e.TEXTURE_2D_ARRAY),
                s.isData3DTexture && (c = e.TEXTURE_3D);
                const h = Z(t, s)
                  , d = s.source;
                n.bindTexture(c, t.__webglTexture, e.TEXTURE0 + l);
                const u = i.get(d);
                if (d.version !== u.__version || !0 === h) {
                    n.activeTexture(e.TEXTURE0 + l);
                    const t = Ye.getPrimaries(Ye.workingColorSpace)
                      , i = s.colorSpace === oe ? null : Ye.getPrimaries(s.colorSpace)
                      , p = s.colorSpace === oe || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                    e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                    e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                    const f = function(e) {
                        return !o && (e.wrapS !== R || e.wrapT !== R || e.minFilter !== I && e.minFilter !== D)
                    }(s) && !1 === g(s.image);
                    let x = m(s.image, f, !1, r.maxTextureSize);
                    x = ne(s, x);
                    const b = g(x) || o
                      , E = a.convert(s.format, s.colorSpace);
                    let S, M = a.convert(s.type), T = y(s.internalFormat, E, M, s.colorSpace, s.isVideoTexture);
                    W(c, s, b);
                    const k = s.mipmaps
                      , C = o && !0 !== s.isVideoTexture && 36196 !== T
                      , A = void 0 === u.__version || !0 === h
                      , P = _(s, x, b);
                    if (s.isDepthTexture)
                        T = e.DEPTH_COMPONENT,
                        o ? T = s.type === V ? e.DEPTH_COMPONENT32F : s.type === H ? e.DEPTH_COMPONENT24 : s.type === j ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : s.type === V && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                        s.format === q && T === e.DEPTH_COMPONENT && s.type !== F && s.type !== H && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        s.type = H,
                        M = a.convert(s.type)),
                        s.format === Y && T === e.DEPTH_COMPONENT && (T = e.DEPTH_STENCIL,
                        s.type !== j && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        s.type = j,
                        M = a.convert(s.type))),
                        A && (C ? n.texStorage2D(e.TEXTURE_2D, 1, T, x.width, x.height) : n.texImage2D(e.TEXTURE_2D, 0, T, x.width, x.height, 0, E, M, null));
                    else if (s.isDataTexture)
                        if (k.length > 0 && b) {
                            C && A && n.texStorage2D(e.TEXTURE_2D, P, T, k[0].width, k[0].height);
                            for (let t = 0, i = k.length; t < i; t++)
                                S = k[t],
                                C ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, E, M, S.data) : n.texImage2D(e.TEXTURE_2D, t, T, S.width, S.height, 0, E, M, S.data);
                            s.generateMipmaps = !1
                        } else
                            C ? (A && n.texStorage2D(e.TEXTURE_2D, P, T, x.width, x.height),
                            n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, x.width, x.height, E, M, x.data)) : n.texImage2D(e.TEXTURE_2D, 0, T, x.width, x.height, 0, E, M, x.data);
                    else if (s.isCompressedTexture)
                        if (s.isCompressedArrayTexture) {
                            C && A && n.texStorage3D(e.TEXTURE_2D_ARRAY, P, T, k[0].width, k[0].height, x.depth);
                            for (let t = 0, i = k.length; t < i; t++)
                                S = k[t],
                                s.format !== X ? null !== E ? C ? n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, x.depth, E, S.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, T, S.width, S.height, x.depth, 0, S.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, x.depth, E, M, S.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, T, S.width, S.height, x.depth, 0, E, M, S.data)
                        } else {
                            C && A && n.texStorage2D(e.TEXTURE_2D, P, T, k[0].width, k[0].height);
                            for (let t = 0, i = k.length; t < i; t++)
                                S = k[t],
                                s.format !== X ? null !== E ? C ? n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, E, S.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, T, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, E, M, S.data) : n.texImage2D(e.TEXTURE_2D, t, T, S.width, S.height, 0, E, M, S.data)
                        }
                    else if (s.isDataArrayTexture)
                        C ? (A && n.texStorage3D(e.TEXTURE_2D_ARRAY, P, T, x.width, x.height, x.depth),
                        n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, x.width, x.height, x.depth, E, M, x.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, T, x.width, x.height, x.depth, 0, E, M, x.data);
                    else if (s.isData3DTexture)
                        C ? (A && n.texStorage3D(e.TEXTURE_3D, P, T, x.width, x.height, x.depth),
                        n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, x.width, x.height, x.depth, E, M, x.data)) : n.texImage3D(e.TEXTURE_3D, 0, T, x.width, x.height, x.depth, 0, E, M, x.data);
                    else if (s.isFramebufferTexture) {
                        if (A)
                            if (C)
                                n.texStorage2D(e.TEXTURE_2D, P, T, x.width, x.height);
                            else {
                                let t = x.width
                                  , i = x.height;
                                for (let r = 0; r < P; r++)
                                    n.texImage2D(e.TEXTURE_2D, r, T, t, i, 0, E, M, null),
                                    t >>= 1,
                                    i >>= 1
                            }
                    } else if (k.length > 0 && b) {
                        C && A && n.texStorage2D(e.TEXTURE_2D, P, T, k[0].width, k[0].height);
                        for (let t = 0, i = k.length; t < i; t++)
                            S = k[t],
                            C ? n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, E, M, S) : n.texImage2D(e.TEXTURE_2D, t, T, E, M, S);
                        s.generateMipmaps = !1
                    } else
                        C ? (A && n.texStorage2D(e.TEXTURE_2D, P, T, x.width, x.height),
                        n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, E, M, x)) : n.texImage2D(e.TEXTURE_2D, 0, T, E, M, x);
                    v(s, b) && w(c),
                    u.__version = d.version,
                    s.onUpdate && s.onUpdate(s)
                }
                t.__version = s.version
            }
            function J(t, r, s, o, c, h) {
                const d = a.convert(s.format, s.colorSpace)
                  , u = a.convert(s.type)
                  , p = y(s.internalFormat, d, u, s.colorSpace);
                if (!i.get(r).__hasExternalTextures) {
                    const t = Math.max(1, r.width >> h)
                      , i = Math.max(1, r.height >> h);
                    c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, p, t, i, r.depth, 0, d, u, null) : n.texImage2D(c, h, p, t, i, 0, d, u, null)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, t),
                te(r) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, c, i.get(s).__webglTexture, 0, ee(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, o, c, i.get(s).__webglTexture, h),
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            function Q(t, n, i) {
                if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                n.depthBuffer && !n.stencilBuffer) {
                    let r = !0 === o ? e.DEPTH_COMPONENT24 : e.DEPTH_COMPONENT16;
                    if (i || te(n)) {
                        const t = n.depthTexture;
                        t && t.isDepthTexture && (t.type === V ? r = e.DEPTH_COMPONENT32F : t.type === H && (r = e.DEPTH_COMPONENT24));
                        const i = ee(n);
                        te(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, r, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, i, r, n.width, n.height)
                    } else
                        e.renderbufferStorage(e.RENDERBUFFER, r, n.width, n.height);
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = ee(n);
                    i && !1 === te(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : te(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
                } else {
                    const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let r = 0; r < t.length; r++) {
                        const s = t[r]
                          , o = a.convert(s.format, s.colorSpace)
                          , c = a.convert(s.type)
                          , h = y(s.internalFormat, o, c, s.colorSpace)
                          , d = ee(n);
                        i && !1 === te(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, h, n.width, n.height) : te(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, h, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, h, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }
            function $(t) {
                const r = i.get(t)
                  , a = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (a)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(t, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        T(r.depthTexture, 0);
                        const a = i.get(r.depthTexture).__webglTexture
                          , s = ee(r);
                        if (r.depthTexture.format === q)
                            te(r) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0);
                        else {
                            if (r.depthTexture.format !== Y)
                                throw new Error("Unknown depthTexture format");
                            te(r) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0)
                        }
                    }(r.__webglFramebuffer, t)
                } else if (a) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]),
                        r.__webglDepthbuffer[i] = e.createRenderbuffer(),
                        Q(r.__webglDepthbuffer[i], t, !1)
                } else
                    n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
                    r.__webglDepthbuffer = e.createRenderbuffer(),
                    Q(r.__webglDepthbuffer, t, !1);
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            function ee(e) {
                return Math.min(r.maxSamples, e.samples)
            }
            function te(e) {
                const n = i.get(e);
                return o && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }
            function ne(e, n) {
                const i = e.colorSpace
                  , r = e.format
                  , a = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === ye || i !== ce && i !== oe && (Ye.getTransfer(i) === pe ? !1 === o ? !0 === t.has("EXT_sRGB") && r === X ? (e.format = ye,
                e.minFilter = D,
                e.generateMipmaps = !1) : n = Qe.sRGBToLinear(n) : r === X && a === z || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)),
                n
            }
            this.allocateTextureUnit = function() {
                const e = M;
                return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures),
                M += 1,
                e
            }
            ,
            this.resetTextureUnits = function() {
                M = 0
            }
            ,
            this.setTexture2D = T,
            this.setTexture2DArray = function(t, r) {
                const a = i.get(t);
                t.version > 0 && a.__version !== t.version ? K(a, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + r)
            }
            ,
            this.setTexture3D = function(t, r) {
                const a = i.get(t);
                t.version > 0 && a.__version !== t.version ? K(a, t, r) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + r)
            }
            ,
            this.setTextureCube = function(t, s) {
                const l = i.get(t);
                t.version > 0 && l.__version !== t.version ? function(t, s, l) {
                    if (6 !== s.image.length)
                        return;
                    const c = Z(t, s)
                      , h = s.source;
                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + l);
                    const d = i.get(h);
                    if (h.version !== d.__version || !0 === c) {
                        n.activeTexture(e.TEXTURE0 + l);
                        const t = Ye.getPrimaries(Ye.workingColorSpace)
                          , i = s.colorSpace === oe ? null : Ye.getPrimaries(s.colorSpace)
                          , u = s.colorSpace === oe || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
                        e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                        const p = s.isCompressedTexture || s.image[0].isCompressedTexture
                          , f = s.image[0] && s.image[0].isDataTexture
                          , x = [];
                        for (let e = 0; e < 6; e++)
                            x[e] = p || f ? f ? s.image[e].image : s.image[e] : m(s.image[e], !1, !0, r.maxCubemapSize),
                            x[e] = ne(s, x[e]);
                        const b = x[0]
                          , E = g(b) || o
                          , S = a.convert(s.format, s.colorSpace)
                          , M = a.convert(s.type)
                          , T = y(s.internalFormat, S, M, s.colorSpace)
                          , k = o && !0 !== s.isVideoTexture
                          , C = void 0 === d.__version || !0 === c;
                        let A, P = _(s, b, E);
                        if (W(e.TEXTURE_CUBE_MAP, s, E),
                        p) {
                            k && C && n.texStorage2D(e.TEXTURE_CUBE_MAP, P, T, b.width, b.height);
                            for (let t = 0; t < 6; t++) {
                                A = x[t].mipmaps;
                                for (let i = 0; i < A.length; i++) {
                                    const r = A[i];
                                    s.format !== X ? null !== S ? k ? n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, S, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, T, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : k ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, S, M, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, T, r.width, r.height, 0, S, M, r.data)
                                }
                            }
                        } else {
                            A = s.mipmaps,
                            k && C && (A.length > 0 && P++,
                            n.texStorage2D(e.TEXTURE_CUBE_MAP, P, T, x[0].width, x[0].height));
                            for (let t = 0; t < 6; t++)
                                if (f) {
                                    k ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, x[t].width, x[t].height, S, M, x[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, T, x[t].width, x[t].height, 0, S, M, x[t].data);
                                    for (let i = 0; i < A.length; i++) {
                                        const r = A[i].image[t].image;
                                        k ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, S, M, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, T, r.width, r.height, 0, S, M, r.data)
                                    }
                                } else {
                                    k ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, S, M, x[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, T, S, M, x[t]);
                                    for (let i = 0; i < A.length; i++) {
                                        const r = A[i];
                                        k ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, S, M, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, T, S, M, r.image[t])
                                    }
                                }
                        }
                        v(s, E) && w(e.TEXTURE_CUBE_MAP),
                        d.__version = h.version,
                        s.onUpdate && s.onUpdate(s)
                    }
                    t.__version = s.version
                }(l, t, s) : n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + s)
            }
            ,
            this.rebindTextures = function(t, n, r) {
                const a = i.get(t);
                void 0 !== n && J(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                void 0 !== r && $(t)
            }
            ,
            this.setupRenderTarget = function(t) {
                const l = t.texture
                  , c = i.get(t)
                  , h = i.get(l);
                t.addEventListener("dispose", E),
                !0 !== t.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = e.createTexture()),
                h.__version = l.version,
                s.memory.textures++);
                const d = !0 === t.isWebGLCubeRenderTarget
                  , u = !0 === t.isWebGLMultipleRenderTargets
                  , p = g(t) || o;
                if (d) {
                    c.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (o && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer[t] = [];
                            for (let n = 0; n < l.mipmaps.length; n++)
                                c.__webglFramebuffer[t][n] = e.createFramebuffer()
                        } else
                            c.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (o && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer = [];
                        for (let t = 0; t < l.mipmaps.length; t++)
                            c.__webglFramebuffer[t] = e.createFramebuffer()
                    } else
                        c.__webglFramebuffer = e.createFramebuffer();
                    if (u)
                        if (r.drawBuffers) {
                            const n = t.texture;
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = i.get(n[t]);
                                void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(),
                                s.memory.textures++)
                            }
                        } else
                            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (o && t.samples > 0 && !1 === te(t)) {
                        const i = u ? l : [l];
                        c.__webglMultisampledFramebuffer = e.createFramebuffer(),
                        c.__webglColorRenderbuffer = [],
                        n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            const r = i[n];
                            c.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                            e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const s = a.convert(r.format, r.colorSpace)
                              , o = a.convert(r.type)
                              , l = y(r.internalFormat, s, o, r.colorSpace, !0 === t.isXRRenderTarget)
                              , h = ee(t);
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null),
                        t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(),
                        Q(c.__webglDepthRenderbuffer, t, !0)),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                }
                if (d) {
                    n.bindTexture(e.TEXTURE_CUBE_MAP, h.__webglTexture),
                    W(e.TEXTURE_CUBE_MAP, l, p);
                    for (let n = 0; n < 6; n++)
                        if (o && l.mipmaps && l.mipmaps.length > 0)
                            for (let i = 0; i < l.mipmaps.length; i++)
                                J(c.__webglFramebuffer[n][i], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else
                            J(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    v(l, p) && w(e.TEXTURE_CUBE_MAP),
                    n.unbindTexture()
                } else if (u) {
                    const r = t.texture;
                    for (let a = 0, s = r.length; a < s; a++) {
                        const s = r[a]
                          , o = i.get(s);
                        n.bindTexture(e.TEXTURE_2D, o.__webglTexture),
                        W(e.TEXTURE_2D, s, p),
                        J(c.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + a, e.TEXTURE_2D, 0),
                        v(s, p) && w(e.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = e.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (o ? i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                    n.bindTexture(i, h.__webglTexture),
                    W(i, l, p),
                    o && l.mipmaps && l.mipmaps.length > 0)
                        for (let n = 0; n < l.mipmaps.length; n++)
                            J(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, i, n);
                    else
                        J(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, i, 0);
                    v(l, p) && w(i),
                    n.unbindTexture()
                }
                t.depthBuffer && $(t)
            }
            ,
            this.updateRenderTargetMipmap = function(t) {
                const r = g(t) || o
                  , a = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let s = 0, o = a.length; s < o; s++) {
                    const o = a[s];
                    if (v(o, r)) {
                        const r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D
                          , a = i.get(o).__webglTexture;
                        n.bindTexture(r, a),
                        w(r),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(t) {
                if (o && t.samples > 0 && !1 === te(t)) {
                    const r = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
                      , a = t.width
                      , s = t.height;
                    let o = e.COLOR_BUFFER_BIT;
                    const l = []
                      , h = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                      , d = i.get(t)
                      , u = !0 === t.isWebGLMultipleRenderTargets;
                    if (u)
                        for (let t = 0; t < r.length; t++)
                            n.bindFramebuffer(e.FRAMEBUFFER, d.__webglMultisampledFramebuffer),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                            n.bindFramebuffer(e.FRAMEBUFFER, d.__webglFramebuffer),
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(e.READ_FRAMEBUFFER, d.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, d.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        l.push(e.COLOR_ATTACHMENT0 + n),
                        t.depthBuffer && l.push(h);
                        const p = void 0 !== d.__ignoreDepthValues && d.__ignoreDepthValues;
                        if (!1 === p && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                        t.stencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                        u && e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, d.__webglColorRenderbuffer[n]),
                        !0 === p && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [h]),
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [h])),
                        u) {
                            const t = i.get(r[n]).__webglTexture;
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                        }
                        e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST),
                        c && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                    u)
                        for (let t = 0; t < r.length; t++) {
                            n.bindFramebuffer(e.FRAMEBUFFER, d.__webglMultisampledFramebuffer),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, d.__webglColorRenderbuffer[t]);
                            const a = i.get(r[t]).__webglTexture;
                            n.bindFramebuffer(e.FRAMEBUFFER, d.__webglFramebuffer),
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0)
                        }
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, d.__webglMultisampledFramebuffer)
                }
            }
            ,
            this.setupDepthRenderbuffer = $,
            this.setupFrameBufferTexture = J,
            this.useMultisampledRTT = te
        }
        function ss(e, t, n) {
            const i = n.isWebGL2;
            return {
                convert: function(n, r="") {
                    let a;
                    const s = Ye.getTransfer(r);
                    if (n === z)
                        return e.UNSIGNED_BYTE;
                    if (1017 === n)
                        return e.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n)
                        return e.UNSIGNED_SHORT_5_5_5_1;
                    if (1010 === n)
                        return e.BYTE;
                    if (1011 === n)
                        return e.SHORT;
                    if (n === F)
                        return e.UNSIGNED_SHORT;
                    if (n === W)
                        return e.INT;
                    if (n === H)
                        return e.UNSIGNED_INT;
                    if (n === V)
                        return e.FLOAT;
                    if (n === G)
                        return i ? e.HALF_FLOAT : (a = t.get("OES_texture_half_float"),
                        null !== a ? a.HALF_FLOAT_OES : null);
                    if (1021 === n)
                        return e.ALPHA;
                    if (n === X)
                        return e.RGBA;
                    if (1024 === n)
                        return e.LUMINANCE;
                    if (1025 === n)
                        return e.LUMINANCE_ALPHA;
                    if (n === q)
                        return e.DEPTH_COMPONENT;
                    if (n === Y)
                        return e.DEPTH_STENCIL;
                    if (n === ye)
                        return a = t.get("EXT_sRGB"),
                        null !== a ? a.SRGB_ALPHA_EXT : null;
                    if (1028 === n)
                        return e.RED;
                    if (1029 === n)
                        return e.RED_INTEGER;
                    if (1030 === n)
                        return e.RG;
                    if (1031 === n)
                        return e.RG_INTEGER;
                    if (1033 === n)
                        return e.RGBA_INTEGER;
                    if (n === Z || n === K || n === J || n === Q)
                        if (s === pe) {
                            if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                            null === a)
                                return null;
                            if (n === Z)
                                return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === K)
                                return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === J)
                                return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === Q)
                                return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (a = t.get("WEBGL_compressed_texture_s3tc"),
                            null === a)
                                return null;
                            if (n === Z)
                                return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === K)
                                return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === J)
                                return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === Q)
                                return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                        if (a = t.get("WEBGL_compressed_texture_pvrtc"),
                        null === a)
                            return null;
                        if (35840 === n)
                            return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n)
                            return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === n)
                            return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n)
                            return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === n)
                        return a = t.get("WEBGL_compressed_texture_etc1"),
                        null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === n || 37496 === n) {
                        if (a = t.get("WEBGL_compressed_texture_etc"),
                        null === a)
                            return null;
                        if (37492 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                        if (37496 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (a = t.get("WEBGL_compressed_texture_astc"),
                        null === a)
                            return null;
                        if (37808 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n)
                            return s === pe ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === $ || 36494 === n || 36495 === n) {
                        if (a = t.get("EXT_texture_compression_bptc"),
                        null === a)
                            return null;
                        if (n === $)
                            return s === pe ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (36494 === n)
                            return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (36495 === n)
                            return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                        if (a = t.get("EXT_texture_compression_rgtc"),
                        null === a)
                            return null;
                        if (n === $)
                            return a.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === n)
                            return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === n)
                            return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === n)
                            return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === j ? i ? e.UNSIGNED_INT_24_8 : (a = t.get("WEBGL_depth_texture"),
                    null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class os extends _i {
            constructor(e=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = e
            }
        }
        class ls extends un {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const cs = {
            type: "move"
        };
        class hs {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new ls,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new ls,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new ht,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new ht),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new ls,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new ht,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new ht),
                this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                null !== this._grip && this._grip.dispatchEvent(e),
                null !== this._hand && this._hand.dispatchEvent(e),
                this
            }
            connect(e) {
                if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of e.hand.values())
                            this._getHandJoint(t, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }),
                this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(e, t, n) {
                let i = null
                  , r = null
                  , a = null;
                const s = this._targetRay
                  , o = this._grip
                  , l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        a = !0;
                        for (const i of e.hand.values()) {
                            const e = t.getJointPose(i, n)
                              , r = this._getHandJoint(l, i);
                            null !== e && (r.matrix.fromArray(e.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.matrixWorldNeedsUpdate = !0,
                            r.jointRadius = e.radius),
                            r.visible = null !== e
                        }
                        const i = l.joints["index-finger-tip"]
                          , r = l.joints["thumb-tip"]
                          , s = i.position.distanceTo(r.position)
                          , o = .02
                          , c = .005;
                        l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else
                        null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                        null !== r && (o.matrix.fromArray(r.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        o.matrixWorldNeedsUpdate = !0,
                        r.linearVelocity ? (o.hasLinearVelocity = !0,
                        o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                        r.angularVelocity ? (o.hasAngularVelocity = !0,
                        o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    null !== s && (i = t.getPose(e.targetRaySpace, n),
                    null === i && null !== r && (i = r),
                    null !== i && (s.matrix.fromArray(i.transform.matrix),
                    s.matrix.decompose(s.position, s.rotation, s.scale),
                    s.matrixWorldNeedsUpdate = !0,
                    i.linearVelocity ? (s.hasLinearVelocity = !0,
                    s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1,
                    i.angularVelocity ? (s.hasAngularVelocity = !0,
                    s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1,
                    this.dispatchEvent(cs)))
                }
                return null !== s && (s.visible = null !== i),
                null !== o && (o.visible = null !== r),
                null !== l && (l.visible = null !== a),
                this
            }
            _getHandJoint(e, t) {
                if (void 0 === e.joints[t.jointName]) {
                    const n = new ls;
                    n.matrixAutoUpdate = !1,
                    n.visible = !1,
                    e.joints[t.jointName] = n,
                    e.add(n)
                }
                return e.joints[t.jointName]
            }
        }
        class ds extends be {
            constructor(e, t) {
                super();
                const n = this;
                let i = null
                  , r = 1
                  , a = null
                  , s = "local-floor"
                  , o = 1
                  , l = null
                  , c = null
                  , h = null
                  , d = null
                  , u = null
                  , p = null;
                const f = t.getContextAttributes();
                let m = null
                  , g = null;
                const v = []
                  , w = []
                  , y = new De;
                let _ = null;
                const x = new _i;
                x.layers.enable(1),
                x.viewport = new rt;
                const b = new _i;
                b.layers.enable(2),
                b.viewport = new rt;
                const E = [x, b]
                  , S = new os;
                S.layers.enable(1),
                S.layers.enable(2);
                let M = null
                  , T = null;
                function k(e) {
                    const t = w.indexOf(e.inputSource);
                    if (-1 === t)
                        return;
                    const n = v[t];
                    void 0 !== n && (n.update(e.inputSource, e.frame, l || a),
                    n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    }))
                }
                function C() {
                    i.removeEventListener("select", k),
                    i.removeEventListener("selectstart", k),
                    i.removeEventListener("selectend", k),
                    i.removeEventListener("squeeze", k),
                    i.removeEventListener("squeezestart", k),
                    i.removeEventListener("squeezeend", k),
                    i.removeEventListener("end", C),
                    i.removeEventListener("inputsourceschange", A);
                    for (let e = 0; e < v.length; e++) {
                        const t = w[e];
                        null !== t && (w[e] = null,
                        v[e].disconnect(t))
                    }
                    M = null,
                    T = null,
                    e.setRenderTarget(m),
                    u = null,
                    d = null,
                    h = null,
                    i = null,
                    g = null,
                    N.stop(),
                    n.isPresenting = !1,
                    e.setPixelRatio(_),
                    e.setSize(y.width, y.height, !1),
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function A(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t]
                          , i = w.indexOf(n);
                        i >= 0 && (w[i] = null,
                        v[i].disconnect(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let i = w.indexOf(n);
                        if (-1 === i) {
                            for (let e = 0; e < v.length; e++) {
                                if (e >= w.length) {
                                    w.push(n),
                                    i = e;
                                    break
                                }
                                if (null === w[e]) {
                                    w[e] = n,
                                    i = e;
                                    break
                                }
                            }
                            if (-1 === i)
                                break
                        }
                        const r = v[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new hs,
                    v[e] = t),
                    t.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new hs,
                    v[e] = t),
                    t.getGripSpace()
                }
                ,
                this.getHand = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new hs,
                    v[e] = t),
                    t.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(e) {
                    r = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(e) {
                    s = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return l || a
                }
                ,
                this.setReferenceSpace = function(e) {
                    l = e
                }
                ,
                this.getBaseLayer = function() {
                    return null !== d ? d : u
                }
                ,
                this.getBinding = function() {
                    return h
                }
                ,
                this.getFrame = function() {
                    return p
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(c) {
                    if (i = c,
                    null !== i) {
                        if (m = e.getRenderTarget(),
                        i.addEventListener("select", k),
                        i.addEventListener("selectstart", k),
                        i.addEventListener("selectend", k),
                        i.addEventListener("squeeze", k),
                        i.addEventListener("squeezestart", k),
                        i.addEventListener("squeezeend", k),
                        i.addEventListener("end", C),
                        i.addEventListener("inputsourceschange", A),
                        !0 !== f.xrCompatible && await t.makeXRCompatible(),
                        _ = e.getPixelRatio(),
                        e.getSize(y),
                        void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || f.antialias,
                                alpha: !0,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            u = new XRWebGLLayer(i,t,n),
                            i.updateRenderState({
                                baseLayer: u
                            }),
                            e.setPixelRatio(1),
                            e.setSize(u.framebufferWidth, u.framebufferHeight, !1),
                            g = new st(u.framebufferWidth,u.framebufferHeight,{
                                format: X,
                                type: z,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: f.stencil
                            })
                        } else {
                            let n = null
                              , a = null
                              , s = null;
                            f.depth && (s = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                            n = f.stencil ? Y : q,
                            a = f.stencil ? j : H);
                            const o = {
                                colorFormat: t.RGBA8,
                                depthFormat: s,
                                scaleFactor: r
                            };
                            h = new XRWebGLBinding(i,t),
                            d = h.createProjectionLayer(o),
                            i.updateRenderState({
                                layers: [d]
                            }),
                            e.setPixelRatio(1),
                            e.setSize(d.textureWidth, d.textureHeight, !1),
                            g = new st(d.textureWidth,d.textureHeight,{
                                format: X,
                                type: z,
                                depthTexture: new vr(d.textureWidth,d.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: f.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: f.antialias ? 4 : 0
                            });
                            e.properties.get(g).__ignoreDepthValues = d.ignoreDepthValues
                        }
                        g.isXRRenderTarget = !0,
                        this.setFoveation(o),
                        l = null,
                        a = await i.requestReferenceSpace(s),
                        N.setContext(i),
                        N.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (null !== i)
                        return i.environmentBlendMode
                }
                ;
                const P = new ht
                  , R = new ht;
                function L(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === i)
                        return;
                    S.near = b.near = x.near = e.near,
                    S.far = b.far = x.far = e.far,
                    M === S.near && T === S.far || (i.updateRenderState({
                        depthNear: S.near,
                        depthFar: S.far
                    }),
                    M = S.near,
                    T = S.far);
                    const t = e.parent
                      , n = S.cameras;
                    L(S, t);
                    for (let e = 0; e < n.length; e++)
                        L(n[e], t);
                    2 === n.length ? function(e, t, n) {
                        P.setFromMatrixPosition(t.matrixWorld),
                        R.setFromMatrixPosition(n.matrixWorld);
                        const i = P.distanceTo(R)
                          , r = t.projectionMatrix.elements
                          , a = n.projectionMatrix.elements
                          , s = r[14] / (r[10] - 1)
                          , o = r[14] / (r[10] + 1)
                          , l = (r[9] + 1) / r[5]
                          , c = (r[9] - 1) / r[5]
                          , h = (r[8] - 1) / r[0]
                          , d = (a[8] + 1) / a[0]
                          , u = s * h
                          , p = s * d
                          , f = i / (-h + d)
                          , m = f * -h;
                        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                        e.translateX(m),
                        e.translateZ(f),
                        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert();
                        const g = s + f
                          , v = o + f
                          , w = u - m
                          , y = p + (i - m)
                          , _ = l * o / v * g
                          , x = c * o / v * g;
                        e.projectionMatrix.makePerspective(w, y, _, x, g, v),
                        e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                    }(S, x, b) : S.projectionMatrix.copy(x.projectionMatrix),
                    function(e, t, n) {
                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                        e.matrix.invert(),
                        e.matrix.multiply(t.matrixWorld));
                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                        e.updateMatrixWorld(!0),
                        e.projectionMatrix.copy(t.projectionMatrix),
                        e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        e.isPerspectiveCamera && (e.fov = 2 * Te * Math.atan(1 / e.projectionMatrix.elements[5]),
                        e.zoom = 1)
                    }(e, S, t)
                }
                ,
                this.getCamera = function() {
                    return S
                }
                ,
                this.getFoveation = function() {
                    if (null !== d || null !== u)
                        return o
                }
                ,
                this.setFoveation = function(e) {
                    o = e,
                    null !== d && (d.fixedFoveation = e),
                    null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
                }
                ;
                let I = null;
                const N = new Li;
                N.setAnimationLoop((function(t, i) {
                    if (c = i.getViewerPose(l || a),
                    p = i,
                    null !== c) {
                        const t = c.views;
                        null !== u && (e.setRenderTargetFramebuffer(g, u.framebuffer),
                        e.setRenderTarget(g));
                        let n = !1;
                        t.length !== S.cameras.length && (S.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            let a = null;
                            if (null !== u)
                                a = u.getViewport(r);
                            else {
                                const t = h.getViewSubImage(d, r);
                                a = t.viewport,
                                0 === i && (e.setRenderTargetTextures(g, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                                e.setRenderTarget(g))
                            }
                            let s = E[i];
                            void 0 === s && (s = new _i,
                            s.layers.enable(i),
                            s.viewport = new rt,
                            E[i] = s),
                            s.matrix.fromArray(r.transform.matrix),
                            s.matrix.decompose(s.position, s.quaternion, s.scale),
                            s.projectionMatrix.fromArray(r.projectionMatrix),
                            s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),
                            s.viewport.set(a.x, a.y, a.width, a.height),
                            0 === i && (S.matrix.copy(s.matrix),
                            S.matrix.decompose(S.position, S.quaternion, S.scale)),
                            !0 === n && S.cameras.push(s)
                        }
                    }
                    for (let e = 0; e < v.length; e++) {
                        const t = w[e]
                          , n = v[e];
                        null !== t && void 0 !== n && n.update(t, i, l || a)
                    }
                    I && I(t, i),
                    i.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: i
                    }),
                    p = null
                }
                )),
                this.setAnimationLoop = function(e) {
                    I = e
                }
                ,
                this.dispose = function() {}
            }
        }
        function us(e, t) {
            function n(e, t) {
                !0 === e.matrixAutoUpdate && e.updateMatrix(),
                t.value.copy(e.matrix)
            }
            function i(i, r) {
                i.opacity.value = r.opacity,
                r.color && i.diffuse.value.copy(r.color),
                r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
                r.map && (i.map.value = r.map,
                n(r.map, i.mapTransform)),
                r.alphaMap && (i.alphaMap.value = r.alphaMap,
                n(r.alphaMap, i.alphaMapTransform)),
                r.bumpMap && (i.bumpMap.value = r.bumpMap,
                n(r.bumpMap, i.bumpMapTransform),
                i.bumpScale.value = r.bumpScale,
                1 === r.side && (i.bumpScale.value *= -1)),
                r.normalMap && (i.normalMap.value = r.normalMap,
                n(r.normalMap, i.normalMapTransform),
                i.normalScale.value.copy(r.normalScale),
                1 === r.side && i.normalScale.value.negate()),
                r.displacementMap && (i.displacementMap.value = r.displacementMap,
                n(r.displacementMap, i.displacementMapTransform),
                i.displacementScale.value = r.displacementScale,
                i.displacementBias.value = r.displacementBias),
                r.emissiveMap && (i.emissiveMap.value = r.emissiveMap,
                n(r.emissiveMap, i.emissiveMapTransform)),
                r.specularMap && (i.specularMap.value = r.specularMap,
                n(r.specularMap, i.specularMapTransform)),
                r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
                const a = t.get(r).envMap;
                if (a && (i.envMap.value = a,
                i.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1,
                i.reflectivity.value = r.reflectivity,
                i.ior.value = r.ior,
                i.refractionRatio.value = r.refractionRatio),
                r.lightMap) {
                    i.lightMap.value = r.lightMap;
                    const t = !0 === e._useLegacyLights ? Math.PI : 1;
                    i.lightMapIntensity.value = r.lightMapIntensity * t,
                    n(r.lightMap, i.lightMapTransform)
                }
                r.aoMap && (i.aoMap.value = r.aoMap,
                i.aoMapIntensity.value = r.aoMapIntensity,
                n(r.aoMap, i.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(t, n) {
                    n.color.getRGB(t.fogColor.value, gi(e)),
                    n.isFog ? (t.fogNear.value = n.near,
                    t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(e, r, a, s, o) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r),
                    function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, r)) : r.isMeshPhongMaterial ? (i(e, r),
                    function(e, t) {
                        e.specular.value.copy(t.specular),
                        e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, r)) : r.isMeshStandardMaterial ? (i(e, r),
                    function(e, i) {
                        e.metalness.value = i.metalness,
                        i.metalnessMap && (e.metalnessMap.value = i.metalnessMap,
                        n(i.metalnessMap, e.metalnessMapTransform));
                        e.roughness.value = i.roughness,
                        i.roughnessMap && (e.roughnessMap.value = i.roughnessMap,
                        n(i.roughnessMap, e.roughnessMapTransform));
                        const r = t.get(i).envMap;
                        r && (e.envMapIntensity.value = i.envMapIntensity)
                    }(e, r),
                    r.isMeshPhysicalMaterial && function(e, t, i) {
                        e.ior.value = t.ior,
                        t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                        e.sheenRoughness.value = t.sheenRoughness,
                        t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                        n(t.sheenColorMap, e.sheenColorMapTransform)),
                        t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                        n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                        e.clearcoatRoughness.value = t.clearcoatRoughness,
                        t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                        t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                        n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                        t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                        e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                        1 === t.side && e.clearcoatNormalScale.value.negate()));
                        t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                        e.iridescenceIOR.value = t.iridescenceIOR,
                        e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                        e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                        t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                        t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                        n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (e.transmission.value = t.transmission,
                        e.transmissionSamplerMap.value = i.texture,
                        e.transmissionSamplerSize.value.set(i.width, i.height),
                        t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                        n(t.transmissionMap, e.transmissionMapTransform)),
                        e.thickness.value = t.thickness,
                        t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                        n(t.thicknessMap, e.thicknessMapTransform)),
                        e.attenuationDistance.value = t.attenuationDistance,
                        e.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                        t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                        e.specularIntensity.value = t.specularIntensity,
                        e.specularColor.value.copy(t.specularColor),
                        t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                        n(t.specularColorMap, e.specularColorMapTransform));
                        t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                        n(t.specularIntensityMap, e.specularIntensityMapTransform))
                    }(e, r, o)) : r.isMeshMatcapMaterial ? (i(e, r),
                    function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r),
                    function(e, n) {
                        const i = t.get(n).light;
                        e.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                        e.nearDistance.value = i.shadow.camera.near,
                        e.farDistance.value = i.shadow.camera.far
                    }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform))
                    }(e, r),
                    r.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize,
                        e.totalSize.value = t.dashSize + t.gapSize,
                        e.scale.value = t.scale
                    }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.size.value = t.size * i,
                        e.scale.value = .5 * r,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.uvTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r, a, s) : r.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.rotation.value = t.rotation,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
                    e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }
        function ps(e, t, n, i) {
            let r = {}
              , a = {}
              , s = [];
            const o = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
            function l(e, t, n, i) {
                const r = e.value
                  , a = t + "_" + n;
                if (void 0 === i[a])
                    return i[a] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(),
                    !0;
                {
                    const e = i[a];
                    if ("number" == typeof r || "boolean" == typeof r) {
                        if (e !== r)
                            return i[a] = r,
                            !0
                    } else if (!1 === e.equals(r))
                        return e.copy(r),
                        !0
                }
                return !1
            }
            function c(e) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
                t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
                t
            }
            function h(t) {
                const n = t.target;
                n.removeEventListener("dispose", h);
                const i = s.indexOf(n.__bindingPointIndex);
                s.splice(i, 1),
                e.deleteBuffer(r[n.id]),
                delete r[n.id],
                delete a[n.id]
            }
            return {
                bind: function(e, t) {
                    const n = t.program;
                    i.uniformBlockBinding(e, n)
                },
                update: function(n, d) {
                    let u = r[n.id];
                    void 0 === u && (!function(e) {
                        const t = e.uniforms;
                        let n = 0;
                        const i = 16;
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                            for (let e = 0, t = r.length; e < t; e++) {
                                const t = r[e]
                                  , a = Array.isArray(t.value) ? t.value : [t.value];
                                for (let e = 0, r = a.length; e < r; e++) {
                                    const r = c(a[e])
                                      , s = n % i;
                                    0 !== s && i - s < r.boundary && (n += i - s),
                                    t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT),
                                    t.__offset = n,
                                    n += r.storage
                                }
                            }
                        }
                        const r = n % i;
                        r > 0 && (n += i - r);
                        e.__size = n,
                        e.__cache = {}
                    }(n),
                    u = function(t) {
                        const n = function() {
                            for (let e = 0; e < o; e++)
                                if (-1 === s.indexOf(e))
                                    return s.push(e),
                                    e;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        t.__bindingPointIndex = n;
                        const i = e.createBuffer()
                          , r = t.__size
                          , a = t.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, i),
                        e.bufferData(e.UNIFORM_BUFFER, r, a),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, n, i),
                        i
                    }(n),
                    r[n.id] = u,
                    n.addEventListener("dispose", h));
                    const p = d.program;
                    i.updateUBOMapping(n, p);
                    const f = t.render.frame;
                    a[n.id] !== f && (!function(t) {
                        const n = r[t.id]
                          , i = t.uniforms
                          , a = t.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, n);
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                            for (let i = 0, r = n.length; i < r; i++) {
                                const r = n[i];
                                if (!0 === l(r, t, i, a)) {
                                    const t = r.__offset
                                      , n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let a = 0; a < n.length; a++) {
                                        const s = n[a]
                                          , o = c(s);
                                        "number" == typeof s || "boolean" == typeof s ? (r.__data[0] = s,
                                        e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : s.isMatrix3 ? (r.__data[0] = s.elements[0],
                                        r.__data[1] = s.elements[1],
                                        r.__data[2] = s.elements[2],
                                        r.__data[3] = 0,
                                        r.__data[4] = s.elements[3],
                                        r.__data[5] = s.elements[4],
                                        r.__data[6] = s.elements[5],
                                        r.__data[7] = 0,
                                        r.__data[8] = s.elements[6],
                                        r.__data[9] = s.elements[7],
                                        r.__data[10] = s.elements[8],
                                        r.__data[11] = 0) : (s.toArray(r.__data, i),
                                        i += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }(n),
                    a[n.id] = f)
                },
                dispose: function() {
                    for (const t in r)
                        e.deleteBuffer(r[t]);
                    s = [],
                    r = {},
                    a = {}
                }
            }
        }
        class fs {
            constructor(e={}) {
                const {canvas: t=We(), context: n=null, depth: i=!0, stencil: r=!0, alpha: a=!1, antialias: s=!1, premultipliedAlpha: o=!0, preserveDrawingBuffer: l=!1, powerPreference: c="default", failIfMajorPerformanceCaveat: h=!1} = e;
                let d;
                this.isWebGLRenderer = !0,
                d = null !== n ? n.getContextAttributes().alpha : a;
                const u = new Uint32Array(4)
                  , p = new Int32Array(4);
                let f = null
                  , g = null;
                const v = []
                  , w = [];
                this.domElement = t,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = le,
                this._useLegacyLights = !1,
                this.toneMapping = 0,
                this.toneMappingExposure = 1;
                const y = this;
                let _ = !1
                  , x = 0
                  , b = 0
                  , E = null
                  , S = -1
                  , M = null;
                const T = new rt
                  , k = new rt;
                let C = null;
                const A = new An(0);
                let P = 0
                  , R = t.width
                  , L = t.height
                  , I = 1
                  , N = null
                  , U = null;
                const D = new rt(0,0,R,L)
                  , B = new rt(0,0,R,L);
                let W = !1;
                const q = new Ri;
                let Y = !1
                  , Z = !1
                  , K = null;
                const J = new Ft
                  , Q = new De
                  , $ = new ht
                  , ee = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                function te() {
                    return null === E ? I : 1
                }
                let ne, ie, re, ae, se, oe, he, de, ue, pe, fe, me, ge, ve, we, ye, _e, xe, be, Ee, Se, Me, Te, ke, Ce = n;
                function Ae(e, n) {
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i]
                          , a = t.getContext(r, n);
                        if (null !== a)
                            return a
                    }
                    return null
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: i,
                        stencil: r,
                        antialias: s,
                        premultipliedAlpha: o,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: h
                    };
                    if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${m}`),
                    t.addEventListener("webglcontextlost", Ie, !1),
                    t.addEventListener("webglcontextrestored", Ne, !1),
                    t.addEventListener("webglcontextcreationerror", Ue, !1),
                    null === Ce) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === y.isWebGL1Renderer && t.shift(),
                        Ce = Ae(t, e),
                        null === Ce)
                            throw Ae(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" != typeof WebGLRenderingContext && Ce instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
                    void 0 === Ce.getShaderPrecisionFormat && (Ce.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                    )
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message),
                    e
                }
                function Pe() {
                    ne = new cr(Ce),
                    ie = new Hi(Ce,ne,e),
                    ne.init(ie),
                    Me = new ss(Ce,ne,ie),
                    re = new rs(Ce,ne,ie),
                    ae = new ur(Ce),
                    se = new Ga,
                    oe = new as(Ce,ne,re,se,ie,Me,ae),
                    he = new Gi(y),
                    de = new lr(y),
                    ue = new Ii(Ce,ie),
                    Te = new Fi(Ce,ne,ue,ie),
                    pe = new hr(Ce,ue,ae,Te),
                    fe = new gr(Ce,pe,ue,ae),
                    be = new mr(Ce,ie,oe),
                    ye = new Vi(se),
                    me = new Va(y,he,de,ne,ie,Te,ye),
                    ge = new us(y,se),
                    ve = new Ya,
                    we = new es(ne,ie),
                    xe = new zi(y,he,de,re,fe,d,o),
                    _e = new is(y,fe,ie),
                    ke = new ps(Ce,ae,ie,re),
                    Ee = new Wi(Ce,ne,ae,ie),
                    Se = new dr(Ce,ne,ae,ie),
                    ae.programs = me.programs,
                    y.capabilities = ie,
                    y.extensions = ne,
                    y.properties = se,
                    y.renderLists = ve,
                    y.shadowMap = _e,
                    y.state = re,
                    y.info = ae
                }
                Pe();
                const Re = new ds(y,Ce);
                function Ie(e) {
                    e.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    _ = !0
                }
                function Ne() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    _ = !1;
                    const e = ae.autoReset
                      , t = _e.enabled
                      , n = _e.autoUpdate
                      , i = _e.needsUpdate
                      , r = _e.type;
                    Pe(),
                    ae.autoReset = e,
                    _e.enabled = t,
                    _e.autoUpdate = n,
                    _e.needsUpdate = i,
                    _e.type = r
                }
                function Ue(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }
                function Be(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", Be),
                    function(e) {
                        (function(e) {
                            const t = se.get(e).programs;
                            void 0 !== t && (t.forEach((function(e) {
                                me.releaseProgram(e)
                            }
                            )),
                            e.isShaderMaterial && me.releaseShaderCache(e))
                        }
                        )(e),
                        se.remove(e)
                    }(t)
                }
                function Oe(e, t, n) {
                    !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1,
                    e.needsUpdate = !0,
                    Ye(e, t, n),
                    e.side = 0,
                    e.needsUpdate = !0,
                    Ye(e, t, n),
                    e.side = 2) : Ye(e, t, n)
                }
                this.xr = Re,
                this.getContext = function() {
                    return Ce
                }
                ,
                this.getContextAttributes = function() {
                    return Ce.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const e = ne.get("WEBGL_lose_context");
                    e && e.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const e = ne.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return I
                }
                ,
                this.setPixelRatio = function(e) {
                    void 0 !== e && (I = e,
                    this.setSize(R, L, !1))
                }
                ,
                this.getSize = function(e) {
                    return e.set(R, L)
                }
                ,
                this.setSize = function(e, n, i=!0) {
                    Re.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e,
                    L = n,
                    t.width = Math.floor(e * I),
                    t.height = Math.floor(n * I),
                    !0 === i && (t.style.width = e + "px",
                    t.style.height = n + "px"),
                    this.setViewport(0, 0, e, n))
                }
                ,
                this.getDrawingBufferSize = function(e) {
                    return e.set(R * I, L * I).floor()
                }
                ,
                this.setDrawingBufferSize = function(e, n, i) {
                    R = e,
                    L = n,
                    I = i,
                    t.width = Math.floor(e * i),
                    t.height = Math.floor(n * i),
                    this.setViewport(0, 0, e, n)
                }
                ,
                this.getCurrentViewport = function(e) {
                    return e.copy(T)
                }
                ,
                this.getViewport = function(e) {
                    return e.copy(D)
                }
                ,
                this.setViewport = function(e, t, n, i) {
                    e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, i),
                    re.viewport(T.copy(D).multiplyScalar(I).floor())
                }
                ,
                this.getScissor = function(e) {
                    return e.copy(B)
                }
                ,
                this.setScissor = function(e, t, n, i) {
                    e.isVector4 ? B.set(e.x, e.y, e.z, e.w) : B.set(e, t, n, i),
                    re.scissor(k.copy(B).multiplyScalar(I).floor())
                }
                ,
                this.getScissorTest = function() {
                    return W
                }
                ,
                this.setScissorTest = function(e) {
                    re.setScissorTest(W = e)
                }
                ,
                this.setOpaqueSort = function(e) {
                    N = e
                }
                ,
                this.setTransparentSort = function(e) {
                    U = e
                }
                ,
                this.getClearColor = function(e) {
                    return e.copy(xe.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    xe.setClearColor.apply(xe, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return xe.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    xe.setClearAlpha.apply(xe, arguments)
                }
                ,
                this.clear = function(e=!0, t=!0, n=!0) {
                    let i = 0;
                    if (e) {
                        let e = !1;
                        if (null !== E) {
                            const t = E.texture.format;
                            e = 1033 === t || 1031 === t || 1029 === t
                        }
                        if (e) {
                            const e = E.texture.type
                              , t = e === z || e === H || e === F || e === j || 1017 === e || 1018 === e
                              , n = xe.getClearColor()
                              , i = xe.getClearAlpha()
                              , r = n.r
                              , a = n.g
                              , s = n.b;
                            t ? (u[0] = r,
                            u[1] = a,
                            u[2] = s,
                            u[3] = i,
                            Ce.clearBufferuiv(Ce.COLOR, 0, u)) : (p[0] = r,
                            p[1] = a,
                            p[2] = s,
                            p[3] = i,
                            Ce.clearBufferiv(Ce.COLOR, 0, p))
                        } else
                            i |= Ce.COLOR_BUFFER_BIT
                    }
                    t && (i |= Ce.DEPTH_BUFFER_BIT),
                    n && (i |= Ce.STENCIL_BUFFER_BIT,
                    this.state.buffers.stencil.setMask(4294967295)),
                    Ce.clear(i)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    t.removeEventListener("webglcontextlost", Ie, !1),
                    t.removeEventListener("webglcontextrestored", Ne, !1),
                    t.removeEventListener("webglcontextcreationerror", Ue, !1),
                    ve.dispose(),
                    we.dispose(),
                    se.dispose(),
                    he.dispose(),
                    de.dispose(),
                    fe.dispose(),
                    Te.dispose(),
                    ke.dispose(),
                    me.dispose(),
                    Re.dispose(),
                    Re.removeEventListener("sessionstart", Fe),
                    Re.removeEventListener("sessionend", He),
                    K && (K.dispose(),
                    K = null),
                    Ve.stop()
                }
                ,
                this.renderBufferDirect = function(e, t, n, i, r, a) {
                    null === t && (t = ee);
                    const s = r.isMesh && r.matrixWorld.determinant() < 0
                      , o = function(e, t, n, i, r) {
                        !0 !== t.isScene && (t = ee);
                        oe.resetTextureUnits();
                        const a = t.fog
                          , s = i.isMeshStandardMaterial ? t.environment : null
                          , o = null === E ? y.outputColorSpace : !0 === E.isXRRenderTarget ? E.texture.colorSpace : ce
                          , l = (i.isMeshStandardMaterial ? de : he).get(i.envMap || s)
                          , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                          , h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0)
                          , d = !!n.morphAttributes.position
                          , u = !!n.morphAttributes.normal
                          , p = !!n.morphAttributes.color;
                        let f = 0;
                        i.toneMapped && (null !== E && !0 !== E.isXRRenderTarget || (f = y.toneMapping));
                        const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                          , v = void 0 !== m ? m.length : 0
                          , w = se.get(i)
                          , _ = g.state.lights;
                        if (!0 === Y && (!0 === Z || e !== M)) {
                            const t = e === M && i.id === S;
                            ye.setState(i, e, t)
                        }
                        let x = !1;
                        i.version === w.__version ? w.needsLights && w.lightsStateVersion !== _.state.version || w.outputColorSpace !== o || r.isBatchedMesh && !1 === w.batching ? x = !0 : r.isBatchedMesh || !0 !== w.batching ? r.isInstancedMesh && !1 === w.instancing ? x = !0 : r.isInstancedMesh || !0 !== w.instancing ? r.isSkinnedMesh && !1 === w.skinning ? x = !0 : r.isSkinnedMesh || !0 !== w.skinning ? r.isInstancedMesh && !0 === w.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === w.instancingColor && null !== r.instanceColor || w.envMap !== l || !0 === i.fog && w.fog !== a ? x = !0 : void 0 === w.numClippingPlanes || w.numClippingPlanes === ye.numPlanes && w.numIntersection === ye.numIntersection ? (w.vertexAlphas !== c || w.vertexTangents !== h || w.morphTargets !== d || w.morphNormals !== u || w.morphColors !== p || w.toneMapping !== f || !0 === ie.isWebGL2 && w.morphTargetsCount !== v) && (x = !0) : x = !0 : x = !0 : x = !0 : x = !0 : (x = !0,
                        w.__version = i.version);
                        let b = w.currentProgram;
                        !0 === x && (b = Ye(i, t, r));
                        let T = !1
                          , k = !1
                          , C = !1;
                        const A = b.getUniforms()
                          , P = w.uniforms;
                        re.useProgram(b.program) && (T = !0,
                        k = !0,
                        C = !0);
                        i.id !== S && (S = i.id,
                        k = !0);
                        if (T || M !== e) {
                            A.setValue(Ce, "projectionMatrix", e.projectionMatrix),
                            A.setValue(Ce, "viewMatrix", e.matrixWorldInverse);
                            const t = A.map.cameraPosition;
                            void 0 !== t && t.setValue(Ce, $.setFromMatrixPosition(e.matrixWorld)),
                            ie.logarithmicDepthBuffer && A.setValue(Ce, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && A.setValue(Ce, "isOrthographic", !0 === e.isOrthographicCamera),
                            M !== e && (M = e,
                            k = !0,
                            C = !0)
                        }
                        if (r.isSkinnedMesh) {
                            A.setOptional(Ce, r, "bindMatrix"),
                            A.setOptional(Ce, r, "bindMatrixInverse");
                            const e = r.skeleton;
                            e && (ie.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(),
                            A.setValue(Ce, "boneTexture", e.boneTexture, oe)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        r.isBatchedMesh && (A.setOptional(Ce, r, "batchingTexture"),
                        A.setValue(Ce, "batchingTexture", r._matricesTexture, oe));
                        const R = n.morphAttributes;
                        (void 0 !== R.position || void 0 !== R.normal || void 0 !== R.color && !0 === ie.isWebGL2) && be.update(r, n, b);
                        (k || w.receiveShadow !== r.receiveShadow) && (w.receiveShadow = r.receiveShadow,
                        A.setValue(Ce, "receiveShadow", r.receiveShadow));
                        i.isMeshGouraudMaterial && null !== i.envMap && (P.envMap.value = l,
                        P.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                        k && (A.setValue(Ce, "toneMappingExposure", y.toneMappingExposure),
                        w.needsLights && (U = C,
                        (N = P).ambientLightColor.needsUpdate = U,
                        N.lightProbe.needsUpdate = U,
                        N.directionalLights.needsUpdate = U,
                        N.directionalLightShadows.needsUpdate = U,
                        N.pointLights.needsUpdate = U,
                        N.pointLightShadows.needsUpdate = U,
                        N.spotLights.needsUpdate = U,
                        N.spotLightShadows.needsUpdate = U,
                        N.rectAreaLights.needsUpdate = U,
                        N.hemisphereLights.needsUpdate = U),
                        a && !0 === i.fog && ge.refreshFogUniforms(P, a),
                        ge.refreshMaterialUniforms(P, i, I, L, K),
                        ba.upload(Ce, Ze(w), P, oe));
                        var N, U;
                        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ba.upload(Ce, Ze(w), P, oe),
                        i.uniformsNeedUpdate = !1);
                        i.isSpriteMaterial && A.setValue(Ce, "center", r.center);
                        if (A.setValue(Ce, "modelViewMatrix", r.modelViewMatrix),
                        A.setValue(Ce, "normalMatrix", r.normalMatrix),
                        A.setValue(Ce, "modelMatrix", r.matrixWorld),
                        i.isShaderMaterial || i.isRawShaderMaterial) {
                            const e = i.uniformsGroups;
                            for (let t = 0, n = e.length; t < n; t++)
                                if (ie.isWebGL2) {
                                    const n = e[t];
                                    ke.update(n, b),
                                    ke.bind(n, b)
                                } else
                                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return b
                    }(e, t, n, i, r);
                    re.setMaterial(i, s);
                    let l = n.index
                      , c = 1;
                    if (!0 === i.wireframe) {
                        if (l = pe.getWireframeAttribute(n),
                        void 0 === l)
                            return;
                        c = 2
                    }
                    const h = n.drawRange
                      , d = n.attributes.position;
                    let u = h.start * c
                      , p = (h.start + h.count) * c;
                    null !== a && (u = Math.max(u, a.start * c),
                    p = Math.min(p, (a.start + a.count) * c)),
                    null !== l ? (u = Math.max(u, 0),
                    p = Math.min(p, l.count)) : null != d && (u = Math.max(u, 0),
                    p = Math.min(p, d.count));
                    const f = p - u;
                    if (f < 0 || f === 1 / 0)
                        return;
                    let m;
                    Te.setup(r, i, o, n, l);
                    let v = Ee;
                    if (null !== l && (m = ue.get(l),
                    v = Se,
                    v.setIndex(m)),
                    r.isMesh)
                        !0 === i.wireframe ? (re.setLineWidth(i.wireframeLinewidth * te()),
                        v.setMode(Ce.LINES)) : v.setMode(Ce.TRIANGLES);
                    else if (r.isLine) {
                        let e = i.linewidth;
                        void 0 === e && (e = 1),
                        re.setLineWidth(e * te()),
                        r.isLineSegments ? v.setMode(Ce.LINES) : r.isLineLoop ? v.setMode(Ce.LINE_LOOP) : v.setMode(Ce.LINE_STRIP)
                    } else
                        r.isPoints ? v.setMode(Ce.POINTS) : r.isSprite && v.setMode(Ce.TRIANGLES);
                    if (r.isBatchedMesh)
                        v.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                    else if (r.isInstancedMesh)
                        v.renderInstances(u, f, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                          , t = Math.min(n.instanceCount, e);
                        v.renderInstances(u, f, t)
                    } else
                        v.render(u, f)
                }
                ,
                this.compile = function(e, t, n=null) {
                    null === n && (n = e),
                    g = we.get(n),
                    g.init(),
                    w.push(g),
                    n.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (g.pushLight(e),
                        e.castShadow && g.pushShadow(e))
                    }
                    )),
                    e !== n && e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (g.pushLight(e),
                        e.castShadow && g.pushShadow(e))
                    }
                    )),
                    g.setupLights(y._useLegacyLights);
                    const i = new Set;
                    return e.traverse((function(e) {
                        const t = e.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let r = 0; r < t.length; r++) {
                                    const a = t[r];
                                    Oe(a, n, e),
                                    i.add(a)
                                }
                            else
                                Oe(t, n, e),
                                i.add(t)
                    }
                    )),
                    w.pop(),
                    g = null,
                    i
                }
                ,
                this.compileAsync = function(e, t, n=null) {
                    const i = this.compile(e, t, n);
                    return new Promise((t=>{
                        function n() {
                            i.forEach((function(e) {
                                se.get(e).currentProgram.isReady() && i.delete(e)
                            }
                            )),
                            0 !== i.size ? setTimeout(n, 10) : t(e)
                        }
                        null !== ne.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }
                    ))
                }
                ;
                let ze = null;
                function Fe() {
                    Ve.stop()
                }
                function He() {
                    Ve.start()
                }
                const Ve = new Li;
                function Ge(e, t, n, i) {
                    if (!1 === e.visible)
                        return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup)
                            n = e.renderOrder;
                        else if (e.isLOD)
                            !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight)
                            g.pushLight(e),
                            e.castShadow && g.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || q.intersectsSprite(e)) {
                                i && $.setFromMatrixPosition(e.matrixWorld).applyMatrix4(J);
                                const t = fe.update(e)
                                  , r = e.material;
                                r.visible && f.push(e, t, r, n, $.z, null)
                            }
                        } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || q.intersectsObject(e))) {
                            const t = fe.update(e)
                              , r = e.material;
                            if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                            $.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                            $.copy(t.boundingSphere.center)),
                            $.applyMatrix4(e.matrixWorld).applyMatrix4(J)),
                            Array.isArray(r)) {
                                const i = t.groups;
                                for (let a = 0, s = i.length; a < s; a++) {
                                    const s = i[a]
                                      , o = r[s.materialIndex];
                                    o && o.visible && f.push(e, t, o, n, $.z, s)
                                }
                            } else
                                r.visible && f.push(e, t, r, n, $.z, null)
                        }
                    const r = e.children;
                    for (let e = 0, a = r.length; e < a; e++)
                        Ge(r[e], t, n, i)
                }
                function je(e, t, n, i) {
                    const r = e.opaque
                      , a = e.transmissive
                      , s = e.transparent;
                    g.setupLightsView(n),
                    !0 === Y && ye.setGlobalState(y.clippingPlanes, n),
                    a.length > 0 && function(e, t, n, i) {
                        const r = !0 === n.isScene ? n.overrideMaterial : null;
                        if (null !== r)
                            return;
                        const a = ie.isWebGL2;
                        null === K && (K = new st(1,1,{
                            generateMipmaps: !0,
                            type: ne.has("EXT_color_buffer_half_float") ? G : z,
                            minFilter: O,
                            samples: a ? 4 : 0
                        }));
                        y.getDrawingBufferSize(Q),
                        a ? K.setSize(Q.x, Q.y) : K.setSize(Le(Q.x), Le(Q.y));
                        const s = y.getRenderTarget();
                        y.setRenderTarget(K),
                        y.getClearColor(A),
                        P = y.getClearAlpha(),
                        P < 1 && y.setClearColor(16777215, .5);
                        y.clear();
                        const o = y.toneMapping;
                        y.toneMapping = 0,
                        Xe(e, n, i),
                        oe.updateMultisampleRenderTarget(K),
                        oe.updateRenderTargetMipmap(K);
                        let l = !1;
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = t[e]
                              , a = r.object
                              , s = r.geometry
                              , o = r.material
                              , c = r.group;
                            if (2 === o.side && a.layers.test(i.layers)) {
                                const e = o.side;
                                o.side = 1,
                                o.needsUpdate = !0,
                                qe(a, n, i, s, o, c),
                                o.side = e,
                                o.needsUpdate = !0,
                                l = !0
                            }
                        }
                        !0 === l && (oe.updateMultisampleRenderTarget(K),
                        oe.updateRenderTargetMipmap(K));
                        y.setRenderTarget(s),
                        y.setClearColor(A, P),
                        y.toneMapping = o
                    }(r, a, t, n),
                    i && re.viewport(T.copy(i)),
                    r.length > 0 && Xe(r, t, n),
                    a.length > 0 && Xe(a, t, n),
                    s.length > 0 && Xe(s, t, n),
                    re.buffers.depth.setTest(!0),
                    re.buffers.depth.setMask(!0),
                    re.buffers.color.setMask(!0),
                    re.setPolygonOffset(!1)
                }
                function Xe(e, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, a = e.length; r < a; r++) {
                        const a = e[r]
                          , s = a.object
                          , o = a.geometry
                          , l = null === i ? a.material : i
                          , c = a.group;
                        s.layers.test(n.layers) && qe(s, t, n, o, l, c)
                    }
                }
                function qe(e, t, n, i, r, a) {
                    e.onBeforeRender(y, t, n, i, r, a),
                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                    e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                    r.onBeforeRender(y, t, n, i, e, a),
                    !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1,
                    r.needsUpdate = !0,
                    y.renderBufferDirect(n, t, i, r, e, a),
                    r.side = 0,
                    r.needsUpdate = !0,
                    y.renderBufferDirect(n, t, i, r, e, a),
                    r.side = 2) : y.renderBufferDirect(n, t, i, r, e, a),
                    e.onAfterRender(y, t, n, i, r, a)
                }
                function Ye(e, t, n) {
                    !0 !== t.isScene && (t = ee);
                    const i = se.get(e)
                      , r = g.state.lights
                      , a = g.state.shadowsArray
                      , s = r.state.version
                      , o = me.getParameters(e, r.state, a, t, n)
                      , l = me.getProgramCacheKey(o);
                    let c = i.programs;
                    i.environment = e.isMeshStandardMaterial ? t.environment : null,
                    i.fog = t.fog,
                    i.envMap = (e.isMeshStandardMaterial ? de : he).get(e.envMap || i.environment),
                    void 0 === c && (e.addEventListener("dispose", Be),
                    c = new Map,
                    i.programs = c);
                    let h = c.get(l);
                    if (void 0 !== h) {
                        if (i.currentProgram === h && i.lightsStateVersion === s)
                            return Ke(e, o),
                            h
                    } else
                        o.uniforms = me.getUniforms(e),
                        e.onBuild(n, o, y),
                        e.onBeforeCompile(o, y),
                        h = me.acquireProgram(o, l),
                        c.set(l, h),
                        i.uniforms = o.uniforms;
                    const d = i.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = ye.uniform),
                    Ke(e, o),
                    i.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e),
                    i.lightsStateVersion = s,
                    i.needsLights && (d.ambientLightColor.value = r.state.ambient,
                    d.lightProbe.value = r.state.probe,
                    d.directionalLights.value = r.state.directional,
                    d.directionalLightShadows.value = r.state.directionalShadow,
                    d.spotLights.value = r.state.spot,
                    d.spotLightShadows.value = r.state.spotShadow,
                    d.rectAreaLights.value = r.state.rectArea,
                    d.ltc_1.value = r.state.rectAreaLTC1,
                    d.ltc_2.value = r.state.rectAreaLTC2,
                    d.pointLights.value = r.state.point,
                    d.pointLightShadows.value = r.state.pointShadow,
                    d.hemisphereLights.value = r.state.hemi,
                    d.directionalShadowMap.value = r.state.directionalShadowMap,
                    d.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                    d.spotShadowMap.value = r.state.spotShadowMap,
                    d.spotLightMatrix.value = r.state.spotLightMatrix,
                    d.spotLightMap.value = r.state.spotLightMap,
                    d.pointShadowMap.value = r.state.pointShadowMap,
                    d.pointShadowMatrix.value = r.state.pointShadowMatrix),
                    i.currentProgram = h,
                    i.uniformsList = null,
                    h
                }
                function Ze(e) {
                    if (null === e.uniformsList) {
                        const t = e.currentProgram.getUniforms();
                        e.uniformsList = ba.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }
                function Ke(e, t) {
                    const n = se.get(e);
                    n.outputColorSpace = t.outputColorSpace,
                    n.batching = t.batching,
                    n.instancing = t.instancing,
                    n.instancingColor = t.instancingColor,
                    n.skinning = t.skinning,
                    n.morphTargets = t.morphTargets,
                    n.morphNormals = t.morphNormals,
                    n.morphColors = t.morphColors,
                    n.morphTargetsCount = t.morphTargetsCount,
                    n.numClippingPlanes = t.numClippingPlanes,
                    n.numIntersection = t.numClipIntersection,
                    n.vertexAlphas = t.vertexAlphas,
                    n.vertexTangents = t.vertexTangents,
                    n.toneMapping = t.toneMapping
                }
                Ve.setAnimationLoop((function(e) {
                    ze && ze(e)
                }
                )),
                "undefined" != typeof self && Ve.setContext(self),
                this.setAnimationLoop = function(e) {
                    ze = e,
                    Re.setAnimationLoop(e),
                    null === e ? Ve.stop() : Ve.start()
                }
                ,
                Re.addEventListener("sessionstart", Fe),
                Re.addEventListener("sessionend", He),
                this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === _)
                        return;
                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    !0 === Re.enabled && !0 === Re.isPresenting && (!0 === Re.cameraAutoUpdate && Re.updateCamera(t),
                    t = Re.getCamera()),
                    !0 === e.isScene && e.onBeforeRender(y, e, t, E),
                    g = we.get(e, w.length),
                    g.init(),
                    w.push(g),
                    J.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    q.setFromProjectionMatrix(J),
                    Z = this.localClippingEnabled,
                    Y = ye.init(this.clippingPlanes, Z),
                    f = ve.get(e, v.length),
                    f.init(),
                    v.push(f),
                    Ge(e, t, 0, y.sortObjects),
                    f.finish(),
                    !0 === y.sortObjects && f.sort(N, U),
                    this.info.render.frame++,
                    !0 === Y && ye.beginShadows();
                    const n = g.state.shadowsArray;
                    if (_e.render(n, e, t),
                    !0 === Y && ye.endShadows(),
                    !0 === this.info.autoReset && this.info.reset(),
                    xe.render(f, e),
                    g.setupLights(y._useLegacyLights),
                    t.isArrayCamera) {
                        const n = t.cameras;
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            je(f, e, i, i.viewport)
                        }
                    } else
                        je(f, e, t);
                    null !== E && (oe.updateMultisampleRenderTarget(E),
                    oe.updateRenderTargetMipmap(E)),
                    !0 === e.isScene && e.onAfterRender(y, e, t),
                    Te.resetDefaultState(),
                    S = -1,
                    M = null,
                    w.pop(),
                    g = w.length > 0 ? w[w.length - 1] : null,
                    v.pop(),
                    f = v.length > 0 ? v[v.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return x
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return b
                }
                ,
                this.getRenderTarget = function() {
                    return E
                }
                ,
                this.setRenderTargetTextures = function(e, t, n) {
                    se.get(e.texture).__webglTexture = t,
                    se.get(e.depthTexture).__webglTexture = n;
                    const i = se.get(e);
                    i.__hasExternalTextures = !0,
                    i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n,
                    i.__autoAllocateDepthBuffer || !0 === ne.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    i.__useRenderToTexture = !1))
                }
                ,
                this.setRenderTargetFramebuffer = function(e, t) {
                    const n = se.get(e);
                    n.__webglFramebuffer = t,
                    n.__useDefaultFramebuffer = void 0 === t
                }
                ,
                this.setRenderTarget = function(e, t=0, n=0) {
                    E = e,
                    x = t,
                    b = n;
                    let i = !0
                      , r = null
                      , a = !1
                      , s = !1;
                    if (e) {
                        const o = se.get(e);
                        void 0 !== o.__useDefaultFramebuffer ? (re.bindFramebuffer(Ce.FRAMEBUFFER, null),
                        i = !1) : void 0 === o.__webglFramebuffer ? oe.setupRenderTarget(e) : o.__hasExternalTextures && oe.rebindTextures(e, se.get(e.texture).__webglTexture, se.get(e.depthTexture).__webglTexture);
                        const l = e.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0);
                        const c = se.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t],
                        a = !0) : r = ie.isWebGL2 && e.samples > 0 && !1 === oe.useMultisampledRTT(e) ? se.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                        T.copy(e.viewport),
                        k.copy(e.scissor),
                        C = e.scissorTest
                    } else
                        T.copy(D).multiplyScalar(I).floor(),
                        k.copy(B).multiplyScalar(I).floor(),
                        C = W;
                    if (re.bindFramebuffer(Ce.FRAMEBUFFER, r) && ie.drawBuffers && i && re.drawBuffers(e, r),
                    re.viewport(T),
                    re.scissor(k),
                    re.setScissorTest(C),
                    a) {
                        const i = se.get(e.texture);
                        Ce.framebufferTexture2D(Ce.FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, Ce.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                    } else if (s) {
                        const i = se.get(e.texture)
                          , r = t || 0;
                        Ce.framebufferTextureLayer(Ce.FRAMEBUFFER, Ce.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    S = -1
                }
                ,
                this.readRenderTargetPixels = function(e, t, n, i, r, a, s) {
                    if (!e || !e.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = se.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]),
                    o) {
                        re.bindFramebuffer(Ce.FRAMEBUFFER, o);
                        try {
                            const s = e.texture
                              , o = s.format
                              , l = s.type;
                            if (o !== X && Me.convert(o) !== Ce.getParameter(Ce.IMPLEMENTATION_COLOR_READ_FORMAT))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === G && (ne.has("EXT_color_buffer_half_float") || ie.isWebGL2 && ne.has("EXT_color_buffer_float"));
                            if (!(l === z || Me.convert(l) === Ce.getParameter(Ce.IMPLEMENTATION_COLOR_READ_TYPE) || l === V && (ie.isWebGL2 || ne.has("OES_texture_float") || ne.has("WEBGL_color_buffer_float")) || c))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Ce.readPixels(t, n, i, r, Me.convert(o), Me.convert(l), a)
                        } finally {
                            const e = null !== E ? se.get(E).__webglFramebuffer : null;
                            re.bindFramebuffer(Ce.FRAMEBUFFER, e)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(e, t, n=0) {
                    const i = Math.pow(2, -n)
                      , r = Math.floor(t.image.width * i)
                      , a = Math.floor(t.image.height * i);
                    oe.setTexture2D(t, 0),
                    Ce.copyTexSubImage2D(Ce.TEXTURE_2D, n, 0, 0, e.x, e.y, r, a),
                    re.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(e, t, n, i=0) {
                    const r = t.image.width
                      , a = t.image.height
                      , s = Me.convert(n.format)
                      , o = Me.convert(n.type);
                    oe.setTexture2D(n, 0),
                    Ce.pixelStorei(Ce.UNPACK_FLIP_Y_WEBGL, n.flipY),
                    Ce.pixelStorei(Ce.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                    Ce.pixelStorei(Ce.UNPACK_ALIGNMENT, n.unpackAlignment),
                    t.isDataTexture ? Ce.texSubImage2D(Ce.TEXTURE_2D, i, e.x, e.y, r, a, s, o, t.image.data) : t.isCompressedTexture ? Ce.compressedTexSubImage2D(Ce.TEXTURE_2D, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data) : Ce.texSubImage2D(Ce.TEXTURE_2D, i, e.x, e.y, s, o, t.image),
                    0 === i && n.generateMipmaps && Ce.generateMipmap(Ce.TEXTURE_2D),
                    re.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(e, t, n, i, r=0) {
                    if (y.isWebGL1Renderer)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const a = e.max.x - e.min.x + 1
                      , s = e.max.y - e.min.y + 1
                      , o = e.max.z - e.min.z + 1
                      , l = Me.convert(i.format)
                      , c = Me.convert(i.type);
                    let h;
                    if (i.isData3DTexture)
                        oe.setTexture3D(i, 0),
                        h = Ce.TEXTURE_3D;
                    else {
                        if (!i.isDataArrayTexture && !i.isCompressedArrayTexture)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        oe.setTexture2DArray(i, 0),
                        h = Ce.TEXTURE_2D_ARRAY
                    }
                    Ce.pixelStorei(Ce.UNPACK_FLIP_Y_WEBGL, i.flipY),
                    Ce.pixelStorei(Ce.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                    Ce.pixelStorei(Ce.UNPACK_ALIGNMENT, i.unpackAlignment);
                    const d = Ce.getParameter(Ce.UNPACK_ROW_LENGTH)
                      , u = Ce.getParameter(Ce.UNPACK_IMAGE_HEIGHT)
                      , p = Ce.getParameter(Ce.UNPACK_SKIP_PIXELS)
                      , f = Ce.getParameter(Ce.UNPACK_SKIP_ROWS)
                      , m = Ce.getParameter(Ce.UNPACK_SKIP_IMAGES)
                      , g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
                    Ce.pixelStorei(Ce.UNPACK_ROW_LENGTH, g.width),
                    Ce.pixelStorei(Ce.UNPACK_IMAGE_HEIGHT, g.height),
                    Ce.pixelStorei(Ce.UNPACK_SKIP_PIXELS, e.min.x),
                    Ce.pixelStorei(Ce.UNPACK_SKIP_ROWS, e.min.y),
                    Ce.pixelStorei(Ce.UNPACK_SKIP_IMAGES, e.min.z),
                    n.isDataTexture || n.isData3DTexture ? Ce.texSubImage3D(h, r, t.x, t.y, t.z, a, s, o, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                    Ce.compressedTexSubImage3D(h, r, t.x, t.y, t.z, a, s, o, l, g.data)) : Ce.texSubImage3D(h, r, t.x, t.y, t.z, a, s, o, l, c, g),
                    Ce.pixelStorei(Ce.UNPACK_ROW_LENGTH, d),
                    Ce.pixelStorei(Ce.UNPACK_IMAGE_HEIGHT, u),
                    Ce.pixelStorei(Ce.UNPACK_SKIP_PIXELS, p),
                    Ce.pixelStorei(Ce.UNPACK_SKIP_ROWS, f),
                    Ce.pixelStorei(Ce.UNPACK_SKIP_IMAGES, m),
                    0 === r && i.generateMipmaps && Ce.generateMipmap(h),
                    re.unbindTexture()
                }
                ,
                this.initTexture = function(e) {
                    e.isCubeTexture ? oe.setTextureCube(e, 0) : e.isData3DTexture ? oe.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? oe.setTexture2DArray(e, 0) : oe.setTexture2D(e, 0),
                    re.unbindTexture()
                }
                ,
                this.resetState = function() {
                    x = 0,
                    b = 0,
                    E = null,
                    re.reset(),
                    Te.reset()
                }
                ,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return _e
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e;
                const t = this.getContext();
                t.drawingBufferColorSpace = e === he ? "display-p3" : "srgb",
                t.unpackColorSpace = Ye.workingColorSpace === de ? "display-p3" : "srgb"
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace === le ? se : 3e3
            }
            set outputEncoding(e) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace = e === se ? le : ce
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights
            }
            set useLegacyLights(e) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights = e
            }
        }
        (class extends fs {
        }
        ).prototype.isWebGL1Renderer = !0;
        class ms {
            constructor(e, t=25e-5) {
                this.isFogExp2 = !0,
                this.name = "",
                this.color = new An(e),
                this.density = t
            }
            clone() {
                return new ms(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    name: this.name,
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        class gs extends un {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.overrideMaterial = null,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t),
                null !== e.background && (this.background = e.background.clone()),
                null !== e.environment && (this.environment = e.environment.clone()),
                null !== e.fog && (this.fog = e.fog.clone()),
                this.backgroundBlurriness = e.backgroundBlurriness,
                this.backgroundIntensity = e.backgroundIntensity,
                null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                t
            }
        }
        class vs {
            constructor(e, t) {
                this.isInterleavedBuffer = !0,
                this.array = e,
                this.stride = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.usage = ve,
                this._updateRange = {
                    offset: 0,
                    count: -1
                },
                this.updateRanges = [],
                this.version = 0,
                this.uuid = ke()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
                this._updateRange
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array),
                this.count = e.count,
                this.stride = e.stride,
                this.usage = e.usage,
                this
            }
            copyAt(e, t, n) {
                e *= this.stride,
                n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                return this
            }
            set(e, t=0) {
                return this.array.set(e, t),
                this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ke()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(t,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ke()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const ws = new ht;
        class ys {
            constructor(e, t, n, i=!1) {
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = e,
                this.itemSize = t,
                this.offset = n,
                this.normalized = i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++)
                    ws.fromBufferAttribute(this, t),
                    ws.applyMatrix4(e),
                    this.setXYZ(t, ws.x, ws.y, ws.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    ws.fromBufferAttribute(this, t),
                    ws.applyNormalMatrix(e),
                    this.setXYZ(t, ws.x, ws.y, ws.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    ws.fromBufferAttribute(this, t),
                    ws.transformDirection(e),
                    this.setXYZ(t, ws.x, ws.y, ws.z);
                return this
            }
            setX(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.data.array[e * this.data.stride + this.offset] = t,
                this
            }
            setY(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 1] = t,
                this
            }
            setZ(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 2] = t,
                this
            }
            setW(e, t) {
                return this.normalized && (t = Ne(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 3] = t,
                this
            }
            getX(e) {
                let t = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            getY(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            getZ(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            getW(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (t = Ie(t, this.array)),
                t
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = Ne(t, this.array),
                n = Ne(n, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, i) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = Ne(t, this.array),
                n = Ne(n, this.array),
                i = Ne(i, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = i,
                this
            }
            setXYZW(e, t, n, i, r) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = Ne(t, this.array),
                n = Ne(n, this.array),
                i = Ne(i, this.array),
                r = Ne(r, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = i,
                this.data.array[e + 3] = r,
                this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return new Dn(new this.array.constructor(e),this.itemSize,this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                new ys(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const _s = new ht
          , xs = new rt
          , bs = new rt
          , Es = new ht
          , Ss = new Ft
          , Ms = new ht
          , Ts = new Rt
          , ks = new Ft
          , Cs = new zt;
        class As extends di {
            constructor(e, t) {
                super(e, t),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = S,
                this.bindMatrix = new Ft,
                this.bindMatrixInverse = new Ft,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const e = this.geometry;
                null === this.boundingBox && (this.boundingBox = new pt),
                this.boundingBox.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++)
                    this.getVertexPosition(e, Ms),
                    this.boundingBox.expandByPoint(Ms)
            }
            computeBoundingSphere() {
                const e = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Rt),
                this.boundingSphere.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++)
                    this.getVertexPosition(e, Ms),
                    this.boundingSphere.expandByPoint(Ms)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.bindMode = e.bindMode,
                this.bindMatrix.copy(e.bindMatrix),
                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                this.skeleton = e.skeleton,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            raycast(e, t) {
                const n = this.material
                  , i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                Ts.copy(this.boundingSphere),
                Ts.applyMatrix4(i),
                !1 !== e.ray.intersectsSphere(Ts) && (ks.copy(i).invert(),
                Cs.copy(e.ray).applyMatrix4(ks),
                null !== this.boundingBox && !1 === Cs.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Cs)))
            }
            getVertexPosition(e, t) {
                return super.getVertexPosition(e, t),
                this.applyBoneTransform(e, t),
                t
            }
            bind(e, t) {
                this.skeleton = e,
                void 0 === t && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                t = this.matrixWorld),
                this.bindMatrix.copy(t),
                this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new rt
                  , t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    e.fromBufferAttribute(t, n);
                    const i = 1 / e.manhattanLength();
                    i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                    t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.bindMode === S ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(e, t) {
                const n = this.skeleton
                  , i = this.geometry;
                xs.fromBufferAttribute(i.attributes.skinIndex, e),
                bs.fromBufferAttribute(i.attributes.skinWeight, e),
                _s.copy(t).applyMatrix4(this.bindMatrix),
                t.set(0, 0, 0);
                for (let e = 0; e < 4; e++) {
                    const i = bs.getComponent(e);
                    if (0 !== i) {
                        const r = xs.getComponent(e);
                        Ss.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        t.addScaledVector(Es.copy(_s).applyMatrix4(Ss), i)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
            boneTransform(e, t) {
                return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
                this.applyBoneTransform(e, t)
            }
        }
        class Ps extends un {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class Rs extends it {
            constructor(e=null, t=1, n=1, i, r, a, s, o, l=1003, c=1003, h, d) {
                super(null, a, s, o, l, c, i, r, h, d),
                this.isDataTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Ls = new Ft
          , Is = new Ft;
        class Ns {
            constructor(e=[], t=[]) {
                this.uuid = ke(),
                this.bones = e.slice(0),
                this.boneInverses = t,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.init()
            }
            init() {
                const e = this.bones
                  , t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length),
                0 === t.length)
                    this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++)
                        this.boneInverses.push(new Ft)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new Ft;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                    this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                    t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                    t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones
                  , t = this.boneInverses
                  , n = this.boneMatrices
                  , i = this.boneTexture;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i] ? e[i].matrixWorld : Is;
                    Ls.multiplyMatrices(r, t[i]),
                    Ls.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Ns(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = 4 * Math.ceil(e / 4),
                e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new Rs(t,e,e,X,V);
                return n.needsUpdate = !0,
                this.boneMatrices = t,
                this.boneTexture = n,
                this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, i = e.bones.length; n < i; n++) {
                    const i = e.bones[n];
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                    r = new Ps),
                    this.bones.push(r),
                    this.boneInverses.push((new Ft).fromArray(e.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones
                  , n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    e.bones.push(r.uuid);
                    const a = n[i];
                    e.boneInverses.push(a.toArray())
                }
                return e
            }
        }
        class Us extends Dn {
            constructor(e, t, n, i=1) {
                super(e, t, n),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = i
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute,
                e.isInstancedBufferAttribute = !0,
                e
            }
        }
        const Ds = new Ft
          , Bs = new Ft
          , Os = []
          , zs = new pt
          , Fs = new Ft
          , Ws = new di
          , Hs = new Rt;
        class Vs extends di {
            constructor(e, t, n) {
                super(e, t),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new Us(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let e = 0; e < n; e++)
                    this.setMatrixAt(e, Fs)
            }
            computeBoundingBox() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingBox && (this.boundingBox = new pt),
                null === e.boundingBox && e.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Ds),
                    zs.copy(e.boundingBox).applyMatrix4(Ds),
                    this.boundingBox.union(zs)
            }
            computeBoundingSphere() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Rt),
                null === e.boundingSphere && e.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Ds),
                    Hs.copy(e.boundingSphere).applyMatrix4(Ds),
                    this.boundingSphere.union(Hs)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.instanceMatrix.copy(e.instanceMatrix),
                null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                this.count = e.count,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, 3 * e)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            }
            raycast(e, t) {
                const n = this.matrixWorld
                  , i = this.count;
                if (Ws.geometry = this.geometry,
                Ws.material = this.material,
                void 0 !== Ws.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                Hs.copy(this.boundingSphere),
                Hs.applyMatrix4(n),
                !1 !== e.ray.intersectsSphere(Hs)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Ds),
                        Bs.multiplyMatrices(n, Ds),
                        Ws.matrixWorld = Bs,
                        Ws.raycast(e, Os);
                        for (let e = 0, n = Os.length; e < n; e++) {
                            const n = Os[e];
                            n.instanceId = r,
                            n.object = this,
                            t.push(n)
                        }
                        Os.length = 0
                    }
            }
            setColorAt(e, t) {
                null === this.instanceColor && (this.instanceColor = new Us(new Float32Array(3 * this.instanceMatrix.count),3)),
                t.toArray(this.instanceColor.array, 3 * e)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Gs extends Ln {
            constructor(e) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new An(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.linewidth = e.linewidth,
                this.linecap = e.linecap,
                this.linejoin = e.linejoin,
                this.fog = e.fog,
                this
            }
        }
        const js = new ht
          , Xs = new ht
          , qs = new Ft
          , Ys = new zt
          , Zs = new Rt;
        class Ks extends un {
            constructor(e=new qn, t=new Gs) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [0];
                    for (let e = 1, i = t.count; e < i; e++)
                        js.fromBufferAttribute(t, e - 1),
                        Xs.fromBufferAttribute(t, e),
                        n[e] = n[e - 1],
                        n[e] += js.distanceTo(Xs);
                    e.setAttribute("lineDistance", new zn(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = e.params.Line.threshold
                  , a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Zs.copy(n.boundingSphere),
                Zs.applyMatrix4(i),
                Zs.radius += r,
                !1 === e.ray.intersectsSphere(Zs))
                    return;
                qs.copy(i).invert(),
                Ys.copy(e.ray).applyMatrix4(qs);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = s * s
                  , l = new ht
                  , c = new ht
                  , h = new ht
                  , d = new ht
                  , u = this.isLineSegments ? 2 : 1
                  , p = n.index
                  , f = n.attributes.position;
                if (null !== p) {
                    for (let n = Math.max(0, a.start), i = Math.min(p.count, a.start + a.count) - 1; n < i; n += u) {
                        const i = p.getX(n)
                          , r = p.getX(n + 1);
                        l.fromBufferAttribute(f, i),
                        c.fromBufferAttribute(f, r);
                        if (Ys.distanceSqToSegment(l, c, d, h) > o)
                            continue;
                        d.applyMatrix4(this.matrixWorld);
                        const a = e.ray.origin.distanceTo(d);
                        a < e.near || a > e.far || t.push({
                            distance: a,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, a.start), i = Math.min(f.count, a.start + a.count) - 1; n < i; n += u) {
                        l.fromBufferAttribute(f, n),
                        c.fromBufferAttribute(f, n + 1);
                        if (Ys.distanceSqToSegment(l, c, d, h) > o)
                            continue;
                        d.applyMatrix4(this.matrixWorld);
                        const i = e.ray.origin.distanceTo(d);
                        i < e.near || i > e.far || t.push({
                            distance: i,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        const Js = new ht
          , Qs = new ht;
        class $s extends Ks {
            constructor(e, t) {
                super(e, t),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [];
                    for (let e = 0, i = t.count; e < i; e += 2)
                        Js.fromBufferAttribute(t, e),
                        Qs.fromBufferAttribute(t, e + 1),
                        n[e] = 0 === e ? 0 : n[e - 1],
                        n[e + 1] = n[e] + Js.distanceTo(Qs);
                    e.setAttribute("lineDistance", new zn(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class eo extends Ks {
            constructor(e, t) {
                super(e, t),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class to extends Ln {
            constructor(e) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new An(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.size = e.size,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        const no = new Ft
          , io = new zt
          , ro = new Rt
          , ao = new ht;
        class so extends un {
            constructor(e=new qn, t=new to) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = e.params.Points.threshold
                  , a = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                ro.copy(n.boundingSphere),
                ro.applyMatrix4(i),
                ro.radius += r,
                !1 === e.ray.intersectsSphere(ro))
                    return;
                no.copy(i).invert(),
                io.copy(e.ray).applyMatrix4(no);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = s * s
                  , l = n.index
                  , c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, a.start), r = Math.min(l.count, a.start + a.count); n < r; n++) {
                        const r = l.getX(n);
                        ao.fromBufferAttribute(c, r),
                        oo(ao, r, o, i, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); n < r; n++)
                        ao.fromBufferAttribute(c, n),
                        oo(ao, n, o, i, e, t, this)
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        function oo(e, t, n, i, r, a, s) {
            const o = io.distanceSqToPoint(e);
            if (o < n) {
                const n = new ht;
                io.closestPointToPoint(e, n),
                n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far)
                    return;
                a.push({
                    distance: l,
                    distanceToRay: Math.sqrt(o),
                    point: n,
                    index: t,
                    face: null,
                    object: s
                })
            }
        }
        class lo {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }
            getPoints(e=5) {
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                return t
            }
            getSpacedPoints(e=5) {
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPointAt(n / e));
                return t
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths(e=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const t = [];
                let n, i = this.getPoint(0), r = 0;
                t.push(0);
                for (let a = 1; a <= e; a++)
                    n = this.getPoint(a / e),
                    r += n.distanceTo(i),
                    t.push(r),
                    i = n;
                return this.cacheArcLengths = t,
                t
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(e, t) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let a;
                a = t || e * n[r - 1];
                let s, o = 0, l = r - 1;
                for (; o <= l; )
                    if (i = Math.floor(o + (l - o) / 2),
                    s = n[i] - a,
                    s < 0)
                        o = i + 1;
                    else {
                        if (!(s > 0)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    }
                if (i = l,
                n[i] === a)
                    return i / (r - 1);
                const c = n[i];
                return (i + (a - c) / (n[i + 1] - c)) / (r - 1)
            }
            getTangent(e, t) {
                const n = 1e-4;
                let i = e - n
                  , r = e + n;
                i < 0 && (i = 0),
                r > 1 && (r = 1);
                const a = this.getPoint(i)
                  , s = this.getPoint(r)
                  , o = t || (a.isVector2 ? new De : new ht);
                return o.copy(s).sub(a).normalize(),
                o
            }
            getTangentAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }
            computeFrenetFrames(e, t) {
                const n = new ht
                  , i = []
                  , r = []
                  , a = []
                  , s = new ht
                  , o = new Ft;
                for (let t = 0; t <= e; t++) {
                    const n = t / e;
                    i[t] = this.getTangentAt(n, new ht)
                }
                r[0] = new ht,
                a[0] = new ht;
                let l = Number.MAX_VALUE;
                const c = Math.abs(i[0].x)
                  , h = Math.abs(i[0].y)
                  , d = Math.abs(i[0].z);
                c <= l && (l = c,
                n.set(1, 0, 0)),
                h <= l && (l = h,
                n.set(0, 1, 0)),
                d <= l && n.set(0, 0, 1),
                s.crossVectors(i[0], n).normalize(),
                r[0].crossVectors(i[0], s),
                a[0].crossVectors(i[0], r[0]);
                for (let t = 1; t <= e; t++) {
                    if (r[t] = r[t - 1].clone(),
                    a[t] = a[t - 1].clone(),
                    s.crossVectors(i[t - 1], i[t]),
                    s.length() > Number.EPSILON) {
                        s.normalize();
                        const e = Math.acos(Ce(i[t - 1].dot(i[t]), -1, 1));
                        r[t].applyMatrix4(o.makeRotationAxis(s, e))
                    }
                    a[t].crossVectors(i[t], r[t])
                }
                if (!0 === t) {
                    let t = Math.acos(Ce(r[0].dot(r[e]), -1, 1));
                    t /= e,
                    i[0].dot(s.crossVectors(r[0], r[e])) > 0 && (t = -t);
                    for (let n = 1; n <= e; n++)
                        r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                        a[n].crossVectors(i[n], r[n])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: a
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions,
                e.type = this.type,
                e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
        }
        class co extends lo {
            constructor(e=0, t=0, n=1, i=1, r=0, a=2 * Math.PI, s=!1, o=0) {
                super(),
                this.isEllipseCurve = !0,
                this.type = "EllipseCurve",
                this.aX = e,
                this.aY = t,
                this.xRadius = n,
                this.yRadius = i,
                this.aStartAngle = r,
                this.aEndAngle = a,
                this.aClockwise = s,
                this.aRotation = o
            }
            getPoint(e, t) {
                const n = t || new De
                  , i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const a = Math.abs(r) < Number.EPSILON;
                for (; r < 0; )
                    r += i;
                for (; r > i; )
                    r -= i;
                r < Number.EPSILON && (r = a ? 0 : i),
                !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                const s = this.aStartAngle + e * r;
                let o = this.aX + this.xRadius * Math.cos(s)
                  , l = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                    const e = Math.cos(this.aRotation)
                      , t = Math.sin(this.aRotation)
                      , n = o - this.aX
                      , i = l - this.aY;
                    o = n * e - i * t + this.aX,
                    l = n * t + i * e + this.aY
                }
                return n.set(o, l)
            }
            copy(e) {
                return super.copy(e),
                this.aX = e.aX,
                this.aY = e.aY,
                this.xRadius = e.xRadius,
                this.yRadius = e.yRadius,
                this.aStartAngle = e.aStartAngle,
                this.aEndAngle = e.aEndAngle,
                this.aClockwise = e.aClockwise,
                this.aRotation = e.aRotation,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.aX = this.aX,
                e.aY = this.aY,
                e.xRadius = this.xRadius,
                e.yRadius = this.yRadius,
                e.aStartAngle = this.aStartAngle,
                e.aEndAngle = this.aEndAngle,
                e.aClockwise = this.aClockwise,
                e.aRotation = this.aRotation,
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.aX = e.aX,
                this.aY = e.aY,
                this.xRadius = e.xRadius,
                this.yRadius = e.yRadius,
                this.aStartAngle = e.aStartAngle,
                this.aEndAngle = e.aEndAngle,
                this.aClockwise = e.aClockwise,
                this.aRotation = e.aRotation,
                this
            }
        }
        function ho() {
            let e = 0
              , t = 0
              , n = 0
              , i = 0;
            function r(r, a, s, o) {
                e = r,
                t = s,
                n = -3 * r + 3 * a - 2 * s - o,
                i = 2 * r - 2 * a + s + o
            }
            return {
                initCatmullRom: function(e, t, n, i, a) {
                    r(t, n, a * (n - e), a * (i - t))
                },
                initNonuniformCatmullRom: function(e, t, n, i, a, s, o) {
                    let l = (t - e) / a - (n - e) / (a + s) + (n - t) / s
                      , c = (n - t) / s - (i - t) / (s + o) + (i - n) / o;
                    l *= s,
                    c *= s,
                    r(t, n, l, c)
                },
                calc: function(r) {
                    const a = r * r;
                    return e + t * r + n * a + i * (a * r)
                }
            }
        }
        const uo = new ht
          , po = new ho
          , fo = new ho
          , mo = new ho;
        function go(e, t, n, i, r) {
            const a = .5 * (i - t)
              , s = .5 * (r - n)
              , o = e * e;
            return (2 * n - 2 * i + a + s) * (e * o) + (-3 * n + 3 * i - 2 * a - s) * o + a * e + n
        }
        function vo(e, t, n, i) {
            return function(e, t) {
                const n = 1 - e;
                return n * n * t
            }(e, t) + function(e, t) {
                return 2 * (1 - e) * e * t
            }(e, n) + function(e, t) {
                return e * e * t
            }(e, i)
        }
        function wo(e, t, n, i, r) {
            return function(e, t) {
                const n = 1 - e;
                return n * n * n * t
            }(e, t) + function(e, t) {
                const n = 1 - e;
                return 3 * n * n * e * t
            }(e, n) + function(e, t) {
                return 3 * (1 - e) * e * e * t
            }(e, i) + function(e, t) {
                return e * e * e * t
            }(e, r)
        }
        class yo extends lo {
            constructor(e=new De, t=new De, n=new De, i=new De) {
                super(),
                this.isCubicBezierCurve = !0,
                this.type = "CubicBezierCurve",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n,
                this.v3 = i
            }
            getPoint(e, t=new De) {
                const n = t
                  , i = this.v0
                  , r = this.v1
                  , a = this.v2
                  , s = this.v3;
                return n.set(wo(e, i.x, r.x, a.x, s.x), wo(e, i.y, r.y, a.y, s.y)),
                n
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
        }
        class _o extends lo {
            constructor(e=new De, t=new De) {
                super(),
                this.isLineCurve = !0,
                this.type = "LineCurve",
                this.v1 = e,
                this.v2 = t
            }
            getPoint(e, t=new De) {
                const n = t;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(e).add(this.v1)),
                n
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            getTangent(e, t=new De) {
                return t.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, t) {
                return this.getTangent(e, t)
            }
            copy(e) {
                return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class xo extends lo {
            constructor(e=new De, t=new De, n=new De) {
                super(),
                this.isQuadraticBezierCurve = !0,
                this.type = "QuadraticBezierCurve",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n
            }
            getPoint(e, t=new De) {
                const n = t
                  , i = this.v0
                  , r = this.v1
                  , a = this.v2;
                return n.set(vo(e, i.x, r.x, a.x), vo(e, i.y, r.y, a.y)),
                n
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class bo extends lo {
            constructor(e=new ht, t=new ht, n=new ht) {
                super(),
                this.isQuadraticBezierCurve3 = !0,
                this.type = "QuadraticBezierCurve3",
                this.v0 = e,
                this.v1 = t,
                this.v2 = n
            }
            getPoint(e, t=new ht) {
                const n = t
                  , i = this.v0
                  , r = this.v1
                  , a = this.v2;
                return n.set(vo(e, i.x, r.x, a.x), vo(e, i.y, r.y, a.y), vo(e, i.z, r.z, a.z)),
                n
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class Eo extends lo {
            constructor(e=[]) {
                super(),
                this.isSplineCurve = !0,
                this.type = "SplineCurve",
                this.points = e
            }
            getPoint(e, t=new De) {
                const n = t
                  , i = this.points
                  , r = (i.length - 1) * e
                  , a = Math.floor(r)
                  , s = r - a
                  , o = i[0 === a ? a : a - 1]
                  , l = i[a]
                  , c = i[a > i.length - 2 ? i.length - 1 : a + 1]
                  , h = i[a > i.length - 3 ? i.length - 1 : a + 2];
                return n.set(go(s, o.x, l.x, c.x, h.x), go(s, o.y, l.y, c.y, h.y)),
                n
            }
            copy(e) {
                super.copy(e),
                this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new De).fromArray(n))
                }
                return this
            }
        }
        var So = Object.freeze({
            __proto__: null,
            ArcCurve: class extends co {
                constructor(e, t, n, i, r, a) {
                    super(e, t, n, n, i, r, a),
                    this.isArcCurve = !0,
                    this.type = "ArcCurve"
                }
            }
            ,
            CatmullRomCurve3: class extends lo {
                constructor(e=[], t=!1, n="centripetal", i=.5) {
                    super(),
                    this.isCatmullRomCurve3 = !0,
                    this.type = "CatmullRomCurve3",
                    this.points = e,
                    this.closed = t,
                    this.curveType = n,
                    this.tension = i
                }
                getPoint(e, t=new ht) {
                    const n = t
                      , i = this.points
                      , r = i.length
                      , a = (r - (this.closed ? 0 : 1)) * e;
                    let s, o, l = Math.floor(a), c = a - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
                    c = 1),
                    this.closed || l > 0 ? s = i[(l - 1) % r] : (uo.subVectors(i[0], i[1]).add(i[0]),
                    s = uo);
                    const h = i[l % r]
                      , d = i[(l + 1) % r];
                    if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (uo.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
                    o = uo),
                    "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const e = "chordal" === this.curveType ? .5 : .25;
                        let t = Math.pow(s.distanceToSquared(h), e)
                          , n = Math.pow(h.distanceToSquared(d), e)
                          , i = Math.pow(d.distanceToSquared(o), e);
                        n < 1e-4 && (n = 1),
                        t < 1e-4 && (t = n),
                        i < 1e-4 && (i = n),
                        po.initNonuniformCatmullRom(s.x, h.x, d.x, o.x, t, n, i),
                        fo.initNonuniformCatmullRom(s.y, h.y, d.y, o.y, t, n, i),
                        mo.initNonuniformCatmullRom(s.z, h.z, d.z, o.z, t, n, i)
                    } else
                        "catmullrom" === this.curveType && (po.initCatmullRom(s.x, h.x, d.x, o.x, this.tension),
                        fo.initCatmullRom(s.y, h.y, d.y, o.y, this.tension),
                        mo.initCatmullRom(s.z, h.z, d.z, o.z, this.tension));
                    return n.set(po.calc(c), fo.calc(c), mo.calc(c)),
                    n
                }
                copy(e) {
                    super.copy(e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this.closed = e.closed,
                    this.curveType = e.curveType,
                    this.tension = e.tension,
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e.closed = this.closed,
                    e.curveType = this.curveType,
                    e.tension = this.tension,
                    e
                }
                fromJSON(e) {
                    super.fromJSON(e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new ht).fromArray(n))
                    }
                    return this.closed = e.closed,
                    this.curveType = e.curveType,
                    this.tension = e.tension,
                    this
                }
            }
            ,
            CubicBezierCurve: yo,
            CubicBezierCurve3: class extends lo {
                constructor(e=new ht, t=new ht, n=new ht, i=new ht) {
                    super(),
                    this.isCubicBezierCurve3 = !0,
                    this.type = "CubicBezierCurve3",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n,
                    this.v3 = i
                }
                getPoint(e, t=new ht) {
                    const n = t
                      , i = this.v0
                      , r = this.v1
                      , a = this.v2
                      , s = this.v3;
                    return n.set(wo(e, i.x, r.x, a.x, s.x), wo(e, i.y, r.y, a.y, s.y), wo(e, i.z, r.z, a.z, s.z)),
                    n
                }
                copy(e) {
                    return super.copy(e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this.v3.copy(e.v3),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e.v3 = this.v3.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this.v3.fromArray(e.v3),
                    this
                }
            }
            ,
            EllipseCurve: co,
            LineCurve: _o,
            LineCurve3: class extends lo {
                constructor(e=new ht, t=new ht) {
                    super(),
                    this.isLineCurve3 = !0,
                    this.type = "LineCurve3",
                    this.v1 = e,
                    this.v2 = t
                }
                getPoint(e, t=new ht) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(e).add(this.v1)),
                    n
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t=new ht) {
                    return t.subVectors(this.v2, this.v1).normalize()
                }
                getTangentAt(e, t) {
                    return this.getTangent(e, t)
                }
                copy(e) {
                    return super.copy(e),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
            }
            ,
            QuadraticBezierCurve: xo,
            QuadraticBezierCurve3: bo,
            SplineCurve: Eo
        });
        class Mo extends lo {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(e) {
                this.curves.push(e)
            }
            closePath() {
                const e = this.curves[0].getPoint(0)
                  , t = this.curves[this.curves.length - 1].getPoint(1);
                if (!e.equals(t)) {
                    const n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
                    this.curves.push(new So[n](t,e))
                }
                return this
            }
            getPoint(e, t) {
                const n = e * this.getLength()
                  , i = this.getCurveLengths();
                let r = 0;
                for (; r < i.length; ) {
                    if (i[r] >= n) {
                        const e = i[r] - n
                          , a = this.curves[r]
                          , s = a.getLength()
                          , o = 0 === s ? 0 : 1 - e / s;
                        return a.getPointAt(o, t)
                    }
                    r++
                }
                return null
            }
            getLength() {
                const e = this.getCurveLengths();
                return e[e.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const e = [];
                let t = 0;
                for (let n = 0, i = this.curves.length; n < i; n++)
                    t += this.curves[n].getLength(),
                    e.push(t);
                return this.cacheLengths = e,
                e
            }
            getSpacedPoints(e=40) {
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]),
                t
            }
            getPoints(e=12) {
                const t = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const a = r[i]
                      , s = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e
                      , o = a.getPoints(s);
                    for (let e = 0; e < o.length; e++) {
                        const i = o[e];
                        n && n.equals(i) || (t.push(i),
                        n = i)
                    }
                }
                return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                t
            }
            copy(e) {
                super.copy(e),
                this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const n = e.curves[t];
                    this.curves.push(n.clone())
                }
                return this.autoClose = e.autoClose,
                this
            }
            toJSON() {
                const e = super.toJSON();
                e.autoClose = this.autoClose,
                e.curves = [];
                for (let t = 0, n = this.curves.length; t < n; t++) {
                    const n = this.curves[t];
                    e.curves.push(n.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.autoClose = e.autoClose,
                this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const n = e.curves[t];
                    this.curves.push((new So[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class To extends Mo {
            constructor(e) {
                super(),
                this.type = "Path",
                this.currentPoint = new De,
                e && this.setFromPoints(e)
            }
            setFromPoints(e) {
                this.moveTo(e[0].x, e[0].y);
                for (let t = 1, n = e.length; t < n; t++)
                    this.lineTo(e[t].x, e[t].y);
                return this
            }
            moveTo(e, t) {
                return this.currentPoint.set(e, t),
                this
            }
            lineTo(e, t) {
                const n = new _o(this.currentPoint.clone(),new De(e,t));
                return this.curves.push(n),
                this.currentPoint.set(e, t),
                this
            }
            quadraticCurveTo(e, t, n, i) {
                const r = new xo(this.currentPoint.clone(),new De(e,t),new De(n,i));
                return this.curves.push(r),
                this.currentPoint.set(n, i),
                this
            }
            bezierCurveTo(e, t, n, i, r, a) {
                const s = new yo(this.currentPoint.clone(),new De(e,t),new De(n,i),new De(r,a));
                return this.curves.push(s),
                this.currentPoint.set(r, a),
                this
            }
            splineThru(e) {
                const t = [this.currentPoint.clone()].concat(e)
                  , n = new Eo(t);
                return this.curves.push(n),
                this.currentPoint.copy(e[e.length - 1]),
                this
            }
            arc(e, t, n, i, r, a) {
                const s = this.currentPoint.x
                  , o = this.currentPoint.y;
                return this.absarc(e + s, t + o, n, i, r, a),
                this
            }
            absarc(e, t, n, i, r, a) {
                return this.absellipse(e, t, n, n, i, r, a),
                this
            }
            ellipse(e, t, n, i, r, a, s, o) {
                const l = this.currentPoint.x
                  , c = this.currentPoint.y;
                return this.absellipse(e + l, t + c, n, i, r, a, s, o),
                this
            }
            absellipse(e, t, n, i, r, a, s, o) {
                const l = new co(e,t,n,i,r,a,s,o);
                if (this.curves.length > 0) {
                    const e = l.getPoint(0);
                    e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c),
                this
            }
            copy(e) {
                return super.copy(e),
                this.currentPoint.copy(e.currentPoint),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.currentPoint = this.currentPoint.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.currentPoint.fromArray(e.currentPoint),
                this
            }
        }
        class ko extends qn {
            constructor(e=1, t=32, n=0, i=2 * Math.PI) {
                super(),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: i
                },
                t = Math.max(3, t);
                const r = []
                  , a = []
                  , s = []
                  , o = []
                  , l = new ht
                  , c = new De;
                a.push(0, 0, 0),
                s.push(0, 0, 1),
                o.push(.5, .5);
                for (let r = 0, h = 3; r <= t; r++,
                h += 3) {
                    const d = n + r / t * i;
                    l.x = e * Math.cos(d),
                    l.y = e * Math.sin(d),
                    a.push(l.x, l.y, l.z),
                    s.push(0, 0, 1),
                    c.x = (a[h] / e + 1) / 2,
                    c.y = (a[h + 1] / e + 1) / 2,
                    o.push(c.x, c.y)
                }
                for (let e = 1; e <= t; e++)
                    r.push(e, e + 1, 0);
                this.setIndex(r),
                this.setAttribute("position", new zn(a,3)),
                this.setAttribute("normal", new zn(s,3)),
                this.setAttribute("uv", new zn(o,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new ko(e.radius,e.segments,e.thetaStart,e.thetaLength)
            }
        }
        class Co extends To {
            constructor(e) {
                super(e),
                this.uuid = ke(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(e) {
                const t = [];
                for (let n = 0, i = this.holes.length; n < i; n++)
                    t[n] = this.holes[n].getPoints(e);
                return t
            }
            extractPoints(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }
            copy(e) {
                super.copy(e),
                this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const n = e.holes[t];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.uuid = this.uuid,
                e.holes = [];
                for (let t = 0, n = this.holes.length; t < n; t++) {
                    const n = this.holes[t];
                    e.holes.push(n.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.uuid = e.uuid,
                this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const n = e.holes[t];
                    this.holes.push((new To).fromJSON(n))
                }
                return this
            }
        }
        const Ao = function(e, t, n=2) {
            const i = t && t.length
              , r = i ? t[0] * n : e.length;
            let a = Po(e, 0, r, n, !0);
            const s = [];
            if (!a || a.next === a.prev)
                return s;
            let o, l, c, h, d, u, p;
            if (i && (a = function(e, t, n, i) {
                const r = [];
                let a, s, o, l, c;
                for (a = 0,
                s = t.length; a < s; a++)
                    o = t[a] * i,
                    l = a < s - 1 ? t[a + 1] * i : e.length,
                    c = Po(e, o, l, i, !1),
                    c === c.next && (c.steiner = !0),
                    r.push(Wo(c));
                for (r.sort(Bo),
                a = 0; a < r.length; a++)
                    n = Oo(r[a], n);
                return n
            }(e, t, a, n)),
            e.length > 80 * n) {
                o = c = e[0],
                l = h = e[1];
                for (let t = n; t < r; t += n)
                    d = e[t],
                    u = e[t + 1],
                    d < o && (o = d),
                    u < l && (l = u),
                    d > c && (c = d),
                    u > h && (h = u);
                p = Math.max(c - o, h - l),
                p = 0 !== p ? 32767 / p : 0
            }
            return Lo(a, s, n, o, l, p, 0),
            s
        };
        function Po(e, t, n, i, r) {
            let a, s;
            if (r === function(e, t, n, i) {
                let r = 0;
                for (let a = t, s = n - i; a < n; a += i)
                    r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]),
                    s = a;
                return r
            }(e, t, n, i) > 0)
                for (a = t; a < n; a += i)
                    s = Jo(a, e[a], e[a + 1], s);
            else
                for (a = n - i; a >= t; a -= i)
                    s = Jo(a, e[a], e[a + 1], s);
            return s && jo(s, s.next) && (Qo(s),
            s = s.next),
            s
        }
        function Ro(e, t) {
            if (!e)
                return e;
            t || (t = e);
            let n, i = e;
            do {
                if (n = !1,
                i.steiner || !jo(i, i.next) && 0 !== Go(i.prev, i, i.next))
                    i = i.next;
                else {
                    if (Qo(i),
                    i = t = i.prev,
                    i === i.next)
                        break;
                    n = !0
                }
            } while (n || i !== t);
            return t
        }
        function Lo(e, t, n, i, r, a, s) {
            if (!e)
                return;
            !s && a && function(e, t, n, i) {
                let r = e;
                do {
                    0 === r.z && (r.z = Fo(r.x, r.y, t, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== e);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(e) {
                    let t, n, i, r, a, s, o, l, c = 1;
                    do {
                        for (n = e,
                        e = null,
                        a = null,
                        s = 0; n; ) {
                            for (s++,
                            i = n,
                            o = 0,
                            t = 0; t < c && (o++,
                            i = i.nextZ,
                            i); t++)
                                ;
                            for (l = c; o > 0 || l > 0 && i; )
                                0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n,
                                n = n.nextZ,
                                o--) : (r = i,
                                i = i.nextZ,
                                l--),
                                a ? a.nextZ = r : e = r,
                                r.prevZ = a,
                                a = r;
                            n = i
                        }
                        a.nextZ = null,
                        c *= 2
                    } while (s > 1)
                }(r)
            }(e, i, r, a);
            let o, l, c = e;
            for (; e.prev !== e.next; )
                if (o = e.prev,
                l = e.next,
                a ? No(e, i, r, a) : Io(e))
                    t.push(o.i / n | 0),
                    t.push(e.i / n | 0),
                    t.push(l.i / n | 0),
                    Qo(e),
                    e = l.next,
                    c = l.next;
                else if ((e = l) === c) {
                    s ? 1 === s ? Lo(e = Uo(Ro(e), t, n), t, n, i, r, a, 2) : 2 === s && Do(e, t, n, i, r, a) : Lo(Ro(e), t, n, i, r, a, 1);
                    break
                }
        }
        function Io(e) {
            const t = e.prev
              , n = e
              , i = e.next;
            if (Go(t, n, i) >= 0)
                return !1;
            const r = t.x
              , a = n.x
              , s = i.x
              , o = t.y
              , l = n.y
              , c = i.y
              , h = r < a ? r < s ? r : s : a < s ? a : s
              , d = o < l ? o < c ? o : c : l < c ? l : c
              , u = r > a ? r > s ? r : s : a > s ? a : s
              , p = o > l ? o > c ? o : c : l > c ? l : c;
            let f = i.next;
            for (; f !== t; ) {
                if (f.x >= h && f.x <= u && f.y >= d && f.y <= p && Ho(r, o, a, l, s, c, f.x, f.y) && Go(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.next
            }
            return !0
        }
        function No(e, t, n, i) {
            const r = e.prev
              , a = e
              , s = e.next;
            if (Go(r, a, s) >= 0)
                return !1;
            const o = r.x
              , l = a.x
              , c = s.x
              , h = r.y
              , d = a.y
              , u = s.y
              , p = o < l ? o < c ? o : c : l < c ? l : c
              , f = h < d ? h < u ? h : u : d < u ? d : u
              , m = o > l ? o > c ? o : c : l > c ? l : c
              , g = h > d ? h > u ? h : u : d > u ? d : u
              , v = Fo(p, f, t, n, i)
              , w = Fo(m, g, t, n, i);
            let y = e.prevZ
              , _ = e.nextZ;
            for (; y && y.z >= v && _ && _.z <= w; ) {
                if (y.x >= p && y.x <= m && y.y >= f && y.y <= g && y !== r && y !== s && Ho(o, h, l, d, c, u, y.x, y.y) && Go(y.prev, y, y.next) >= 0)
                    return !1;
                if (y = y.prevZ,
                _.x >= p && _.x <= m && _.y >= f && _.y <= g && _ !== r && _ !== s && Ho(o, h, l, d, c, u, _.x, _.y) && Go(_.prev, _, _.next) >= 0)
                    return !1;
                _ = _.nextZ
            }
            for (; y && y.z >= v; ) {
                if (y.x >= p && y.x <= m && y.y >= f && y.y <= g && y !== r && y !== s && Ho(o, h, l, d, c, u, y.x, y.y) && Go(y.prev, y, y.next) >= 0)
                    return !1;
                y = y.prevZ
            }
            for (; _ && _.z <= w; ) {
                if (_.x >= p && _.x <= m && _.y >= f && _.y <= g && _ !== r && _ !== s && Ho(o, h, l, d, c, u, _.x, _.y) && Go(_.prev, _, _.next) >= 0)
                    return !1;
                _ = _.nextZ
            }
            return !0
        }
        function Uo(e, t, n) {
            let i = e;
            do {
                const r = i.prev
                  , a = i.next.next;
                !jo(r, a) && Xo(r, i, i.next, a) && Zo(r, a) && Zo(a, r) && (t.push(r.i / n | 0),
                t.push(i.i / n | 0),
                t.push(a.i / n | 0),
                Qo(i),
                Qo(i.next),
                i = e = a),
                i = i.next
            } while (i !== e);
            return Ro(i)
        }
        function Do(e, t, n, i, r, a) {
            let s = e;
            do {
                let e = s.next.next;
                for (; e !== s.prev; ) {
                    if (s.i !== e.i && Vo(s, e)) {
                        let o = Ko(s, e);
                        return s = Ro(s, s.next),
                        o = Ro(o, o.next),
                        Lo(s, t, n, i, r, a, 0),
                        void Lo(o, t, n, i, r, a, 0)
                    }
                    e = e.next
                }
                s = s.next
            } while (s !== e)
        }
        function Bo(e, t) {
            return e.x - t.x
        }
        function Oo(e, t) {
            const n = function(e, t) {
                let n, i = t, r = -1 / 0;
                const a = e.x
                  , s = e.y;
                do {
                    if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                        const e = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (e <= a && e > r && (r = e,
                        n = i.x < i.next.x ? i : i.next,
                        e === a))
                            return n
                    }
                    i = i.next
                } while (i !== t);
                if (!n)
                    return null;
                const o = n
                  , l = n.x
                  , c = n.y;
                let h, d = 1 / 0;
                i = n;
                do {
                    a >= i.x && i.x >= l && a !== i.x && Ho(s < c ? a : r, s, l, c, s < c ? r : a, s, i.x, i.y) && (h = Math.abs(s - i.y) / (a - i.x),
                    Zo(i, e) && (h < d || h === d && (i.x > n.x || i.x === n.x && zo(n, i))) && (n = i,
                    d = h)),
                    i = i.next
                } while (i !== o);
                return n
            }(e, t);
            if (!n)
                return t;
            const i = Ko(n, e);
            return Ro(i, i.next),
            Ro(n, n.next)
        }
        function zo(e, t) {
            return Go(e.prev, e, t.prev) < 0 && Go(t.next, e, e.next) < 0
        }
        function Fo(e, t, n, i, r) {
            return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }
        function Wo(e) {
            let t = e
              , n = e;
            do {
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                t = t.next
            } while (t !== e);
            return n
        }
        function Ho(e, t, n, i, r, a, s, o) {
            return (r - s) * (t - o) >= (e - s) * (a - o) && (e - s) * (i - o) >= (n - s) * (t - o) && (n - s) * (a - o) >= (r - s) * (i - o)
        }
        function Vo(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
                let n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Xo(n, n.next, e, t))
                        return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }(e, t) && (Zo(e, t) && Zo(t, e) && function(e, t) {
                let n = e
                  , i = !1;
                const r = (e.x + t.x) / 2
                  , a = (e.y + t.y) / 2;
                do {
                    n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                    n = n.next
                } while (n !== e);
                return i
            }(e, t) && (Go(e.prev, e, t.prev) || Go(e, t.prev, t)) || jo(e, t) && Go(e.prev, e, e.next) > 0 && Go(t.prev, t, t.next) > 0)
        }
        function Go(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }
        function jo(e, t) {
            return e.x === t.x && e.y === t.y
        }
        function Xo(e, t, n, i) {
            const r = Yo(Go(e, t, n))
              , a = Yo(Go(e, t, i))
              , s = Yo(Go(n, i, e))
              , o = Yo(Go(n, i, t));
            return r !== a && s !== o || (!(0 !== r || !qo(e, n, t)) || (!(0 !== a || !qo(e, i, t)) || (!(0 !== s || !qo(n, e, i)) || !(0 !== o || !qo(n, t, i)))))
        }
        function qo(e, t, n) {
            return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
        }
        function Yo(e) {
            return e > 0 ? 1 : e < 0 ? -1 : 0
        }
        function Zo(e, t) {
            return Go(e.prev, e, e.next) < 0 ? Go(e, t, e.next) >= 0 && Go(e, e.prev, t) >= 0 : Go(e, t, e.prev) < 0 || Go(e, e.next, t) < 0
        }
        function Ko(e, t) {
            const n = new $o(e.i,e.x,e.y)
              , i = new $o(t.i,t.x,t.y)
              , r = e.next
              , a = t.prev;
            return e.next = t,
            t.prev = e,
            n.next = r,
            r.prev = n,
            i.next = n,
            n.prev = i,
            a.next = i,
            i.prev = a,
            i
        }
        function Jo(e, t, n, i) {
            const r = new $o(e,t,n);
            return i ? (r.next = i.next,
            r.prev = i,
            i.next.prev = r,
            i.next = r) : (r.prev = r,
            r.next = r),
            r
        }
        function Qo(e) {
            e.next.prev = e.prev,
            e.prev.next = e.next,
            e.prevZ && (e.prevZ.nextZ = e.nextZ),
            e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }
        function $o(e, t, n) {
            this.i = e,
            this.x = t,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class el {
            static area(e) {
                const t = e.length;
                let n = 0;
                for (let i = t - 1, r = 0; r < t; i = r++)
                    n += e[i].x * e[r].y - e[r].x * e[i].y;
                return .5 * n
            }
            static isClockWise(e) {
                return el.area(e) < 0
            }
            static triangulateShape(e, t) {
                const n = []
                  , i = []
                  , r = [];
                tl(e),
                nl(n, e);
                let a = e.length;
                t.forEach(tl);
                for (let e = 0; e < t.length; e++)
                    i.push(a),
                    a += t[e].length,
                    nl(n, t[e]);
                const s = Ao(n, i);
                for (let e = 0; e < s.length; e += 3)
                    r.push(s.slice(e, e + 3));
                return r
            }
        }
        function tl(e) {
            const t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop()
        }
        function nl(e, t) {
            for (let n = 0; n < t.length; n++)
                e.push(t[n].x),
                e.push(t[n].y)
        }
        class il extends qn {
            constructor(e=new Co([new De(0,.5), new De(-.5,-.5), new De(.5,-.5)]), t=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: e,
                    curveSegments: t
                };
                const n = []
                  , i = []
                  , r = []
                  , a = [];
                let s = 0
                  , o = 0;
                if (!1 === Array.isArray(e))
                    l(e);
                else
                    for (let t = 0; t < e.length; t++)
                        l(e[t]),
                        this.addGroup(s, o, t),
                        s += o,
                        o = 0;
                function l(e) {
                    const s = i.length / 3
                      , l = e.extractPoints(t);
                    let c = l.shape;
                    const h = l.holes;
                    !1 === el.isClockWise(c) && (c = c.reverse());
                    for (let e = 0, t = h.length; e < t; e++) {
                        const t = h[e];
                        !0 === el.isClockWise(t) && (h[e] = t.reverse())
                    }
                    const d = el.triangulateShape(c, h);
                    for (let e = 0, t = h.length; e < t; e++) {
                        const t = h[e];
                        c = c.concat(t)
                    }
                    for (let e = 0, t = c.length; e < t; e++) {
                        const t = c[e];
                        i.push(t.x, t.y, 0),
                        r.push(0, 0, 1),
                        a.push(t.x, t.y)
                    }
                    for (let e = 0, t = d.length; e < t; e++) {
                        const t = d[e]
                          , i = t[0] + s
                          , r = t[1] + s
                          , a = t[2] + s;
                        n.push(i, r, a),
                        o += 3
                    }
                }
                this.setIndex(n),
                this.setAttribute("position", new zn(i,3)),
                this.setAttribute("normal", new zn(r,3)),
                this.setAttribute("uv", new zn(a,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return function(e, t) {
                    if (t.shapes = [],
                    Array.isArray(e))
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            t.shapes.push(i.uuid)
                        }
                    else
                        t.shapes.push(e.uuid);
                    return t
                }(this.parameters.shapes, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let i = 0, r = e.shapes.length; i < r; i++) {
                    const r = t[e.shapes[i]];
                    n.push(r)
                }
                return new il(n,e.curveSegments)
            }
        }
        class rl extends qn {
            constructor(e=1, t=32, n=16, i=0, r=2 * Math.PI, a=0, s=Math.PI) {
                super(),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: s
                },
                t = Math.max(3, Math.floor(t)),
                n = Math.max(2, Math.floor(n));
                const o = Math.min(a + s, Math.PI);
                let l = 0;
                const c = []
                  , h = new ht
                  , d = new ht
                  , u = []
                  , p = []
                  , f = []
                  , m = [];
                for (let u = 0; u <= n; u++) {
                    const g = []
                      , v = u / n;
                    let w = 0;
                    0 === u && 0 === a ? w = .5 / t : u === n && o === Math.PI && (w = -.5 / t);
                    for (let n = 0; n <= t; n++) {
                        const o = n / t;
                        h.x = -e * Math.cos(i + o * r) * Math.sin(a + v * s),
                        h.y = e * Math.cos(a + v * s),
                        h.z = e * Math.sin(i + o * r) * Math.sin(a + v * s),
                        p.push(h.x, h.y, h.z),
                        d.copy(h).normalize(),
                        f.push(d.x, d.y, d.z),
                        m.push(o + w, 1 - v),
                        g.push(l++)
                    }
                    c.push(g)
                }
                for (let e = 0; e < n; e++)
                    for (let i = 0; i < t; i++) {
                        const t = c[e][i + 1]
                          , r = c[e][i]
                          , s = c[e + 1][i]
                          , l = c[e + 1][i + 1];
                        (0 !== e || a > 0) && u.push(t, r, l),
                        (e !== n - 1 || o < Math.PI) && u.push(r, s, l)
                    }
                this.setIndex(u),
                this.setAttribute("position", new zn(p,3)),
                this.setAttribute("normal", new zn(f,3)),
                this.setAttribute("uv", new zn(m,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new rl(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
            }
        }
        class al extends Ln {
            constructor(e) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new An(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new An(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new De(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(e.color),
                this.roughness = e.roughness,
                this.metalness = e.metalness,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.roughnessMap = e.roughnessMap,
                this.metalnessMap = e.metalnessMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapIntensity = e.envMapIntensity,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class sl extends al {
            constructor(e) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new De(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return Ce(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new An(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new An(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new An(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(e)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(e) {
                this._anisotropy > 0 != e > 0 && this.version++,
                this._anisotropy = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++,
                this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 != e > 0 && this.version++,
                this._iridescence = e
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++,
                this._sheen = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++,
                this._transmission = e
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = e.anisotropy,
                this.anisotropyRotation = e.anisotropyRotation,
                this.anisotropyMap = e.anisotropyMap,
                this.clearcoat = e.clearcoat,
                this.clearcoatMap = e.clearcoatMap,
                this.clearcoatRoughness = e.clearcoatRoughness,
                this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                this.clearcoatNormalMap = e.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                this.ior = e.ior,
                this.iridescence = e.iridescence,
                this.iridescenceMap = e.iridescenceMap,
                this.iridescenceIOR = e.iridescenceIOR,
                this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                this.sheen = e.sheen,
                this.sheenColor.copy(e.sheenColor),
                this.sheenColorMap = e.sheenColorMap,
                this.sheenRoughness = e.sheenRoughness,
                this.sheenRoughnessMap = e.sheenRoughnessMap,
                this.transmission = e.transmission,
                this.transmissionMap = e.transmissionMap,
                this.thickness = e.thickness,
                this.thicknessMap = e.thicknessMap,
                this.attenuationDistance = e.attenuationDistance,
                this.attenuationColor.copy(e.attenuationColor),
                this.specularIntensity = e.specularIntensity,
                this.specularIntensityMap = e.specularIntensityMap,
                this.specularColor.copy(e.specularColor),
                this.specularColorMap = e.specularColorMap,
                this
            }
        }
        class ol extends Ln {
            constructor(e) {
                super(),
                this.isMeshLambertMaterial = !0,
                this.type = "MeshLambertMaterial",
                this.color = new An(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new An(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new De(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        function ll(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }
        function cl(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }
        function hl(e) {
            const t = e.length
              , n = new Array(t);
            for (let e = 0; e !== t; ++e)
                n[e] = e;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            }
            )),
            n
        }
        function dl(e, t, n) {
            const i = e.length
              , r = new e.constructor(i);
            for (let a = 0, s = 0; s !== i; ++a) {
                const i = n[a] * t;
                for (let n = 0; n !== t; ++n)
                    r[s++] = e[i + n]
            }
            return r
        }
        function ul(e, t, n, i) {
            let r = 1
              , a = e[0];
            for (; void 0 !== a && void 0 === a[i]; )
                a = e[r++];
            if (void 0 === a)
                return;
            let s = a[i];
            if (void 0 !== s)
                if (Array.isArray(s))
                    do {
                        s = a[i],
                        void 0 !== s && (t.push(a.time),
                        n.push.apply(n, s)),
                        a = e[r++]
                    } while (void 0 !== a);
                else if (void 0 !== s.toArray)
                    do {
                        s = a[i],
                        void 0 !== s && (t.push(a.time),
                        s.toArray(n, n.length)),
                        a = e[r++]
                    } while (void 0 !== a);
                else
                    do {
                        s = a[i],
                        void 0 !== s && (t.push(a.time),
                        n.push(s)),
                        a = e[r++]
                    } while (void 0 !== a)
        }
        class pl {
            constructor(e, t, n, i) {
                this.parameterPositions = e,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
                this.sampleValues = t,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex
                  , i = t[n]
                  , r = t[n - 1];
                e: {
                    t: {
                        let a;
                        n: {
                            i: if (!(e < i)) {
                                for (let a = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (e < r)
                                            break i;
                                        return n = t.length,
                                        this._cachedIndex = n,
                                        this.copySampleValue_(n - 1)
                                    }
                                    if (n === a)
                                        break;
                                    if (r = i,
                                    i = t[++n],
                                    e < i)
                                        break t
                                }
                                a = t.length;
                                break n
                            }
                            if (e >= r)
                                break e;
                            {
                                const s = t[1];
                                e < s && (n = 2,
                                r = s);
                                for (let a = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (n === a)
                                        break;
                                    if (i = r,
                                    r = t[--n - 1],
                                    e >= r)
                                        break t
                                }
                                a = n,
                                n = 0
                            }
                        }
                        for (; n < a; ) {
                            const i = n + a >>> 1;
                            e < t[i] ? a = i : n = i + 1
                        }
                        if (i = t[n],
                        r = t[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === i)
                            return n = t.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = e * i;
                for (let e = 0; e !== i; ++e)
                    t[e] = n[r + e];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class fl extends pl {
            constructor(e, t, n, i) {
                super(e, t, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: ie,
                    endingEnd: ie
                }
            }
            intervalChanged_(e, t, n) {
                const i = this.parameterPositions;
                let r = e - 2
                  , a = e + 1
                  , s = i[r]
                  , o = i[a];
                if (void 0 === s)
                    switch (this.getSettings_().endingStart) {
                    case re:
                        r = e,
                        s = 2 * t - n;
                        break;
                    case ae:
                        r = i.length - 2,
                        s = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e,
                        s = n
                    }
                if (void 0 === o)
                    switch (this.getSettings_().endingEnd) {
                    case re:
                        a = e,
                        o = 2 * n - t;
                        break;
                    case ae:
                        a = 1,
                        o = n + i[1] - i[0];
                        break;
                    default:
                        a = e - 1,
                        o = t
                    }
                const l = .5 * (n - t)
                  , c = this.valueSize;
                this._weightPrev = l / (t - s),
                this._weightNext = l / (o - n),
                this._offsetPrev = r * c,
                this._offsetNext = a * c
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = e * s
                  , l = o - s
                  , c = this._offsetPrev
                  , h = this._offsetNext
                  , d = this._weightPrev
                  , u = this._weightNext
                  , p = (n - t) / (i - t)
                  , f = p * p
                  , m = f * p
                  , g = -d * m + 2 * d * f - d * p
                  , v = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1
                  , w = (-1 - u) * m + (1.5 + u) * f + .5 * p
                  , y = u * m - u * f;
                for (let e = 0; e !== s; ++e)
                    r[e] = g * a[c + e] + v * a[l + e] + w * a[o + e] + y * a[h + e];
                return r
            }
        }
        class ml extends pl {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = e * s
                  , l = o - s
                  , c = (n - t) / (i - t)
                  , h = 1 - c;
                for (let e = 0; e !== s; ++e)
                    r[e] = a[l + e] * h + a[o + e] * c;
                return r
            }
        }
        class gl extends pl {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class vl {
            constructor(e, t, n, i) {
                if (void 0 === e)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e,
                this.times = ll(t, this.TimeBufferType),
                this.values = ll(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON)
                    n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: ll(e.times, Array),
                        values: ll(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new gl(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new ml(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new fl(this.times,this.values,this.getValueSize(),e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                case ee:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case te:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case ne:
                    t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation)
                            throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t),
                    this
                }
                return this.createInterpolant = t,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return ee;
                case this.InterpolantFactoryMethodLinear:
                    return te;
                case this.InterpolantFactoryMethodSmooth:
                    return ne
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , a = i - 1;
                for (; r !== i && n[r] < e; )
                    ++r;
                for (; -1 !== a && n[a] > t; )
                    --a;
                if (++a,
                0 !== r || a !== i) {
                    r >= a && (a = Math.max(a, 1),
                    r = a - 1);
                    const e = this.getValueSize();
                    this.times = n.slice(r, a),
                    this.values = this.values.slice(r * e, a * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                e = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                e = !1);
                let a = null;
                for (let t = 0; t !== r; t++) {
                    const i = n[t];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i),
                        e = !1;
                        break
                    }
                    if (null !== a && a > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, a),
                        e = !1;
                        break
                    }
                    a = i
                }
                if (void 0 !== i && cl(i))
                    for (let t = 0, n = i.length; t !== n; ++t) {
                        const n = i[t];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                            e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = this.getValueSize()
                  , i = this.getInterpolation() === ne
                  , r = e.length - 1;
                let a = 1;
                for (let s = 1; s < r; ++s) {
                    let r = !1;
                    const o = e[s];
                    if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                        if (i)
                            r = !0;
                        else {
                            const e = s * n
                              , i = e - n
                              , a = e + n;
                            for (let s = 0; s !== n; ++s) {
                                const n = t[e + s];
                                if (n !== t[i + s] || n !== t[a + s]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (s !== a) {
                            e[a] = e[s];
                            const i = s * n
                              , r = a * n;
                            for (let e = 0; e !== n; ++e)
                                t[r + e] = t[i + e]
                        }
                        ++a
                    }
                }
                if (r > 0) {
                    e[a] = e[r];
                    for (let e = r * n, i = a * n, s = 0; s !== n; ++s)
                        t[i + s] = t[e + s];
                    ++a
                }
                return a !== e.length ? (this.times = e.slice(0, a),
                this.values = t.slice(0, a * n)) : (this.times = e,
                this.values = t),
                this
            }
            clone() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = new (0,
                this.constructor)(this.name,e,t);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        vl.prototype.TimeBufferType = Float32Array,
        vl.prototype.ValueBufferType = Float32Array,
        vl.prototype.DefaultInterpolation = te;
        class wl extends vl {
        }
        wl.prototype.ValueTypeName = "bool",
        wl.prototype.ValueBufferType = Array,
        wl.prototype.DefaultInterpolation = ee,
        wl.prototype.InterpolantFactoryMethodLinear = void 0,
        wl.prototype.InterpolantFactoryMethodSmooth = void 0;
        class yl extends vl {
        }
        yl.prototype.ValueTypeName = "color";
        class _l extends vl {
        }
        _l.prototype.ValueTypeName = "number";
        class xl extends pl {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = (n - t) / (i - t);
                let l = e * s;
                for (let e = l + s; l !== e; l += 4)
                    ct.slerpFlat(r, 0, a, l - s, a, l, o);
                return r
            }
        }
        class bl extends vl {
            InterpolantFactoryMethodLinear(e) {
                return new xl(this.times,this.values,this.getValueSize(),e)
            }
        }
        bl.prototype.ValueTypeName = "quaternion",
        bl.prototype.DefaultInterpolation = te,
        bl.prototype.InterpolantFactoryMethodSmooth = void 0;
        class El extends vl {
        }
        El.prototype.ValueTypeName = "string",
        El.prototype.ValueBufferType = Array,
        El.prototype.DefaultInterpolation = ee,
        El.prototype.InterpolantFactoryMethodLinear = void 0,
        El.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Sl extends vl {
        }
        Sl.prototype.ValueTypeName = "vector";
        class Ml {
            constructor(e, t=-1, n, i=2500) {
                this.name = e,
                this.tracks = n,
                this.duration = t,
                this.blendMode = i,
                this.uuid = ke(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = []
                  , n = e.tracks
                  , i = 1 / (e.fps || 1);
                for (let e = 0, r = n.length; e !== r; ++e)
                    t.push(Tl(n[e]).scale(i));
                const r = new this(e.name,e.duration,t,e.blendMode);
                return r.uuid = e.uuid,
                r
            }
            static toJSON(e) {
                const t = []
                  , n = e.tracks
                  , i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
                for (let e = 0, i = n.length; e !== i; ++e)
                    t.push(vl.toJSON(n[e]));
                return i
            }
            static CreateFromMorphTargetSequence(e, t, n, i) {
                const r = t.length
                  , a = [];
                for (let e = 0; e < r; e++) {
                    let s = []
                      , o = [];
                    s.push((e + r - 1) % r, e, (e + 1) % r),
                    o.push(0, 1, 0);
                    const l = hl(s);
                    s = dl(s, 1, l),
                    o = dl(o, 1, l),
                    i || 0 !== s[0] || (s.push(r),
                    o.push(o[0])),
                    a.push(new _l(".morphTargetInfluences[" + t[e].name + "]",s,o).scale(1 / n))
                }
                return new this(e,-1,a)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let e = 0; e < n.length; e++)
                    if (n[e].name === t)
                        return n[e];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const i = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t]
                      , a = n.name.match(r);
                    if (a && a.length > 1) {
                        const e = a[1];
                        let t = i[e];
                        t || (i[e] = t = []),
                        t.push(n)
                    }
                }
                const a = [];
                for (const e in i)
                    a.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                return a
            }
            static parseAnimation(e, t) {
                if (!e)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(e, t, n, i, r) {
                    if (0 !== n.length) {
                        const a = []
                          , s = [];
                        ul(n, a, s, i),
                        0 !== a.length && r.push(new e(t,a,s))
                    }
                }
                  , i = []
                  , r = e.name || "default"
                  , a = e.fps || 30
                  , s = e.blendMode;
                let o = e.length || -1;
                const l = e.hierarchy || [];
                for (let e = 0; e < l.length; e++) {
                    const r = l[e].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const e = {};
                            let t;
                            for (t = 0; t < r.length; t++)
                                if (r[t].morphTargets)
                                    for (let n = 0; n < r[t].morphTargets.length; n++)
                                        e[r[t].morphTargets[n]] = -1;
                            for (const n in e) {
                                const e = []
                                  , a = [];
                                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                    const i = r[t];
                                    e.push(i.time),
                                    a.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new _l(".morphTargetInfluence[" + n + "]",e,a))
                            }
                            o = e.length * a
                        } else {
                            const a = ".bones[" + t[e].name + "]";
                            n(Sl, a + ".position", r, "pos", i),
                            n(bl, a + ".quaternion", r, "rot", i),
                            n(Sl, a + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length)
                    return null;
                return new this(r,o,i,s)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e,
                this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++)
                    e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++)
                    e.push(this.tracks[t].clone());
                return new this.constructor(this.name,this.duration,e,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function Tl(e) {
            if (void 0 === e.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return _l;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Sl;
                case "color":
                    return yl;
                case "quaternion":
                    return bl;
                case "bool":
                case "boolean":
                    return wl;
                case "string":
                    return El
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = []
                  , n = [];
                ul(e.keys, t, n, "value"),
                e.times = t,
                e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
        }
        const kl = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled)
                    return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class Cl {
            constructor(e, t, n) {
                const i = this;
                let r, a = !1, s = 0, o = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = e,
                this.onProgress = t,
                this.onError = n,
                this.itemStart = function(e) {
                    o++,
                    !1 === a && void 0 !== i.onStart && i.onStart(e, s, o),
                    a = !0
                }
                ,
                this.itemEnd = function(e) {
                    s++,
                    void 0 !== i.onProgress && i.onProgress(e, s, o),
                    s === o && (a = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(e) {
                    void 0 !== i.onError && i.onError(e)
                }
                ,
                this.resolveURL = function(e) {
                    return r ? r(e) : e
                }
                ,
                this.setURLModifier = function(e) {
                    return r = e,
                    this
                }
                ,
                this.addHandler = function(e, t) {
                    return l.push(e, t),
                    this
                }
                ,
                this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2),
                    this
                }
                ,
                this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t]
                          , i = l[t + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(e))
                            return i
                    }
                    return null
                }
            }
        }
        const Al = new Cl;
        class Pl {
            constructor(e) {
                this.manager = void 0 !== e ? e : Al,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(e, i, t, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e,
                this
            }
            setWithCredentials(e) {
                return this.withCredentials = e,
                this
            }
            setPath(e) {
                return this.path = e,
                this
            }
            setResourcePath(e) {
                return this.resourcePath = e,
                this
            }
            setRequestHeader(e) {
                return this.requestHeader = e,
                this
            }
        }
        Pl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Rl = {};
        class Ll extends Error {
            constructor(e, t) {
                super(e),
                this.response = t
            }
        }
        class Il extends Pl {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = kl.get(e);
                if (void 0 !== r)
                    return this.manager.itemStart(e),
                    setTimeout((()=>{
                        t && t(r),
                        this.manager.itemEnd(e)
                    }
                    ), 0),
                    r;
                if (void 0 !== Rl[e])
                    return void Rl[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                Rl[e] = [],
                Rl[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                const a = new Request(e,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , s = this.mimeType
                  , o = this.responseType;
                fetch(a).then((t=>{
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                            return t;
                        const n = Rl[e]
                          , i = t.body.getReader()
                          , r = t.headers.get("Content-Length") || t.headers.get("X-File-Size")
                          , a = r ? parseInt(r) : 0
                          , s = 0 !== a;
                        let o = 0;
                        const l = new ReadableStream({
                            start(e) {
                                !function t() {
                                    i.read().then((({done: i, value: r})=>{
                                        if (i)
                                            e.close();
                                        else {
                                            o += r.byteLength;
                                            const i = new ProgressEvent("progress",{
                                                lengthComputable: s,
                                                loaded: o,
                                                total: a
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(i)
                                            }
                                            e.enqueue(r),
                                            t()
                                        }
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new Ll(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
                }
                )).then((e=>{
                    switch (o) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((e=>(new DOMParser).parseFromString(e, s)));
                    case "json":
                        return e.json();
                    default:
                        if (void 0 === s)
                            return e.text();
                        {
                            const t = /charset="?([^;"\s]*)"?/i.exec(s)
                              , n = t && t[1] ? t[1].toLowerCase() : void 0
                              , i = new TextDecoder(n);
                            return e.arrayBuffer().then((e=>i.decode(e)))
                        }
                    }
                }
                )).then((t=>{
                    kl.add(e, t);
                    const n = Rl[e];
                    delete Rl[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onLoad && i.onLoad(t)
                    }
                }
                )).catch((t=>{
                    const n = Rl[e];
                    if (void 0 === n)
                        throw this.manager.itemError(e),
                        t;
                    delete Rl[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    this.manager.itemError(e)
                }
                )).finally((()=>{
                    this.manager.itemEnd(e)
                }
                )),
                this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e,
                this
            }
            setMimeType(e) {
                return this.mimeType = e,
                this
            }
        }
        class Nl extends Pl {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = this
                  , a = kl.get(e);
                if (void 0 !== a)
                    return r.manager.itemStart(e),
                    setTimeout((function() {
                        t && t(a),
                        r.manager.itemEnd(e)
                    }
                    ), 0),
                    a;
                const s = Fe("img");
                function o() {
                    c(),
                    kl.add(e, this),
                    t && t(this),
                    r.manager.itemEnd(e)
                }
                function l(t) {
                    c(),
                    i && i(t),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                function c() {
                    s.removeEventListener("load", o, !1),
                    s.removeEventListener("error", l, !1)
                }
                return s.addEventListener("load", o, !1),
                s.addEventListener("error", l, !1),
                "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                r.manager.itemStart(e),
                s.src = e,
                s
            }
        }
        class Ul extends Pl {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new it
                  , a = new Nl(this.manager);
                return a.setCrossOrigin(this.crossOrigin),
                a.setPath(this.path),
                a.load(e, (function(e) {
                    r.image = e,
                    r.needsUpdate = !0,
                    void 0 !== t && t(r)
                }
                ), n, i),
                r
            }
        }
        class Dl extends un {
            constructor(e, t=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new An(e),
                this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t),
                this.color.copy(e.color),
                this.intensity = e.intensity,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(),
                t.object.intensity = this.intensity,
                void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (t.object.distance = this.distance),
                void 0 !== this.angle && (t.object.angle = this.angle),
                void 0 !== this.decay && (t.object.decay = this.decay),
                void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                t
            }
        }
        class Bl extends Dl {
            constructor(e, t, n) {
                super(e, n),
                this.isHemisphereLight = !0,
                this.type = "HemisphereLight",
                this.position.copy(un.DEFAULT_UP),
                this.updateMatrix(),
                this.groundColor = new An(t)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.groundColor.copy(e.groundColor),
                this
            }
        }
        const Ol = new Ft
          , zl = new ht
          , Fl = new ht;
        class Wl {
            constructor(e) {
                this.camera = e,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new De(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Ft,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Ri,
                this._frameExtents = new De(1,1),
                this._viewportCount = 1,
                this._viewports = [new rt(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = this.matrix;
                zl.setFromMatrixPosition(e.matrixWorld),
                t.position.copy(zl),
                Fl.setFromMatrixPosition(e.target.matrixWorld),
                t.lookAt(Fl),
                t.updateMatrixWorld(),
                Ol.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Ol),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(Ol)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(),
                this.bias = e.bias,
                this.radius = e.radius,
                this.mapSize.copy(e.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 0 !== this.bias && (e.bias = this.bias),
                0 !== this.normalBias && (e.normalBias = this.normalBias),
                1 !== this.radius && (e.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                e.camera = this.camera.toJSON(!1).object,
                delete e.camera.matrix,
                e
            }
        }
        class Hl extends Wl {
            constructor() {
                super(new _i(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = 2 * Te * e.angle * this.focus
                  , i = this.mapSize.width / this.mapSize.height
                  , r = e.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
                t.aspect = i,
                t.far = r,
                t.updateProjectionMatrix()),
                super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e),
                this.focus = e.focus,
                this
            }
        }
        class Vl extends Dl {
            constructor(e, t, n=0, i=Math.PI / 3, r=0, a=2) {
                super(e, t),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(un.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new un,
                this.distance = n,
                this.angle = i,
                this.penumbra = r,
                this.decay = a,
                this.map = null,
                this.shadow = new Hl
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.angle = e.angle,
                this.penumbra = e.penumbra,
                this.decay = e.decay,
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        const Gl = new Ft
          , jl = new ht
          , Xl = new ht;
        class ql extends Wl {
            constructor() {
                super(new _i(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new De(4,2),
                this._viewportCount = 6,
                this._viewports = [new rt(2,1,1,1), new rt(0,1,1,1), new rt(3,1,1,1), new rt(1,1,1,1), new rt(3,0,1,1), new rt(1,0,1,1)],
                this._cubeDirections = [new ht(1,0,0), new ht(-1,0,0), new ht(0,0,1), new ht(0,0,-1), new ht(0,1,0), new ht(0,-1,0)],
                this._cubeUps = [new ht(0,1,0), new ht(0,1,0), new ht(0,1,0), new ht(0,1,0), new ht(0,0,1), new ht(0,0,-1)]
            }
            updateMatrices(e, t=0) {
                const n = this.camera
                  , i = this.matrix
                  , r = e.distance || n.far;
                r !== n.far && (n.far = r,
                n.updateProjectionMatrix()),
                jl.setFromMatrixPosition(e.matrixWorld),
                n.position.copy(jl),
                Xl.copy(n.position),
                Xl.add(this._cubeDirections[t]),
                n.up.copy(this._cubeUps[t]),
                n.lookAt(Xl),
                n.updateMatrixWorld(),
                i.makeTranslation(-jl.x, -jl.y, -jl.z),
                Gl.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Gl)
            }
        }
        class Yl extends Dl {
            constructor(e, t, n=0, i=2) {
                super(e, t),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = n,
                this.decay = i,
                this.shadow = new ql
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.decay = e.decay,
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class Zl extends Wl {
            constructor() {
                super(new ji(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class Kl extends Dl {
            constructor(e, t) {
                super(e, t),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(un.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new un,
                this.shadow = new Zl
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e),
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class Jl {
            static decodeText(e) {
                if ("undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(e);
                let t = "";
                for (let n = 0, i = e.length; n < i; n++)
                    t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class Ql extends Pl {
            constructor(e) {
                super(e),
                this.isImageBitmapLoader = !0,
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e,
                this
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = this
                  , a = kl.get(e);
                if (void 0 !== a)
                    return r.manager.itemStart(e),
                    a.then ? void a.then((n=>{
                        t && t(n),
                        r.manager.itemEnd(e)
                    }
                    )).catch((e=>{
                        i && i(e)
                    }
                    )) : (setTimeout((function() {
                        t && t(a),
                        r.manager.itemEnd(e)
                    }
                    ), 0),
                    a);
                const s = {};
                s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                s.headers = this.requestHeader;
                const o = fetch(e, s).then((function(e) {
                    return e.blob()
                }
                )).then((function(e) {
                    return createImageBitmap(e, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    return kl.add(e, n),
                    t && t(n),
                    r.manager.itemEnd(e),
                    n
                }
                )).catch((function(t) {
                    i && i(t),
                    kl.remove(e),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                ));
                kl.add(e, o),
                r.manager.itemStart(e)
            }
        }
        const $l = "\\[\\]\\.:\\/"
          , ec = new RegExp("[" + $l + "]","g")
          , tc = "[^" + $l + "]"
          , nc = "[^" + $l.replace("\\.", "") + "]"
          , ic = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", tc) + /(WCOD+)?/.source.replace("WCOD", nc) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tc) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tc) + "$")
          , rc = ["material", "materials", "bones", "map"];
        class ac {
            constructor(e, t, n) {
                this.path = t,
                this.parsedPath = n || ac.parseTrackName(t),
                this.node = ac.findNode(e, this.parsedPath.nodeName),
                this.rootNode = e,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new ac.Composite(e,t,n) : new ac(e,t,n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(ec, "")
            }
            static parseTrackName(e) {
                const t = ic.exec(e);
                if (null === t)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const e = n.nodeName.substring(i + 1);
                    -1 !== rc.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                    return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n)
                        return n
                }
                if (e.children) {
                    const n = function(e) {
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            if (r.name === t || r.uuid === t)
                                return r;
                            const a = n(r.children);
                            if (a)
                                return a
                        }
                        return null
                    }
                      , i = n(e.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    e[t++] = n[i]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(),
                this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(),
                this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath
                  , n = t.objectName
                  , i = t.propertyName;
                let r = t.propertyIndex;
                if (e || (e = ac.findNode(this.rootNode, t.nodeName),
                this.node = e),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !e)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let i = t.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++)
                            if (e[t].name === i) {
                                i = t;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        e = e.material.map;
                        break;
                    default:
                        if (void 0 === e[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === e[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[i]
                    }
                }
                const a = e[i];
                if (void 0 === a) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                }
                let s = this.Versioning.None;
                this.targetObject = e,
                void 0 !== e.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!e.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement,
                    this.resolvedProperty = a,
                    this.propertyIndex = r
                } else
                    void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray,
                    this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray,
                    this.resolvedProperty = a) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[o],
                this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        ac.Composite = class {
            constructor(e, t, n) {
                const i = n || ac.parseTrackName(t);
                this._targetGroup = e,
                this._bindings = e.subscribe_(t, i)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].unbind()
            }
        }
        ,
        ac.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        ac.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        ac.prototype.GetterByBindingType = [ac.prototype._getValue_direct, ac.prototype._getValue_array, ac.prototype._getValue_arrayElement, ac.prototype._getValue_toArray],
        ac.prototype.SetterByBindingTypeAndVersioning = [[ac.prototype._setValue_direct, ac.prototype._setValue_direct_setNeedsUpdate, ac.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ac.prototype._setValue_array, ac.prototype._setValue_array_setNeedsUpdate, ac.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ac.prototype._setValue_arrayElement, ac.prototype._setValue_arrayElement_setNeedsUpdate, ac.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ac.prototype._setValue_fromArray, ac.prototype._setValue_fromArray_setNeedsUpdate, ac.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        new Float32Array(1);
        class sc {
            constructor(e, t, n=0, i=1 / 0) {
                this.ray = new zt(e,t),
                this.near = n,
                this.far = i,
                this.camera = null,
                this.layers = new Jt,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            intersectObject(e, t=!0, n=[]) {
                return lc(e, this, n, t),
                n.sort(oc),
                n
            }
            intersectObjects(e, t=!0, n=[]) {
                for (let i = 0, r = e.length; i < r; i++)
                    lc(e[i], this, n, t);
                return n.sort(oc),
                n
            }
        }
        function oc(e, t) {
            return e.distance - t.distance
        }
        function lc(e, t, n, i) {
            if (e.layers.test(t.layers) && e.raycast(t, n),
            !0 === i) {
                const i = e.children;
                for (let e = 0, r = i.length; e < r; e++)
                    lc(i[e], t, n, !0)
            }
        }
        class cc {
            constructor(e=1, t=0, n=0) {
                return this.radius = e,
                this.phi = t,
                this.theta = n,
                this
            }
            set(e, t, n) {
                return this.radius = e,
                this.phi = t,
                this.theta = n,
                this
            }
            copy(e) {
                return this.radius = e.radius,
                this.phi = e.phi,
                this.theta = e.theta,
                this
            }
            makeSafe() {
                const e = 1e-6;
                return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
                this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n),
                0 === this.radius ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(e, n),
                this.phi = Math.acos(Ce(t / this.radius, -1, 1))),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class hc {
            constructor() {
                this.type = "ShapePath",
                this.color = new An,
                this.subPaths = [],
                this.currentPath = null
            }
            moveTo(e, t) {
                return this.currentPath = new To,
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(e, t),
                this
            }
            lineTo(e, t) {
                return this.currentPath.lineTo(e, t),
                this
            }
            quadraticCurveTo(e, t, n, i) {
                return this.currentPath.quadraticCurveTo(e, t, n, i),
                this
            }
            bezierCurveTo(e, t, n, i, r, a) {
                return this.currentPath.bezierCurveTo(e, t, n, i, r, a),
                this
            }
            splineThru(e) {
                return this.currentPath.splineThru(e),
                this
            }
            toShapes(e) {
                function t(e, t) {
                    const n = t.length;
                    let i = !1;
                    for (let r = n - 1, a = 0; a < n; r = a++) {
                        let n = t[r]
                          , s = t[a]
                          , o = s.x - n.x
                          , l = s.y - n.y;
                        if (Math.abs(l) > Number.EPSILON) {
                            if (l < 0 && (n = t[a],
                            o = -o,
                            s = t[r],
                            l = -l),
                            e.y < n.y || e.y > s.y)
                                continue;
                            if (e.y === n.y) {
                                if (e.x === n.x)
                                    return !0
                            } else {
                                const t = l * (e.x - n.x) - o * (e.y - n.y);
                                if (0 === t)
                                    return !0;
                                if (t < 0)
                                    continue;
                                i = !i
                            }
                        } else {
                            if (e.y !== n.y)
                                continue;
                            if (s.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= s.x)
                                return !0
                        }
                    }
                    return i
                }
                const n = el.isClockWise
                  , i = this.subPaths;
                if (0 === i.length)
                    return [];
                let r, a, s;
                const o = [];
                if (1 === i.length)
                    return a = i[0],
                    s = new Co,
                    s.curves = a.curves,
                    o.push(s),
                    o;
                let l = !n(i[0].getPoints());
                l = e ? !l : l;
                const c = []
                  , h = [];
                let d, u, p = [], f = 0;
                h[f] = void 0,
                p[f] = [];
                for (let t = 0, s = i.length; t < s; t++)
                    a = i[t],
                    d = a.getPoints(),
                    r = n(d),
                    r = e ? !r : r,
                    r ? (!l && h[f] && f++,
                    h[f] = {
                        s: new Co,
                        p: d
                    },
                    h[f].s.curves = a.curves,
                    l && f++,
                    p[f] = []) : p[f].push({
                        h: a,
                        p: d[0]
                    });
                if (!h[0])
                    return function(e) {
                        const t = [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n]
                              , r = new Co;
                            r.curves = i.curves,
                            t.push(r)
                        }
                        return t
                    }(i);
                if (h.length > 1) {
                    let e = !1
                      , n = 0;
                    for (let e = 0, t = h.length; e < t; e++)
                        c[e] = [];
                    for (let i = 0, r = h.length; i < r; i++) {
                        const r = p[i];
                        for (let a = 0; a < r.length; a++) {
                            const s = r[a];
                            let o = !0;
                            for (let r = 0; r < h.length; r++)
                                t(s.p, h[r].p) && (i !== r && n++,
                                o ? (o = !1,
                                c[r].push(s)) : e = !0);
                            o && c[i].push(s)
                        }
                    }
                    n > 0 && !1 === e && (p = c)
                }
                for (let e = 0, t = h.length; e < t; e++) {
                    s = h[e].s,
                    o.push(s),
                    u = p[e];
                    for (let e = 0, t = u.length; e < t; e++)
                        s.holes.push(u[e].h)
                }
                return o
            }
        }
        var dc;
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: m
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = m),
        function(e) {
            e[e.ImperialUnitsEnabled = 0] = "ImperialUnitsEnabled",
            e[e.ResetHintEnabled = 1] = "ResetHintEnabled",
            e[e.GhostCarEnabled = 2] = "GhostCarEnabled",
            e[e.CockpitCameraToggle = 3] = "CockpitCameraToggle",
            e[e.CheckpointsPosition = 4] = "CheckpointsPosition",
            e[e.TimerPosition = 5] = "TimerPosition",
            e[e.SpeedometerPosition = 6] = "SpeedometerPosition",
            e[e.Language = 7] = "Language",
            e[e.CarShadowQuality = 8] = "CarShadowQuality",
            e[e.TrackShadowEnabled = 9] = "TrackShadowEnabled",
            e[e.CloudsEnabled = 10] = "CloudsEnabled",
            e[e.ParticlesEnabled = 11] = "ParticlesEnabled",
            e[e.SkidmarksEnabled = 12] = "SkidmarksEnabled",
            e[e.RenderScale = 13] = "RenderScale",
            e[e.Antialiasing = 14] = "Antialiasing",
            e[e.SoundEffectVolume = 15] = "SoundEffectVolume",
            e[e.MusicVolume = 16] = "MusicVolume",
            e[e.CheckpointVolume = 17] = "CheckpointVolume"
        }(dc || (dc = {}));
        const uc = dc;
        var pc, fc, mc, gc, vc, wc, yc, _c, xc, bc = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Ec = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        fc = new WeakMap,
        mc = new WeakMap,
        gc = new WeakMap,
        vc = new WeakMap,
        wc = new WeakMap,
        pc = new WeakSet,
        yc = function e(t, n) {
            if (null == this.context)
                n(null);
            else if (0 == t.length)
                n(null);
            else {
                const i = t[0]
                  , r = new XMLHttpRequest;
                r.open("GET", i, !0),
                r.responseType = "arraybuffer",
                r.onload = ()=>{
                    this.context.decodeAudioData(r.response, (e=>{
                        n(e)
                    }
                    ), (()=>{
                        Ec(this, pc, "m", e).call(this, t.slice(1), n)
                    }
                    ))
                }
                ,
                r.send()
            }
        }
        ,
        _c = function(e) {
            var t;
            let n = Math.min(Math.max(e.getSettingFloat(uc.SoundEffectVolume), 0), 1);
            Number.isNaN(n) && (n = 0),
            null == Ec(this, wc, "f") && null != this.context ? (bc(this, wc, this.context.createGain(), "f"),
            Ec(this, wc, "f").gain.value = n,
            Ec(this, wc, "f").connect(this.context.destination)) : null === (t = Ec(this, wc, "f")) || void 0 === t || t.gain.setTargetAtTime(n, 0, .1)
        }
        ,
        xc = function(e, t, n) {
            if (t) {
                if (null == Ec(this, gc, "f")) {
                    const e = this.getBuffer("music");
                    if (null != e && null != this.context) {
                        const t = this.context.createBufferSource();
                        t.buffer = e,
                        t.loop = !0;
                        const n = this.context.createGain();
                        n.gain.value = 0,
                        t.connect(n),
                        n.connect(this.context.destination),
                        t.start(0),
                        bc(this, gc, {
                            source: t,
                            gain: n
                        }, "f")
                    }
                } else {
                    let e = Math.min(Math.max(n.getSettingFloat(uc.MusicVolume), 0), 1);
                    Number.isNaN(e) && (e = 0),
                    Ec(this, gc, "f").gain.gain.setTargetAtTime(.25 * e, 0, .5)
                }
                bc(this, vc, 0, "f")
            } else
                null != Ec(this, gc, "f") && (Ec(this, gc, "f").gain.gain.setTargetAtTime(0, 0, .5),
                Ec(this, vc, "f") >= 5 ? (Ec(this, gc, "f").source.stop(),
                bc(this, gc, null, "f")) : bc(this, vc, Ec(this, vc, "f") + e, "f"))
        }
        ;
        const Sc = class {
            constructor(e) {
                pc.add(this),
                fc.set(this, void 0),
                this.context = null,
                mc.set(this, new Map),
                gc.set(this, null),
                vc.set(this, 0),
                wc.set(this, null),
                bc(this, fc, e, "f");
                try {
                    const e = new (window.AudioContext || window.webkitAudioContext);
                    if ("running" != e.state) {
                        const t = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "pointerup", "touchend", "keydown", "keyup"]
                          , n = ()=>{
                            e.resume();
                            for (let e = 0; e < t.length; ++e)
                                window.removeEventListener(t[e], n)
                        }
                        ;
                        for (let e = 0; e < t.length; ++e)
                            window.addEventListener(t[e], n)
                    }
                    this.context = e
                } catch (e) {
                    this.context = null,
                    console.error("Failed to create audio context: " + e)
                }
            }
            get destinationSfx() {
                return Ec(this, wc, "f")
            }
            get destinationRaw() {
                var e, t;
                return null !== (t = null === (e = this.context) || void 0 === e ? void 0 : e.destination) && void 0 !== t ? t : null
            }
            load(e, t) {
                Ec(this, fc, "f").addResource(),
                Ec(this, pc, "m", yc).call(this, t, (t=>{
                    Ec(this, fc, "f").loadedResource(),
                    null == t ? (console.warn('Audio "' + e + '" failed to load'),
                    Ec(this, mc, "f").set(e, null)) : Ec(this, mc, "f").set(e, t)
                }
                ))
            }
            getBuffer(e) {
                return null == this.context ? null : Ec(this, mc, "f").has(e) ? Ec(this, mc, "f").get(e) : null
            }
            playUIClick() {
                const e = this.getBuffer("click");
                if (null != e && null != this.context && null != this.destinationSfx) {
                    const t = this.context.createBufferSource();
                    t.buffer = e;
                    const n = this.context.createGain();
                    n.gain.value = .0075,
                    t.connect(n),
                    n.connect(this.destinationSfx),
                    t.start(0)
                }
            }
            refreshListener(e) {
                if (null != this.context) {
                    const t = new ht
                      , n = new ct
                      , i = new ht;
                    e.camera.matrix.decompose(t, n, i);
                    const r = this.context.listener;
                    r.positionX && r.positionY && r.positionZ ? (r.positionX.value = t.x,
                    r.positionY.value = t.y,
                    r.positionZ.value = t.z) : r.setPosition(t.x, t.y, t.z);
                    const a = new ht(0,0,-1);
                    a.applyQuaternion(n);
                    const s = new ht(0,1,0);
                    s.applyQuaternion(n),
                    r.forwardX && r.forwardY && r.forwardZ && r.upX && r.upY && r.upZ ? (r.forwardX.value = a.x,
                    r.forwardY.value = a.y,
                    r.forwardZ.value = a.z,
                    r.upX.value = s.x,
                    r.upY.value = s.y,
                    r.upZ.value = s.z) : r.setOrientation(a.x, a.y, a.z, s.x, s.y, s.z)
                }
            }
            update(e, t, n, i) {
                this.refreshListener(n),
                Ec(this, pc, "m", _c).call(this, i),
                Ec(this, pc, "m", xc).call(this, e, t, i)
            }
        }
        ;
        function Mc(e, t=!1) {
            const n = null !== e[0].index
              , i = new Set(Object.keys(e[0].attributes))
              , r = new Set(Object.keys(e[0].morphAttributes))
              , a = {}
              , s = {}
              , o = e[0].morphTargetsRelative
              , l = new qn;
            let c = 0;
            for (let h = 0; h < e.length; ++h) {
                const d = e[h];
                let u = 0;
                if (n !== (null !== d.index))
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),
                    null;
                for (const e in d.attributes) {
                    if (!i.has(e))
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + e + '" attribute exists among all geometries, or in none of them.'),
                        null;
                    void 0 === a[e] && (a[e] = []),
                    a[e].push(d.attributes[e]),
                    u++
                }
                if (u !== i.size)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."),
                    null;
                if (o !== d.morphTargetsRelative)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."),
                    null;
                for (const e in d.morphAttributes) {
                    if (!r.has(e))
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."),
                        null;
                    void 0 === s[e] && (s[e] = []),
                    s[e].push(d.morphAttributes[e])
                }
                if (t) {
                    let e;
                    if (n)
                        e = d.index.count;
                    else {
                        if (void 0 === d.attributes.position)
                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"),
                            null;
                        e = d.attributes.position.count
                    }
                    l.addGroup(c, e, h),
                    c += e
                }
            }
            if (n) {
                let t = 0;
                const n = [];
                for (let i = 0; i < e.length; ++i) {
                    const r = e[i].index;
                    for (let e = 0; e < r.count; ++e)
                        n.push(r.getX(e) + t);
                    t += e[i].attributes.position.count
                }
                l.setIndex(n)
            }
            for (const e in a) {
                const t = Tc(a[e]);
                if (!t)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " attribute."),
                    null;
                l.setAttribute(e, t)
            }
            for (const e in s) {
                const t = s[e][0].length;
                if (0 === t)
                    break;
                l.morphAttributes = l.morphAttributes || {},
                l.morphAttributes[e] = [];
                for (let n = 0; n < t; ++n) {
                    const t = [];
                    for (let i = 0; i < s[e].length; ++i)
                        t.push(s[e][i][n]);
                    const i = Tc(t);
                    if (!i)
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " morphAttribute."),
                        null;
                    l.morphAttributes[e].push(i)
                }
            }
            return l
        }
        function Tc(e) {
            let t, n, i, r = -1, a = 0;
            for (let s = 0; s < e.length; ++s) {
                const o = e[s];
                if (o.isInterleavedBufferAttribute)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),
                    null;
                if (void 0 === t && (t = o.array.constructor),
                t !== o.array.constructor)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
                    null;
                if (void 0 === n && (n = o.itemSize),
                n !== o.itemSize)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
                    null;
                if (void 0 === i && (i = o.normalized),
                i !== o.normalized)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
                    null;
                if (-1 === r && (r = o.gpuType),
                r !== o.gpuType)
                    return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
                    null;
                a += o.array.length
            }
            const s = new t(a);
            let o = 0;
            for (let t = 0; t < e.length; ++t)
                s.set(e[t].array, o),
                o += e[t].array.length;
            const l = new Dn(s,n,i);
            return void 0 !== r && (l.gpuType = r),
            l
        }
        function kc(e, t) {
            if (0 === t)
                return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                e;
            if (2 === t || 1 === t) {
                let n = e.getIndex();
                if (null === n) {
                    const t = []
                      , i = e.getAttribute("position");
                    if (void 0 === i)
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                        e;
                    for (let e = 0; e < i.count; e++)
                        t.push(e);
                    e.setIndex(t),
                    n = e.getIndex()
                }
                const i = n.count - 2
                  , r = [];
                if (2 === t)
                    for (let e = 1; e <= i; e++)
                        r.push(n.getX(0)),
                        r.push(n.getX(e)),
                        r.push(n.getX(e + 1));
                else
                    for (let e = 0; e < i; e++)
                        e % 2 == 0 ? (r.push(n.getX(e)),
                        r.push(n.getX(e + 1)),
                        r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)),
                        r.push(n.getX(e + 1)),
                        r.push(n.getX(e)));
                r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const a = e.clone();
                return a.setIndex(r),
                a.clearGroups(),
                a
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t),
            e
        }
        class Cc extends Pl {
            constructor(e) {
                super(e),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(e) {
                    return new Nc(e)
                }
                )),
                this.register((function(e) {
                    return new Vc(e)
                }
                )),
                this.register((function(e) {
                    return new Gc(e)
                }
                )),
                this.register((function(e) {
                    return new jc(e)
                }
                )),
                this.register((function(e) {
                    return new Dc(e)
                }
                )),
                this.register((function(e) {
                    return new Bc(e)
                }
                )),
                this.register((function(e) {
                    return new Oc(e)
                }
                )),
                this.register((function(e) {
                    return new zc(e)
                }
                )),
                this.register((function(e) {
                    return new Ic(e)
                }
                )),
                this.register((function(e) {
                    return new Fc(e)
                }
                )),
                this.register((function(e) {
                    return new Uc(e)
                }
                )),
                this.register((function(e) {
                    return new Hc(e)
                }
                )),
                this.register((function(e) {
                    return new Wc(e)
                }
                )),
                this.register((function(e) {
                    return new Rc(e)
                }
                )),
                this.register((function(e) {
                    return new Xc(e)
                }
                )),
                this.register((function(e) {
                    return new qc(e)
                }
                ))
            }
            load(e, t, n, i) {
                const r = this;
                let a;
                if ("" !== this.resourcePath)
                    a = this.resourcePath;
                else if ("" !== this.path) {
                    const t = Jl.extractUrlBase(e);
                    a = Jl.resolveURL(t, this.path)
                } else
                    a = Jl.extractUrlBase(e);
                this.manager.itemStart(e);
                const s = function(t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                  , o = new Il(this.manager);
                o.setPath(this.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(e, (function(n) {
                    try {
                        r.parse(n, a, (function(n) {
                            t(n),
                            r.manager.itemEnd(e)
                        }
                        ), s)
                    } catch (e) {
                        s(e)
                    }
                }
                ), n, s)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e,
                this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e,
                this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                this
            }
            parse(e, t, n, i) {
                let r;
                const a = {}
                  , s = {}
                  , o = new TextDecoder;
                if ("string" == typeof e)
                    r = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (o.decode(new Uint8Array(e,0,4)) === Yc) {
                        try {
                            a[Pc.KHR_BINARY_GLTF] = new Jc(e)
                        } catch (e) {
                            return void (i && i(e))
                        }
                        r = JSON.parse(a[Pc.KHR_BINARY_GLTF].content)
                    } else
                        r = JSON.parse(o.decode(e))
                } else
                    r = e;
                if (void 0 === r.asset || r.asset.version[0] < 2)
                    return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new bh(r,{
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let e = 0; e < this.pluginCallbacks.length; e++) {
                    const t = this.pluginCallbacks[e](l);
                    t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                    s[t.name] = t,
                    a[t.name] = !0
                }
                if (r.extensionsUsed)
                    for (let e = 0; e < r.extensionsUsed.length; ++e) {
                        const t = r.extensionsUsed[e]
                          , n = r.extensionsRequired || [];
                        switch (t) {
                        case Pc.KHR_MATERIALS_UNLIT:
                            a[t] = new Lc;
                            break;
                        case Pc.KHR_DRACO_MESH_COMPRESSION:
                            a[t] = new Qc(r,this.dracoLoader);
                            break;
                        case Pc.KHR_TEXTURE_TRANSFORM:
                            a[t] = new $c;
                            break;
                        case Pc.KHR_MESH_QUANTIZATION:
                            a[t] = new eh;
                            break;
                        default:
                            n.indexOf(t) >= 0 && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                        }
                    }
                l.setExtensions(a),
                l.setPlugins(s),
                l.parse(n, i)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(e, t, i, r)
                }
                ))
            }
        }
        function Ac() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const Pc = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class Rc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser
                  , t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser
                  , n = "light:" + e;
                let i = t.cache.get(n);
                if (i)
                    return i;
                const r = t.json
                  , a = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                let s;
                const o = new An(16777215);
                void 0 !== a.color && o.setRGB(a.color[0], a.color[1], a.color[2], ce);
                const l = void 0 !== a.range ? a.range : 0;
                switch (a.type) {
                case "directional":
                    s = new Kl(o),
                    s.target.position.set(0, 0, -1),
                    s.add(s.target);
                    break;
                case "point":
                    s = new Yl(o),
                    s.distance = l;
                    break;
                case "spot":
                    s = new Vl(o),
                    s.distance = l,
                    a.spot = a.spot || {},
                    a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0,
                    a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4,
                    s.angle = a.spot.outerConeAngle,
                    s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle,
                    s.target.position.set(0, 0, -1),
                    s.add(s.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                }
                return s.position.set(0, 0, 0),
                s.decay = 2,
                gh(s, a),
                void 0 !== a.intensity && (s.intensity = a.intensity),
                s.name = t.createUniqueName(a.name || "light_" + e),
                i = Promise.resolve(s),
                t.cache.add(n, i),
                i
            }
            getDependency(e, t) {
                if ("light" === e)
                    return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this
                  , n = this.parser
                  , i = n.json.nodes[e]
                  , r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(e) {
                    return n._getNodeRef(t.cache, r, e)
                }
                ))
            }
        }
        class Lc {
            constructor() {
                this.name = Pc.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return In
            }
            extendParams(e, t, n) {
                const i = [];
                e.color = new An(1,1,1),
                e.opacity = 1;
                const r = t.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const t = r.baseColorFactor;
                        e.color.setRGB(t[0], t[1], t[2], ce),
                        e.opacity = t[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, le))
                }
                return Promise.all(i)
            }
        }
        class Ic {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (t.emissiveIntensity = i),
                Promise.resolve()
            }
        }
        class Nc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor),
                void 0 !== a.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
                void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
                void 0 !== a.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)),
                void 0 !== a.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)),
                void 0 !== a.clearcoatNormalTexture.scale)) {
                    const e = a.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new De(e,e)
                }
                return Promise.all(r)
            }
        }
        class Uc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor),
                void 0 !== a.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
                void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor),
                void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
                void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
                void 0 !== a.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)),
                Promise.all(r)
            }
        }
        class Dc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [];
                t.sheenColor = new An(0,0,0),
                t.sheenRoughness = 0,
                t.sheen = 1;
                const a = i.extensions[this.name];
                if (void 0 !== a.sheenColorFactor) {
                    const e = a.sheenColorFactor;
                    t.sheenColor.setRGB(e[0], e[1], e[2], ce)
                }
                return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor),
                void 0 !== a.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, le)),
                void 0 !== a.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)),
                Promise.all(r)
            }
        }
        class Bc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor),
                void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
                Promise.all(r)
            }
        }
        class Oc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0,
                void 0 !== a.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
                t.attenuationDistance = a.attenuationDistance || 1 / 0;
                const s = a.attenuationColor || [1, 1, 1];
                return t.attenuationColor = (new An).setRGB(s[0], s[1], s[2], ce),
                Promise.all(r)
            }
        }
        class zc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.ior = void 0 !== i.ior ? i.ior : 1.5,
                Promise.resolve()
            }
        }
        class Fc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1,
                void 0 !== a.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                const s = a.specularColorFactor || [1, 1, 1];
                return t.specularColor = (new An).setRGB(s[0], s[1], s[2], ce),
                void 0 !== a.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, le)),
                Promise.all(r)
            }
        }
        class Wc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.EXT_MATERIALS_BUMP
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1,
                void 0 !== a.bumpTexture && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)),
                Promise.all(r)
            }
        }
        class Hc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? sl : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , a = i.extensions[this.name];
                return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength),
                void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation),
                void 0 !== a.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
                Promise.all(r)
            }
        }
        class Vc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser
                  , n = t.json
                  , i = n.textures[e];
                if (!i.extensions || !i.extensions[this.name])
                    return null;
                const r = i.extensions[this.name]
                  , a = t.options.ktx2Loader;
                if (!a) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, r.source, a)
            }
        }
        class Gc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[e];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const a = r.extensions[t]
                  , s = i.images[a.source];
                let o = n.textureLoader;
                if (s.uri) {
                    const e = n.options.manager.getHandler(s.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(e, a.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class jc {
            constructor(e) {
                this.parser = e,
                this.name = Pc.EXT_TEXTURE_AVIF,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[e];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const a = r.extensions[t]
                  , s = i.images[a.source];
                let o = n.textureLoader;
                if (s.uri) {
                    const e = n.options.manager.getHandler(s.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(e, a.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class Xc {
            constructor(e) {
                this.name = Pc.EXT_MESHOPT_COMPRESSION,
                this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json
                  , n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name]
                      , i = this.parser.getDependency("buffer", e.buffer)
                      , r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function(t) {
                        const n = e.byteOffset || 0
                          , i = e.byteLength || 0
                          , a = e.count
                          , s = e.byteStride
                          , o = new Uint8Array(t,n,i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(a, s, o, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        }
                        )) : r.ready.then((function() {
                            const t = new ArrayBuffer(a * s);
                            return r.decodeGltfBuffer(new Uint8Array(t), a, s, o, e.mode, e.filter),
                            t
                        }
                        ))
                    }
                    ))
                }
                return null
            }
        }
        class qc {
            constructor(e) {
                this.name = Pc.EXT_MESH_GPU_INSTANCING,
                this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json
                  , n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const i = t.meshes[n.mesh];
                for (const e of i.primitives)
                    if (e.mode !== rh.TRIANGLES && e.mode !== rh.TRIANGLE_STRIP && e.mode !== rh.TRIANGLE_FAN && void 0 !== e.mode)
                        return null;
                const r = n.extensions[this.name].attributes
                  , a = []
                  , s = {};
                for (const e in r)
                    a.push(this.parser.getDependency("accessor", r[e]).then((t=>(s[e] = t,
                    s[e]))));
                return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
                Promise.all(a).then((e=>{
                    const t = e.pop()
                      , n = t.isGroup ? t.children : [t]
                      , i = e[0].count
                      , r = [];
                    for (const e of n) {
                        const t = new Ft
                          , n = new ht
                          , a = new ct
                          , o = new ht(1,1,1)
                          , l = new Vs(e.geometry,e.material,i);
                        for (let e = 0; e < i; e++)
                            s.TRANSLATION && n.fromBufferAttribute(s.TRANSLATION, e),
                            s.ROTATION && a.fromBufferAttribute(s.ROTATION, e),
                            s.SCALE && o.fromBufferAttribute(s.SCALE, e),
                            l.setMatrixAt(e, t.compose(n, a, o));
                        for (const t in s)
                            if ("_COLOR_0" === t) {
                                const e = s[t];
                                l.instanceColor = new Us(e.array,e.itemSize,e.normalized)
                            } else
                                "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]);
                        un.prototype.copy.call(l, e),
                        this.parser.assignFinalMaterial(l),
                        r.push(l)
                    }
                    return t.isGroup ? (t.clear(),
                    t.add(...r),
                    t) : r[0]
                }
                )))
            }
        }
        const Yc = "glTF"
          , Zc = 1313821514
          , Kc = 5130562;
        class Jc {
            constructor(e) {
                this.name = Pc.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const t = new DataView(e,0,12)
                  , n = new TextDecoder;
                if (this.header = {
                    magic: n.decode(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                },
                this.header.magic !== Yc)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const i = this.header.length - 12
                  , r = new DataView(e,12);
                let a = 0;
                for (; a < i; ) {
                    const t = r.getUint32(a, !0);
                    a += 4;
                    const i = r.getUint32(a, !0);
                    if (a += 4,
                    i === Zc) {
                        const i = new Uint8Array(e,12 + a,t);
                        this.content = n.decode(i)
                    } else if (i === Kc) {
                        const n = 12 + a;
                        this.body = e.slice(n, n + t)
                    }
                    a += t
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class Qc {
            constructor(e, t) {
                if (!t)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = Pc.KHR_DRACO_MESH_COMPRESSION,
                this.json = e,
                this.dracoLoader = t,
                this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json
                  , i = this.dracoLoader
                  , r = e.extensions[this.name].bufferView
                  , a = e.extensions[this.name].attributes
                  , s = {}
                  , o = {}
                  , l = {};
                for (const e in a) {
                    const t = ch[e] || e.toLowerCase();
                    s[t] = a[e]
                }
                for (const t in e.attributes) {
                    const i = ch[t] || t.toLowerCase();
                    if (void 0 !== a[t]) {
                        const r = n.accessors[e.attributes[t]]
                          , a = ah[r.componentType];
                        l[i] = a.name,
                        o[i] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", r).then((function(e) {
                    return new Promise((function(t, n) {
                        i.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t]
                                  , i = o[t];
                                void 0 !== i && (n.normalized = i)
                            }
                            t(e)
                        }
                        ), s, l, ce, n)
                    }
                    ))
                }
                ))
            }
        }
        class $c {
            constructor() {
                this.name = Pc.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(),
                void 0 !== t.texCoord && (e.channel = t.texCoord),
                void 0 !== t.offset && e.offset.fromArray(t.offset),
                void 0 !== t.rotation && (e.rotation = t.rotation),
                void 0 !== t.scale && e.repeat.fromArray(t.scale),
                e.needsUpdate = !0,
                e) : e
            }
        }
        class eh {
            constructor() {
                this.name = Pc.KHR_MESH_QUANTIZATION
            }
        }
        class th extends pl {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = e * i * 3 + i;
                for (let e = 0; e !== i; e++)
                    t[e] = n[r + e];
                return t
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , a = this.sampleValues
                  , s = this.valueSize
                  , o = 2 * s
                  , l = 3 * s
                  , c = i - t
                  , h = (n - t) / c
                  , d = h * h
                  , u = d * h
                  , p = e * l
                  , f = p - l
                  , m = -2 * u + 3 * d
                  , g = u - d
                  , v = 1 - m
                  , w = g - d + h;
                for (let e = 0; e !== s; e++) {
                    const t = a[f + e + s]
                      , n = a[f + e + o] * c
                      , i = a[p + e + s]
                      , l = a[p + e] * c;
                    r[e] = v * t + w * n + m * i + g * l
                }
                return r
            }
        }
        const nh = new ct;
        class ih extends th {
            interpolate_(e, t, n, i) {
                const r = super.interpolate_(e, t, n, i);
                return nh.fromArray(r).normalize().toArray(r),
                r
            }
        }
        const rh = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , ah = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , sh = {
            9728: I,
            9729: D,
            9984: N,
            9985: B,
            9986: U,
            9987: O
        }
          , oh = {
            33071: R,
            33648: L,
            10497: P
        }
          , lh = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , ch = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , hh = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , dh = {
            CUBICSPLINE: void 0,
            LINEAR: te,
            STEP: ee
        }
          , uh = "OPAQUE"
          , ph = "MASK"
          , fh = "BLEND";
        function mh(e, t, n) {
            for (const i in n.extensions)
                void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                t.userData.gltfExtensions[i] = n.extensions[i])
        }
        function gh(e, t) {
            void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }
        function vh(e, t) {
            if (e.updateMorphTargets(),
            void 0 !== t.weights)
                for (let n = 0, i = t.weights.length; n < i; n++)
                    e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, i = n.length; t < i; t++)
                        e.morphTargetDictionary[n[t]] = t
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function wh(e) {
            let t;
            const n = e.extensions && e.extensions[Pc.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + yh(n.attributes) : e.indices + ":" + yh(e.attributes) + ":" + e.mode,
            void 0 !== e.targets)
                for (let n = 0, i = e.targets.length; n < i; n++)
                    t += ":" + yh(e.targets[n]);
            return t
        }
        function yh(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let i = 0, r = n.length; i < r; i++)
                t += n[i] + ":" + e[n[i]] + ";";
            return t
        }
        function _h(e) {
            switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const xh = new Ft;
        class bh {
            constructor(e={}, t={}) {
                this.json = e,
                this.extensions = {},
                this.plugins = {},
                this.options = t,
                this.cache = new Ac,
                this.associations = new Map,
                this.primitiveCache = {},
                this.nodeCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                let n = !1
                  , i = !1
                  , r = -1;
                "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                i = navigator.userAgent.indexOf("Firefox") > -1,
                r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
                "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new Ul(this.options.manager) : this.textureLoader = new Ql(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new Il(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this
                  , i = this.json
                  , r = this.extensions;
                this.cache.removeAll(),
                this.nodeCache = {},
                this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(t) {
                    const a = {
                        scene: t[0][i.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return mh(r, a, i),
                    gh(a, i),
                    Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(a)
                    }
                    ))).then((function() {
                        e(a)
                    }
                    ))
                }
                )).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || []
                  , t = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n].joints;
                    for (let t = 0, n = i.length; t < n; t++)
                        e[i[t]].isBone = !0
                }
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                    void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                    void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1)
                    return n;
                const i = n.clone()
                  , r = (e,t)=>{
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [n,i] of e.children.entries())
                        r(i, t.children[n])
                }
                ;
                return r(n, i),
                i.name += "_instance_" + e.uses[t]++,
                i
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = e(t[n]);
                    if (i)
                        return i
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne((function(e) {
                            return e.loadNode && e.loadNode(t)
                        }
                        ));
                        break;
                    case "mesh":
                        i = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }
                        ));
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }
                        ));
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }
                        ));
                        break;
                    case "texture":
                        i = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }
                        ));
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }
                        ));
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne((function(n) {
                            return n != this && n.getDependency && n.getDependency(e, t)
                        }
                        )),
                        !i)
                            throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this
                      , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(i.map((function(t, i) {
                        return n.getDependency(e, i)
                    }
                    ))),
                    this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e]
                  , n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type)
                    throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e)
                    return Promise.resolve(this.extensions[Pc.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function(e, r) {
                    n.load(Jl.resolveURL(t.uri, i.path), e, void 0, (function() {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0
                      , i = t.byteOffset || 0;
                    return e.slice(i, i + n)
                }
                ))
            }
            loadAccessor(e) {
                const t = this
                  , n = this.json
                  , i = this.json.accessors[e];
                if (void 0 === i.bufferView && void 0 === i.sparse) {
                    const e = lh[i.type]
                      , t = ah[i.componentType]
                      , n = !0 === i.normalized
                      , r = new t(i.count * e);
                    return Promise.resolve(new Dn(r,e,n))
                }
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
                void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
                r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
                Promise.all(r).then((function(e) {
                    const r = e[0]
                      , a = lh[i.type]
                      , s = ah[i.componentType]
                      , o = s.BYTES_PER_ELEMENT
                      , l = o * a
                      , c = i.byteOffset || 0
                      , h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
                      , d = !0 === i.normalized;
                    let u, p;
                    if (h && h !== l) {
                        const e = Math.floor(c / h)
                          , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                        let l = t.cache.get(n);
                        l || (u = new s(r,e * h,i.count * h / o),
                        l = new vs(u,h / o),
                        t.cache.add(n, l)),
                        p = new ys(l,a,c % h / o,d)
                    } else
                        u = null === r ? new s(i.count * a) : new s(r,c,i.count * a),
                        p = new Dn(u,a,d);
                    if (void 0 !== i.sparse) {
                        const t = lh.SCALAR
                          , n = ah[i.sparse.indices.componentType]
                          , o = i.sparse.indices.byteOffset || 0
                          , l = i.sparse.values.byteOffset || 0
                          , c = new n(e[1],o,i.sparse.count * t)
                          , h = new s(e[2],l,i.sparse.count * a);
                        null !== r && (p = new Dn(p.array.slice(),p.itemSize,p.normalized));
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            if (p.setX(t, h[e * a]),
                            a >= 2 && p.setY(t, h[e * a + 1]),
                            a >= 3 && p.setZ(t, h[e * a + 2]),
                            a >= 4 && p.setW(t, h[e * a + 3]),
                            a >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }
                ))
            }
            loadTexture(e) {
                const t = this.json
                  , n = this.options
                  , i = t.textures[e].source
                  , r = t.images[i];
                let a = this.textureLoader;
                if (r.uri) {
                    const e = n.manager.getHandler(r.uri);
                    null !== e && (a = e)
                }
                return this.loadTextureImage(e, i, a)
            }
            loadTextureImage(e, t, n) {
                const i = this
                  , r = this.json
                  , a = r.textures[e]
                  , s = r.images[t]
                  , o = (s.uri || s.bufferView) + ":" + a.sampler;
                if (this.textureCache[o])
                    return this.textureCache[o];
                const l = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1,
                    t.name = a.name || s.name || "",
                    "" === t.name && "string" == typeof s.uri && !1 === s.uri.startsWith("data:image/") && (t.name = s.uri);
                    const n = (r.samplers || {})[a.sampler] || {};
                    return t.magFilter = sh[n.magFilter] || D,
                    t.minFilter = sh[n.minFilter] || O,
                    t.wrapS = oh[n.wrapS] || P,
                    t.wrapT = oh[n.wrapT] || P,
                    i.associations.set(t, {
                        textures: e
                    }),
                    t
                }
                )).catch((function() {
                    return null
                }
                ));
                return this.textureCache[o] = l,
                l
            }
            loadImageSource(e, t) {
                const n = this
                  , i = this.json
                  , r = this.options;
                if (void 0 !== this.sourceCache[e])
                    return this.sourceCache[e].then((e=>e.clone()));
                const a = i.images[e]
                  , s = self.URL || self.webkitURL;
                let o = a.uri || ""
                  , l = !1;
                if (void 0 !== a.bufferView)
                    o = n.getDependency("bufferView", a.bufferView).then((function(e) {
                        l = !0;
                        const t = new Blob([e],{
                            type: a.mimeType
                        });
                        return o = s.createObjectURL(t),
                        o
                    }
                    ));
                else if (void 0 === a.uri)
                    throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const c = Promise.resolve(o).then((function(e) {
                    return new Promise((function(n, i) {
                        let a = n;
                        !0 === t.isImageBitmapLoader && (a = function(e) {
                            const t = new it(e);
                            t.needsUpdate = !0,
                            n(t)
                        }
                        ),
                        t.load(Jl.resolveURL(e, r.path), a, void 0, i)
                    }
                    ))
                }
                )).then((function(e) {
                    var t;
                    return !0 === l && s.revokeObjectURL(o),
                    e.userData.mimeType = a.mimeType || ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
                    e
                }
                )).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", o),
                    e
                }
                ));
                return this.sourceCache[e] = c,
                c
            }
            assignTexture(e, t, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(a) {
                    if (!a)
                        return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord),
                    r.extensions[Pc.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[Pc.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = r.associations.get(a);
                            a = r.extensions[Pc.KHR_TEXTURE_TRANSFORM].extendTexture(a, e),
                            r.associations.set(a, t)
                        }
                    }
                    return void 0 !== i && (a.colorSpace = i),
                    e[t] = a,
                    a
                }
                ))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const i = void 0 === t.attributes.tangent
                  , r = void 0 !== t.attributes.color
                  , a = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new to,
                    Ln.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    t.sizeAttenuation = !1,
                    this.cache.add(e, t)),
                    n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new Gs,
                    Ln.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    this.cache.add(e, t)),
                    n = t
                }
                if (i || r || a) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    i && (e += "derivative-tangents:"),
                    r && (e += "vertex-colors:"),
                    a && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(),
                    r && (t.vertexColors = !0),
                    a && (t.flatShading = !0),
                    i && (t.normalScale && (t.normalScale.y *= -1),
                    t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                    this.cache.add(e, t),
                    this.associations.set(t, this.associations.get(n))),
                    n = t
                }
                e.material = n
            }
            getMaterialType() {
                return al
            }
            loadMaterial(e) {
                const t = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.materials[e];
                let a;
                const s = {}
                  , o = [];
                if ((r.extensions || {})[Pc.KHR_MATERIALS_UNLIT]) {
                    const e = i[Pc.KHR_MATERIALS_UNLIT];
                    a = e.getMaterialType(),
                    o.push(e.extendParams(s, r, t))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (s.color = new An(1,1,1),
                    s.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        s.color.setRGB(e[0], e[1], e[2], ce),
                        s.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && o.push(t.assignTexture(s, "map", n.baseColorTexture, le)),
                    s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (o.push(t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)),
                    o.push(t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))),
                    a = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    }
                    )),
                    o.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, s)
                    }
                    ))))
                }
                !0 === r.doubleSided && (s.side = 2);
                const l = r.alphaMode || uh;
                if (l === fh ? (s.transparent = !0,
                s.depthWrite = !1) : (s.transparent = !1,
                l === ph && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
                void 0 !== r.normalTexture && a !== In && (o.push(t.assignTexture(s, "normalMap", r.normalTexture)),
                s.normalScale = new De(1,1),
                void 0 !== r.normalTexture.scale)) {
                    const e = r.normalTexture.scale;
                    s.normalScale.set(e, e)
                }
                if (void 0 !== r.occlusionTexture && a !== In && (o.push(t.assignTexture(s, "aoMap", r.occlusionTexture)),
                void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)),
                void 0 !== r.emissiveFactor && a !== In) {
                    const e = r.emissiveFactor;
                    s.emissive = (new An).setRGB(e[0], e[1], e[2], ce)
                }
                return void 0 !== r.emissiveTexture && a !== In && o.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture, le)),
                Promise.all(o).then((function() {
                    const n = new a(s);
                    return r.name && (n.name = r.name),
                    gh(n, r),
                    t.associations.set(n, {
                        materials: e
                    }),
                    r.extensions && mh(i, n, r),
                    n
                }
                ))
            }
            createUniqueName(e) {
                const t = ac.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
                t)
            }
            loadGeometries(e) {
                const t = this
                  , n = this.extensions
                  , i = this.primitiveCache;
                function r(e) {
                    return n[Pc.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return Eh(n, e, t)
                    }
                    ))
                }
                const a = [];
                for (let n = 0, s = e.length; n < s; n++) {
                    const s = e[n]
                      , o = wh(s)
                      , l = i[o];
                    if (l)
                        a.push(l.promise);
                    else {
                        let e;
                        e = s.extensions && s.extensions[Pc.KHR_DRACO_MESH_COMPRESSION] ? r(s) : Eh(new qn, s, t),
                        i[o] = {
                            primitive: s,
                            promise: e
                        },
                        a.push(e)
                    }
                }
                return Promise.all(a)
            }
            loadMesh(e) {
                const t = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.meshes[e]
                  , a = r.primitives
                  , s = [];
                for (let e = 0, t = a.length; e < t; e++) {
                    const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new al({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0
                    })),
                    o.DefaultMaterial) : this.getDependency("material", a[e].material);
                    s.push(t)
                }
                var o;
                return s.push(t.loadGeometries(a)),
                Promise.all(s).then((function(n) {
                    const s = n.slice(0, n.length - 1)
                      , o = n[n.length - 1]
                      , l = [];
                    for (let n = 0, c = o.length; n < c; n++) {
                        const c = o[n]
                          , h = a[n];
                        let d;
                        const u = s[n];
                        if (h.mode === rh.TRIANGLES || h.mode === rh.TRIANGLE_STRIP || h.mode === rh.TRIANGLE_FAN || void 0 === h.mode)
                            d = !0 === r.isSkinnedMesh ? new As(c,u) : new di(c,u),
                            !0 === d.isSkinnedMesh && d.normalizeSkinWeights(),
                            h.mode === rh.TRIANGLE_STRIP ? d.geometry = kc(d.geometry, 1) : h.mode === rh.TRIANGLE_FAN && (d.geometry = kc(d.geometry, 2));
                        else if (h.mode === rh.LINES)
                            d = new $s(c,u);
                        else if (h.mode === rh.LINE_STRIP)
                            d = new Ks(c,u);
                        else if (h.mode === rh.LINE_LOOP)
                            d = new eo(c,u);
                        else {
                            if (h.mode !== rh.POINTS)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                            d = new so(c,u)
                        }
                        Object.keys(d.geometry.morphAttributes).length > 0 && vh(d, r),
                        d.name = t.createUniqueName(r.name || "mesh_" + e),
                        gh(d, r),
                        h.extensions && mh(i, d, h),
                        t.assignFinalMaterial(d),
                        l.push(d)
                    }
                    for (let n = 0, i = l.length; n < i; n++)
                        t.associations.set(l[n], {
                            meshes: e,
                            primitives: n
                        });
                    if (1 === l.length)
                        return r.extensions && mh(i, l[0], r),
                        l[0];
                    const c = new ls;
                    r.extensions && mh(i, c, r),
                    t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++)
                        c.add(l[e]);
                    return c
                }
                ))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e]
                  , i = n[n.type];
                if (i)
                    return "perspective" === n.type ? t = new _i(Ue.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (t = new ji(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                    n.name && (t.name = this.createUniqueName(n.name)),
                    gh(t, n),
                    Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e]
                  , n = [];
                for (let e = 0, i = t.joints.length; e < i; e++)
                    n.push(this._loadNodeShallow(t.joints[e]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
                Promise.all(n).then((function(e) {
                    const n = e.pop()
                      , i = e
                      , r = []
                      , a = [];
                    for (let e = 0, s = i.length; e < s; e++) {
                        const s = i[e];
                        if (s) {
                            r.push(s);
                            const t = new Ft;
                            null !== n && t.fromArray(n.array, 16 * e),
                            a.push(t)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    return new Ns(r,a)
                }
                ))
            }
            loadAnimation(e) {
                const t = this.json
                  , n = this
                  , i = t.animations[e]
                  , r = i.name ? i.name : "animation_" + e
                  , a = []
                  , s = []
                  , o = []
                  , l = []
                  , c = [];
                for (let e = 0, t = i.channels.length; e < t; e++) {
                    const t = i.channels[e]
                      , n = i.samplers[t.sampler]
                      , r = t.target
                      , h = r.node
                      , d = void 0 !== i.parameters ? i.parameters[n.input] : n.input
                      , u = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                    void 0 !== r.node && (a.push(this.getDependency("node", h)),
                    s.push(this.getDependency("accessor", d)),
                    o.push(this.getDependency("accessor", u)),
                    l.push(n),
                    c.push(r))
                }
                return Promise.all([Promise.all(a), Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(c)]).then((function(e) {
                    const t = e[0]
                      , i = e[1]
                      , a = e[2]
                      , s = e[3]
                      , o = e[4]
                      , l = [];
                    for (let e = 0, r = t.length; e < r; e++) {
                        const r = t[e]
                          , c = i[e]
                          , h = a[e]
                          , d = s[e]
                          , u = o[e];
                        if (void 0 === r)
                            continue;
                        r.updateMatrix && r.updateMatrix();
                        const p = n._createAnimationTracks(r, c, h, d, u);
                        if (p)
                            for (let e = 0; e < p.length; e++)
                                l.push(p[e])
                    }
                    return new Ml(r,void 0,l)
                }
                ))
            }
            createNodeMesh(e) {
                const t = this.json
                  , n = this
                  , i = t.nodes[e];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, i.mesh, e);
                    return void 0 !== i.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = i.weights.length; t < n; t++)
                                e.morphTargetInfluences[t] = i.weights[t]
                    }
                    )),
                    t
                }
                ))
            }
            loadNode(e) {
                const t = this
                  , n = this.json.nodes[e]
                  , i = t._loadNodeShallow(e)
                  , r = []
                  , a = n.children || [];
                for (let e = 0, n = a.length; e < n; e++)
                    r.push(t.getDependency("node", a[e]));
                const s = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([i, Promise.all(r), s]).then((function(e) {
                    const t = e[0]
                      , n = e[1]
                      , i = e[2];
                    null !== i && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(i, xh)
                    }
                    ));
                    for (let e = 0, i = n.length; e < i; e++)
                        t.add(n[e]);
                    return t
                }
                ))
            }
            _loadNodeShallow(e) {
                const t = this.json
                  , n = this.extensions
                  , i = this;
                if (void 0 !== this.nodeCache[e])
                    return this.nodeCache[e];
                const r = t.nodes[e]
                  , a = r.name ? i.createUniqueName(r.name) : ""
                  , s = []
                  , o = i._invokeOne((function(t) {
                    return t.createNodeMesh && t.createNodeMesh(e)
                }
                ));
                return o && s.push(o),
                void 0 !== r.camera && s.push(i.getDependency("camera", r.camera).then((function(e) {
                    return i._getNodeRef(i.cameraCache, r.camera, e)
                }
                ))),
                i._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                }
                )).forEach((function(e) {
                    s.push(e)
                }
                )),
                this.nodeCache[e] = Promise.all(s).then((function(t) {
                    let s;
                    if (s = !0 === r.isBone ? new Ps : t.length > 1 ? new ls : 1 === t.length ? t[0] : new un,
                    s !== t[0])
                        for (let e = 0, n = t.length; e < n; e++)
                            s.add(t[e]);
                    if (r.name && (s.userData.name = r.name,
                    s.name = a),
                    gh(s, r),
                    r.extensions && mh(n, s, r),
                    void 0 !== r.matrix) {
                        const e = new Ft;
                        e.fromArray(r.matrix),
                        s.applyMatrix4(e)
                    } else
                        void 0 !== r.translation && s.position.fromArray(r.translation),
                        void 0 !== r.rotation && s.quaternion.fromArray(r.rotation),
                        void 0 !== r.scale && s.scale.fromArray(r.scale);
                    return i.associations.has(s) || i.associations.set(s, {}),
                    i.associations.get(s).nodes = e,
                    s
                }
                )),
                this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions
                  , n = this.json.scenes[e]
                  , i = this
                  , r = new ls;
                n.name && (r.name = i.createUniqueName(n.name)),
                gh(r, n),
                n.extensions && mh(t, r, n);
                const a = n.nodes || []
                  , s = [];
                for (let e = 0, t = a.length; e < t; e++)
                    s.push(i.getDependency("node", a[e]));
                return Promise.all(s).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++)
                        r.add(e[t]);
                    return i.associations = (e=>{
                        const t = new Map;
                        for (const [e,n] of i.associations)
                            (e instanceof Ln || e instanceof it) && t.set(e, n);
                        return e.traverse((e=>{
                            const n = i.associations.get(e);
                            null != n && t.set(e, n)
                        }
                        )),
                        t
                    }
                    )(r),
                    r
                }
                ))
            }
            _createAnimationTracks(e, t, n, i, r) {
                const a = []
                  , s = e.name ? e.name : e.uuid
                  , o = [];
                let l;
                switch (hh[r.path] === hh.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid)
                }
                )) : o.push(s),
                hh[r.path]) {
                case hh.weights:
                    l = _l;
                    break;
                case hh.rotation:
                    l = bl;
                    break;
                case hh.position:
                case hh.scale:
                    l = Sl;
                    break;
                default:
                    if (1 === n.itemSize)
                        l = _l;
                    else
                        l = Sl
                }
                const c = void 0 !== i.interpolation ? dh[i.interpolation] : te
                  , h = this._getArrayFromAccessor(n);
                for (let e = 0, n = o.length; e < n; e++) {
                    const n = new l(o[e] + "." + hh[r.path],t.array,h,c);
                    "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n),
                    a.push(n)
                }
                return a
            }
            _getArrayFromAccessor(e) {
                let t = e.array;
                if (e.normalized) {
                    const e = _h(t.constructor)
                      , n = new Float32Array(t.length);
                    for (let i = 0, r = t.length; i < r; i++)
                        n[i] = t[i] * e;
                    t = n
                }
                return t
            }
            _createCubicSplineTrackInterpolant(e) {
                e.createInterpolant = function(e) {
                    return new (this instanceof bl ? ih : th)(this.times,this.values,this.getValueSize() / 3,e)
                }
                ,
                e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }
        function Eh(e, t, n) {
            const i = t.attributes
              , r = [];
            function a(t, i) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(i, t)
                }
                ))
            }
            for (const t in i) {
                const n = ch[t] || t.toLowerCase();
                n in e.attributes || r.push(a(i[t], n))
            }
            if (void 0 !== t.indices && !e.index) {
                const i = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }
                ));
                r.push(i)
            }
            return Ye.workingColorSpace !== ce && "COLOR_0"in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ye.workingColorSpace}" not supported.`),
            gh(e, t),
            function(e, t, n) {
                const i = t.attributes
                  , r = new pt;
                if (void 0 === i.POSITION)
                    return;
                {
                    const e = n.json.accessors[i.POSITION]
                      , t = e.min
                      , a = e.max;
                    if (void 0 === t || void 0 === a)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (r.set(new ht(t[0],t[1],t[2]), new ht(a[0],a[1],a[2])),
                    e.normalized) {
                        const t = _h(ah[e.componentType]);
                        r.min.multiplyScalar(t),
                        r.max.multiplyScalar(t)
                    }
                }
                const a = t.targets;
                if (void 0 !== a) {
                    const e = new ht
                      , t = new ht;
                    for (let i = 0, r = a.length; i < r; i++) {
                        const r = a[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION]
                              , a = i.min
                              , s = i.max;
                            if (void 0 !== a && void 0 !== s) {
                                if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))),
                                t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))),
                                t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))),
                                i.normalized) {
                                    const e = _h(ah[i.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    r.expandByVector(e)
                }
                e.boundingBox = r;
                const s = new Rt;
                r.getCenter(s.center),
                s.radius = r.min.distanceTo(r.max) / 2,
                e.boundingSphere = s
            }(e, t, n),
            Promise.all(r).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let i = !1
                      , r = !1
                      , a = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        void 0 !== n.COLOR_0 && (a = !0),
                        i && r && a)
                            break
                    }
                    if (!i && !r && !a)
                        return Promise.resolve(e);
                    const s = []
                      , o = []
                      , l = [];
                    for (let c = 0, h = t.length; c < h; c++) {
                        const h = t[c];
                        if (i) {
                            const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                            s.push(t)
                        }
                        if (r) {
                            const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                            o.push(t)
                        }
                        if (a) {
                            const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                            l.push(t)
                        }
                    }
                    return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function(t) {
                        const n = t[0]
                          , s = t[1]
                          , o = t[2];
                        return i && (e.morphAttributes.position = n),
                        r && (e.morphAttributes.normal = s),
                        a && (e.morphAttributes.color = o),
                        e.morphTargetsRelative = !0,
                        e
                    }
                    ))
                }(e, t.targets, n) : e
            }
            ))
        }
        var Sh, Mh, Th, kh = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Ch {
            constructor() {
                Th.set(this, new _i(kh(Sh, Sh, "f", Mh),1,.1,1e4))
            }
            reset(e, t) {
                this.update(e, t, 0),
                kh(this, Th, "f").fov = kh(Sh, Sh, "f", Mh),
                kh(this, Th, "f").updateProjectionMatrix()
            }
            update(e, t, n) {
                const i = Math.abs(n) / 400;
                kh(this, Th, "f").fov = kh(Sh, Sh, "f", Mh) + (90 - kh(Sh, Sh, "f", Mh)) * Math.pow(i, 1) / (Math.pow(i, 1) + Math.pow(1 - i, 1)),
                kh(this, Th, "f").updateProjectionMatrix();
                const r = new ht(0,1,.5);
                kh(this, Th, "f").position.addVectors(e, r.applyQuaternion(t)),
                kh(this, Th, "f").quaternion.copy(t),
                kh(this, Th, "f").quaternion.multiply((new ct).setFromEuler(new Kt(0,Math.PI,0))),
                kh(this, Th, "f").updateMatrix()
            }
            get camera() {
                return kh(this, Th, "f")
            }
        }
        Sh = Ch,
        Th = new WeakMap,
        Mh = {
            value: 70
        };
        const Ah = Ch;
        class Ph {
            constructor(e, t, n, i) {
                this.primary = e,
                this.secondary = t,
                this.frame = n,
                this.rims = i
            }
            static random() {
                const e = 360 * Math.random()
                  , t = .5 * (1 - Math.pow(Math.random(), 2)) * 100
                  , n = 100 * (.1 + .2 * (1 - Math.pow(Math.random(), 2)));
                return new Ph(new An("hsl(" + e + "," + t + "%," + n + "%)"),new An("#ffffff"),new An("#131313"),new An("#666666"))
            }
            serialize() {
                return this.primary.getHexString() + this.secondary.getHexString() + this.frame.getHexString() + this.rims.getHexString()
            }
            static deserialize(e) {
                const t = [];
                for (let n = 0; n < 4; n++) {
                    const i = e.substring(6 * n, 6 * (n + 1));
                    /^[0-9a-f]{6}$/i.test(i) ? t.push(new An("#" + i)) : t.push(new An("#555"))
                }
                return new Ph(t[0],t[1],t[2],t[3])
            }
        }
        const Rh = Ph;
        var Lh, Ih, Nh, Uh, Dh, Bh = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Oh = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class zh {
            constructor() {
                Nh.set(this, new _i(Oh(Lh, Lh, "f", Ih),1,.1,1e4)),
                Uh.set(this, new ht),
                Dh.set(this, new ht(0,1,0))
            }
            reset(e, t) {
                Bh(this, Uh, new ht(0,0,-1), "f"),
                Oh(this, Uh, "f").applyQuaternion(t),
                Oh(this, Uh, "f").add(e),
                Bh(this, Dh, new ht(0,1,0), "f"),
                Oh(this, Dh, "f").applyQuaternion(t),
                this.update(e, t, 0),
                Oh(this, Nh, "f").fov = Oh(Lh, Lh, "f", Ih),
                Oh(this, Nh, "f").updateProjectionMatrix()
            }
            update(e, t, n) {
                const i = Math.abs(n) / 400;
                Oh(this, Nh, "f").fov = Oh(Lh, Lh, "f", Ih) + (100 - Oh(Lh, Lh, "f", Ih)) * Math.pow(i, 1) / (Math.pow(i, 1) + Math.pow(1 - i, 1)),
                Oh(this, Nh, "f").updateProjectionMatrix();
                const r = new ht(0,1,0);
                r.applyQuaternion(t);
                const a = .005;
                Oh(this, Dh, "f").set(a * r.x + (1 - a) * Oh(this, Dh, "f").x, a * r.y + (1 - a) * Oh(this, Dh, "f").y, a * r.z + (1 - a) * Oh(this, Dh, "f").z);
                const s = (new ht).subVectors(e, Oh(this, Uh, "f"));
                s.normalize();
                const o = 5.5;
                Oh(this, Nh, "f").position.x = e.x - s.x * o + 2 * Oh(this, Dh, "f").x,
                Oh(this, Nh, "f").position.y = Math.max(.25, e.y - s.y * o + 2 * Oh(this, Dh, "f").y),
                Oh(this, Nh, "f").position.z = e.z - s.z * o + 2 * Oh(this, Dh, "f").z,
                Oh(this, Nh, "f").lookAt(new ht(e.x + 2 * Oh(this, Dh, "f").x,e.y + 2 * Oh(this, Dh, "f").y,e.z + 2 * Oh(this, Dh, "f").z)),
                Oh(this, Nh, "f").updateMatrix(),
                Oh(this, Uh, "f").set(e.x - s.x * o, e.y - s.y * o, e.z - s.z * o)
            }
            get camera() {
                return Oh(this, Nh, "f")
            }
        }
        Lh = zh,
        Nh = new WeakMap,
        Uh = new WeakMap,
        Dh = new WeakMap,
        Ih = {
            value: 70
        };
        const Fh = zh;
        var Wh, Hh, Vh, Gh, jh, Xh, qh, Yh = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Zh = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Kh {
            constructor(e) {
                Hh.set(this, void 0),
                Vh.set(this, void 0),
                Gh.set(this, []),
                jh.set(this, (new Ft).makeScale(0, 0, 0)),
                Xh.set(this, new ht(0,1,0)),
                Yh(this, Hh, e, "f");
                const t = new Ni;
                t.rotateX(Math.PI);
                const n = new In({
                    opacity: .3,
                    depthWrite: !1,
                    transparent: !0,
                    map: Zh(Wh, Wh, "f", qh)
                });
                Yh(this, Vh, new Vs(t,n,256), "f"),
                Zh(this, Vh, "f").frustumCulled = !1,
                e.scene.add(Zh(this, Vh, "f")),
                this.clear()
            }
            dispose() {
                Zh(this, Vh, "f").geometry.dispose(),
                Zh(this, Vh, "f").material.dispose(),
                Zh(this, Vh, "f").dispose(),
                Zh(this, Hh, "f").scene.remove(Zh(this, Vh, "f"))
            }
            clear() {
                Zh(this, Gh, "f").length = 0;
                for (let e = 0; e < Zh(this, Vh, "f").count; ++e)
                    Zh(this, Vh, "f").setMatrixAt(e, Zh(this, jh, "f"))
            }
            spawn(e, t, n) {
                Zh(this, Gh, "f").push({
                    x: e + .25 * (Math.random() - .5),
                    y: t + .25 * (Math.random() - .5),
                    z: n + .25 * (Math.random() - .5),
                    vx: .5 * (Math.random() - .5),
                    vy: .5 * (Math.random() - .5),
                    vz: .5 * (Math.random() - .5),
                    rotation: Math.random() * Math.PI * 2,
                    lifetime: .5
                })
            }
            update(e) {
                for (let t = Zh(this, Gh, "f").length - 1; t >= 0; --t) {
                    const n = Zh(this, Gh, "f")[t];
                    n.vy += 15 * e,
                    n.x += n.vx * e,
                    n.y += n.vy * e,
                    n.z += n.vz * e,
                    n.lifetime -= e,
                    n.lifetime <= 0 && Zh(this, Gh, "f").splice(t, 1)
                }
                for (let e = 0; e < Zh(this, Vh, "f").count; ++e)
                    if (e < Zh(this, Gh, "f").length) {
                        const t = Zh(this, Gh, "f")[Zh(this, Gh, "f").length - 1 - e]
                          , n = new Ft;
                        n.lookAt(new ht(t.x,t.y,t.z), Zh(this, Hh, "f").camera.position, Zh(this, Xh, "f")),
                        n.setPosition(t.x, t.y, t.z),
                        n.multiply((new Ft).makeRotationZ(t.rotation));
                        const i = .5 + 2 * (.5 - t.lifetime);
                        n.scale(new ht(i,i,i)),
                        Zh(this, Vh, "f").setMatrixAt(e, n)
                    } else
                        Zh(this, Vh, "f").setMatrixAt(e, Zh(this, jh, "f"));
                Zh(this, Vh, "f").instanceMatrix.needsUpdate = !0
            }
            static initResources(e) {
                e.addResource(),
                Yh(this, Wh, (new Ul).load("images/smoke.png", (()=>{
                    e.loadedResource()
                }
                )), "f", qh)
            }
        }
        Wh = Kh,
        Hh = new WeakMap,
        Vh = new WeakMap,
        Gh = new WeakMap,
        jh = new WeakMap,
        Xh = new WeakMap,
        qh = {
            value: null
        };
        const Jh = Kh;
        var Qh, $h, ed, td, nd, id, rd, ad, sd, od, ld, cd, hd = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, dd = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        $h = new WeakMap,
        ed = new WeakMap,
        td = new WeakMap,
        nd = new WeakMap,
        id = new WeakMap,
        rd = new WeakMap,
        ad = new WeakMap,
        sd = new WeakMap,
        od = new WeakMap,
        ld = new WeakMap,
        Qh = new WeakSet,
        cd = function(e, t, n, i) {
            const r = new sc(e,t,n,i)
              , a = dd(this, td, "f").shortRaycast(r);
            if (null != a)
                return a;
            const s = dd(this, ed, "f").raycast(r);
            return null != s ? s : null
        }
        ;
        const ud = class {
            constructor(e, t, n) {
                Qh.add(this),
                $h.set(this, void 0),
                ed.set(this, void 0),
                td.set(this, void 0),
                nd.set(this, void 0),
                id.set(this, void 0),
                rd.set(this, void 0),
                ad.set(this, 1e3),
                sd.set(this, 0),
                od.set(this, null),
                ld.set(this, null),
                hd(this, $h, e, "f"),
                hd(this, ed, t, "f"),
                hd(this, td, n, "f");
                const i = new qn;
                hd(this, id, new Float32Array(6 * dd(this, ad, "f") * 3), "f"),
                hd(this, rd, new Dn(dd(this, id, "f"),3), "f"),
                i.setAttribute("position", dd(this, rd, "f"));
                const r = new In({
                    color: 1118481,
                    side: 2,
                    polygonOffset: !0,
                    polygonOffsetFactor: -1,
                    polygonOffsetUnits: 0
                });
                hd(this, nd, new di(i,r), "f"),
                dd(this, nd, "f").frustumCulled = !1,
                dd(this, $h, "f").scene.add(dd(this, nd, "f"))
            }
            dispose() {
                dd(this, nd, "f").geometry.dispose(),
                dd(this, nd, "f").material.dispose(),
                dd(this, $h, "f").scene.remove(dd(this, nd, "f"))
            }
            clear() {
                for (let e = 0; e < dd(this, id, "f").length; ++e)
                    dd(this, id, "f")[e] = 0;
                dd(this, rd, "f").needsUpdate = !0,
                hd(this, sd, 0, "f"),
                this.break()
            }
            break() {
                hd(this, od, null, "f"),
                hd(this, ld, null, "f")
            }
            spawn(e, t, n, i) {
                var r, a;
                const s = dd(this, od, "f")
                  , o = dd(this, ld, "f");
                let l = new ht(e,t,n).add(new ht(.172,-.3,0).applyQuaternion(i))
                  , c = new ht(e,t,n).add(new ht(-.172,-.3,0).applyQuaternion(i));
                const h = new ht(0,-1,0).applyQuaternion(i)
                  , d = dd(this, Qh, "m", cd).call(this, l, h, 0, .05)
                  , u = dd(this, Qh, "m", cd).call(this, c, h, 0, .05);
                if (null != d && null != u) {
                    if (l = d.point,
                    c = u.point,
                    null != s && null != o) {
                        const e = (hd(this, sd, (a = dd(this, sd, "f"),
                        r = a++,
                        a), "f"),
                        r);
                        dd(this, id, "f")[6 * e * 3 + 0] = l.x,
                        dd(this, id, "f")[6 * e * 3 + 1] = l.y,
                        dd(this, id, "f")[6 * e * 3 + 2] = l.z,
                        dd(this, id, "f")[6 * e * 3 + 3] = s.x,
                        dd(this, id, "f")[6 * e * 3 + 4] = s.y,
                        dd(this, id, "f")[6 * e * 3 + 5] = s.z,
                        dd(this, id, "f")[6 * e * 3 + 6] = c.x,
                        dd(this, id, "f")[6 * e * 3 + 7] = c.y,
                        dd(this, id, "f")[6 * e * 3 + 8] = c.z,
                        dd(this, id, "f")[6 * e * 3 + 9] = c.x,
                        dd(this, id, "f")[6 * e * 3 + 10] = c.y,
                        dd(this, id, "f")[6 * e * 3 + 11] = c.z,
                        dd(this, id, "f")[6 * e * 3 + 12] = s.x,
                        dd(this, id, "f")[6 * e * 3 + 13] = s.y,
                        dd(this, id, "f")[6 * e * 3 + 14] = s.z,
                        dd(this, id, "f")[6 * e * 3 + 15] = o.x,
                        dd(this, id, "f")[6 * e * 3 + 16] = o.y,
                        dd(this, id, "f")[6 * e * 3 + 17] = o.z,
                        dd(this, rd, "f").needsUpdate = !0,
                        dd(this, sd, "f") >= dd(this, ad, "f") - 1 && hd(this, sd, 0, "f")
                    }
                    hd(this, od, l, "f"),
                    hd(this, ld, c, "f")
                } else
                    this.break()
            }
        }
        ;
        var pd, fd = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, md = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class gd {
            constructor(e) {
                if (pd.set(this, 0),
                null != e) {
                    if (!Number.isSafeInteger(e))
                        throw "Frames is not a safe integer";
                    fd(this, pd, e, "f")
                }
            }
            get numberOfFrames() {
                return md(this, pd, "f")
            }
            get time() {
                return md(this, pd, "f") / 1e3
            }
            increment() {
                var e;
                fd(this, pd, (e = md(this, pd, "f"),
                ++e), "f")
            }
            difference(e) {
                return new gd(md(this, pd, "f") - md(e, pd, "f"))
            }
            lessThan(e) {
                return md(this, pd, "f") < md(e, pd, "f")
            }
            greaterThan(e) {
                return md(this, pd, "f") > md(e, pd, "f")
            }
            lessOrEqual(e) {
                return md(this, pd, "f") <= md(e, pd, "f")
            }
            greaterOrEqual(e) {
                return md(this, pd, "f") >= md(e, pd, "f")
            }
            equals(e) {
                return md(this, pd, "f") == md(e, pd, "f")
            }
            isNegative() {
                return md(this, pd, "f") < 0
            }
            clone() {
                const e = new gd;
                return fd(e, pd, md(this, pd, "f"), "f"),
                e
            }
        }
        pd = new WeakMap;
        const vd = gd;
        function wd(e) {
            let t = e.length;
            for (; --t >= 0; )
                e[t] = 0
        }
        const yd = 256
          , _d = 286
          , xd = 30
          , bd = 15
          , Ed = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
          , Sd = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
          , Md = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
          , Td = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , kd = new Array(576);
        wd(kd);
        const Cd = new Array(60);
        wd(Cd);
        const Ad = new Array(512);
        wd(Ad);
        const Pd = new Array(256);
        wd(Pd);
        const Rd = new Array(29);
        wd(Rd);
        const Ld = new Array(xd);
        function Id(e, t, n, i, r) {
            this.static_tree = e,
            this.extra_bits = t,
            this.extra_base = n,
            this.elems = i,
            this.max_length = r,
            this.has_stree = e && e.length
        }
        let Nd, Ud, Dd;
        function Bd(e, t) {
            this.dyn_tree = e,
            this.max_code = 0,
            this.stat_desc = t
        }
        wd(Ld);
        const Od = e=>e < 256 ? Ad[e] : Ad[256 + (e >>> 7)]
          , zd = (e,t)=>{
            e.pending_buf[e.pending++] = 255 & t,
            e.pending_buf[e.pending++] = t >>> 8 & 255
        }
          , Fd = (e,t,n)=>{
            e.bi_valid > 16 - n ? (e.bi_buf |= t << e.bi_valid & 65535,
            zd(e, e.bi_buf),
            e.bi_buf = t >> 16 - e.bi_valid,
            e.bi_valid += n - 16) : (e.bi_buf |= t << e.bi_valid & 65535,
            e.bi_valid += n)
        }
          , Wd = (e,t,n)=>{
            Fd(e, n[2 * t], n[2 * t + 1])
        }
          , Hd = (e,t)=>{
            let n = 0;
            do {
                n |= 1 & e,
                e >>>= 1,
                n <<= 1
            } while (--t > 0);
            return n >>> 1
        }
          , Vd = (e,t,n)=>{
            const i = new Array(16);
            let r, a, s = 0;
            for (r = 1; r <= bd; r++)
                s = s + n[r - 1] << 1,
                i[r] = s;
            for (a = 0; a <= t; a++) {
                let t = e[2 * a + 1];
                0 !== t && (e[2 * a] = Hd(i[t]++, t))
            }
        }
          , Gd = e=>{
            let t;
            for (t = 0; t < _d; t++)
                e.dyn_ltree[2 * t] = 0;
            for (t = 0; t < xd; t++)
                e.dyn_dtree[2 * t] = 0;
            for (t = 0; t < 19; t++)
                e.bl_tree[2 * t] = 0;
            e.dyn_ltree[512] = 1,
            e.opt_len = e.static_len = 0,
            e.sym_next = e.matches = 0
        }
          , jd = e=>{
            e.bi_valid > 8 ? zd(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
            e.bi_buf = 0,
            e.bi_valid = 0
        }
          , Xd = (e,t,n,i)=>{
            const r = 2 * t
              , a = 2 * n;
            return e[r] < e[a] || e[r] === e[a] && i[t] <= i[n]
        }
          , qd = (e,t,n)=>{
            const i = e.heap[n];
            let r = n << 1;
            for (; r <= e.heap_len && (r < e.heap_len && Xd(t, e.heap[r + 1], e.heap[r], e.depth) && r++,
            !Xd(t, i, e.heap[r], e.depth)); )
                e.heap[n] = e.heap[r],
                n = r,
                r <<= 1;
            e.heap[n] = i
        }
          , Yd = (e,t,n)=>{
            let i, r, a, s, o = 0;
            if (0 !== e.sym_next)
                do {
                    i = 255 & e.pending_buf[e.sym_buf + o++],
                    i += (255 & e.pending_buf[e.sym_buf + o++]) << 8,
                    r = e.pending_buf[e.sym_buf + o++],
                    0 === i ? Wd(e, r, t) : (a = Pd[r],
                    Wd(e, a + yd + 1, t),
                    s = Ed[a],
                    0 !== s && (r -= Rd[a],
                    Fd(e, r, s)),
                    i--,
                    a = Od(i),
                    Wd(e, a, n),
                    s = Sd[a],
                    0 !== s && (i -= Ld[a],
                    Fd(e, i, s)))
                } while (o < e.sym_next);
            Wd(e, 256, t)
        }
          , Zd = (e,t)=>{
            const n = t.dyn_tree
              , i = t.stat_desc.static_tree
              , r = t.stat_desc.has_stree
              , a = t.stat_desc.elems;
            let s, o, l, c = -1;
            for (e.heap_len = 0,
            e.heap_max = 573,
            s = 0; s < a; s++)
                0 !== n[2 * s] ? (e.heap[++e.heap_len] = c = s,
                e.depth[s] = 0) : n[2 * s + 1] = 0;
            for (; e.heap_len < 2; )
                l = e.heap[++e.heap_len] = c < 2 ? ++c : 0,
                n[2 * l] = 1,
                e.depth[l] = 0,
                e.opt_len--,
                r && (e.static_len -= i[2 * l + 1]);
            for (t.max_code = c,
            s = e.heap_len >> 1; s >= 1; s--)
                qd(e, n, s);
            l = a;
            do {
                s = e.heap[1],
                e.heap[1] = e.heap[e.heap_len--],
                qd(e, n, 1),
                o = e.heap[1],
                e.heap[--e.heap_max] = s,
                e.heap[--e.heap_max] = o,
                n[2 * l] = n[2 * s] + n[2 * o],
                e.depth[l] = (e.depth[s] >= e.depth[o] ? e.depth[s] : e.depth[o]) + 1,
                n[2 * s + 1] = n[2 * o + 1] = l,
                e.heap[1] = l++,
                qd(e, n, 1)
            } while (e.heap_len >= 2);
            e.heap[--e.heap_max] = e.heap[1],
            ((e,t)=>{
                const n = t.dyn_tree
                  , i = t.max_code
                  , r = t.stat_desc.static_tree
                  , a = t.stat_desc.has_stree
                  , s = t.stat_desc.extra_bits
                  , o = t.stat_desc.extra_base
                  , l = t.stat_desc.max_length;
                let c, h, d, u, p, f, m = 0;
                for (u = 0; u <= bd; u++)
                    e.bl_count[u] = 0;
                for (n[2 * e.heap[e.heap_max] + 1] = 0,
                c = e.heap_max + 1; c < 573; c++)
                    h = e.heap[c],
                    u = n[2 * n[2 * h + 1] + 1] + 1,
                    u > l && (u = l,
                    m++),
                    n[2 * h + 1] = u,
                    h > i || (e.bl_count[u]++,
                    p = 0,
                    h >= o && (p = s[h - o]),
                    f = n[2 * h],
                    e.opt_len += f * (u + p),
                    a && (e.static_len += f * (r[2 * h + 1] + p)));
                if (0 !== m) {
                    do {
                        for (u = l - 1; 0 === e.bl_count[u]; )
                            u--;
                        e.bl_count[u]--,
                        e.bl_count[u + 1] += 2,
                        e.bl_count[l]--,
                        m -= 2
                    } while (m > 0);
                    for (u = l; 0 !== u; u--)
                        for (h = e.bl_count[u]; 0 !== h; )
                            d = e.heap[--c],
                            d > i || (n[2 * d + 1] !== u && (e.opt_len += (u - n[2 * d + 1]) * n[2 * d],
                            n[2 * d + 1] = u),
                            h--)
                }
            }
            )(e, t),
            Vd(n, c, e.bl_count)
        }
          , Kd = (e,t,n)=>{
            let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
            for (0 === s && (l = 138,
            c = 3),
            t[2 * (n + 1) + 1] = 65535,
            i = 0; i <= n; i++)
                r = s,
                s = t[2 * (i + 1) + 1],
                ++o < l && r === s || (o < c ? e.bl_tree[2 * r] += o : 0 !== r ? (r !== a && e.bl_tree[2 * r]++,
                e.bl_tree[32]++) : o <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++,
                o = 0,
                a = r,
                0 === s ? (l = 138,
                c = 3) : r === s ? (l = 6,
                c = 3) : (l = 7,
                c = 4))
        }
          , Jd = (e,t,n)=>{
            let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
            for (0 === s && (l = 138,
            c = 3),
            i = 0; i <= n; i++)
                if (r = s,
                s = t[2 * (i + 1) + 1],
                !(++o < l && r === s)) {
                    if (o < c)
                        do {
                            Wd(e, r, e.bl_tree)
                        } while (0 != --o);
                    else
                        0 !== r ? (r !== a && (Wd(e, r, e.bl_tree),
                        o--),
                        Wd(e, 16, e.bl_tree),
                        Fd(e, o - 3, 2)) : o <= 10 ? (Wd(e, 17, e.bl_tree),
                        Fd(e, o - 3, 3)) : (Wd(e, 18, e.bl_tree),
                        Fd(e, o - 11, 7));
                    o = 0,
                    a = r,
                    0 === s ? (l = 138,
                    c = 3) : r === s ? (l = 6,
                    c = 3) : (l = 7,
                    c = 4)
                }
        }
        ;
        let Qd = !1;
        const $d = (e,t,n,i)=>{
            Fd(e, 0 + (i ? 1 : 0), 3),
            jd(e),
            zd(e, n),
            zd(e, ~n),
            n && e.pending_buf.set(e.window.subarray(t, t + n), e.pending),
            e.pending += n
        }
        ;
        var eu = (e,t,n,i)=>{
            let r, a, s = 0;
            e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e=>{
                let t, n = 4093624447;
                for (t = 0; t <= 31; t++,
                n >>>= 1)
                    if (1 & n && 0 !== e.dyn_ltree[2 * t])
                        return 0;
                if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26])
                    return 1;
                for (t = 32; t < yd; t++)
                    if (0 !== e.dyn_ltree[2 * t])
                        return 1;
                return 0
            }
            )(e)),
            Zd(e, e.l_desc),
            Zd(e, e.d_desc),
            s = (e=>{
                let t;
                for (Kd(e, e.dyn_ltree, e.l_desc.max_code),
                Kd(e, e.dyn_dtree, e.d_desc.max_code),
                Zd(e, e.bl_desc),
                t = 18; t >= 3 && 0 === e.bl_tree[2 * Td[t] + 1]; t--)
                    ;
                return e.opt_len += 3 * (t + 1) + 5 + 5 + 4,
                t
            }
            )(e),
            r = e.opt_len + 3 + 7 >>> 3,
            a = e.static_len + 3 + 7 >>> 3,
            a <= r && (r = a)) : r = a = n + 5,
            n + 4 <= r && -1 !== t ? $d(e, t, n, i) : 4 === e.strategy || a === r ? (Fd(e, 2 + (i ? 1 : 0), 3),
            Yd(e, kd, Cd)) : (Fd(e, 4 + (i ? 1 : 0), 3),
            ((e,t,n,i)=>{
                let r;
                for (Fd(e, t - 257, 5),
                Fd(e, n - 1, 5),
                Fd(e, i - 4, 4),
                r = 0; r < i; r++)
                    Fd(e, e.bl_tree[2 * Td[r] + 1], 3);
                Jd(e, e.dyn_ltree, t - 1),
                Jd(e, e.dyn_dtree, n - 1)
            }
            )(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1),
            Yd(e, e.dyn_ltree, e.dyn_dtree)),
            Gd(e),
            i && jd(e)
        }
          , tu = {
            _tr_init: e=>{
                Qd || ((()=>{
                    let e, t, n, i, r;
                    const a = new Array(16);
                    for (n = 0,
                    i = 0; i < 28; i++)
                        for (Rd[i] = n,
                        e = 0; e < 1 << Ed[i]; e++)
                            Pd[n++] = i;
                    for (Pd[n - 1] = i,
                    r = 0,
                    i = 0; i < 16; i++)
                        for (Ld[i] = r,
                        e = 0; e < 1 << Sd[i]; e++)
                            Ad[r++] = i;
                    for (r >>= 7; i < xd; i++)
                        for (Ld[i] = r << 7,
                        e = 0; e < 1 << Sd[i] - 7; e++)
                            Ad[256 + r++] = i;
                    for (t = 0; t <= bd; t++)
                        a[t] = 0;
                    for (e = 0; e <= 143; )
                        kd[2 * e + 1] = 8,
                        e++,
                        a[8]++;
                    for (; e <= 255; )
                        kd[2 * e + 1] = 9,
                        e++,
                        a[9]++;
                    for (; e <= 279; )
                        kd[2 * e + 1] = 7,
                        e++,
                        a[7]++;
                    for (; e <= 287; )
                        kd[2 * e + 1] = 8,
                        e++,
                        a[8]++;
                    for (Vd(kd, 287, a),
                    e = 0; e < xd; e++)
                        Cd[2 * e + 1] = 5,
                        Cd[2 * e] = Hd(e, 5);
                    Nd = new Id(kd,Ed,257,_d,bd),
                    Ud = new Id(Cd,Sd,0,xd,bd),
                    Dd = new Id(new Array(0),Md,0,19,7)
                }
                )(),
                Qd = !0),
                e.l_desc = new Bd(e.dyn_ltree,Nd),
                e.d_desc = new Bd(e.dyn_dtree,Ud),
                e.bl_desc = new Bd(e.bl_tree,Dd),
                e.bi_buf = 0,
                e.bi_valid = 0,
                Gd(e)
            }
            ,
            _tr_stored_block: $d,
            _tr_flush_block: eu,
            _tr_tally: (e,t,n)=>(e.pending_buf[e.sym_buf + e.sym_next++] = t,
            e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8,
            e.pending_buf[e.sym_buf + e.sym_next++] = n,
            0 === t ? e.dyn_ltree[2 * n]++ : (e.matches++,
            t--,
            e.dyn_ltree[2 * (Pd[n] + yd + 1)]++,
            e.dyn_dtree[2 * Od(t)]++),
            e.sym_next === e.sym_end),
            _tr_align: e=>{
                Fd(e, 2, 3),
                Wd(e, 256, kd),
                (e=>{
                    16 === e.bi_valid ? (zd(e, e.bi_buf),
                    e.bi_buf = 0,
                    e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf,
                    e.bi_buf >>= 8,
                    e.bi_valid -= 8)
                }
                )(e)
            }
        };
        var nu = (e,t,n,i)=>{
            let r = 65535 & e | 0
              , a = e >>> 16 & 65535 | 0
              , s = 0;
            for (; 0 !== n; ) {
                s = n > 2e3 ? 2e3 : n,
                n -= s;
                do {
                    r = r + t[i++] | 0,
                    a = a + r | 0
                } while (--s);
                r %= 65521,
                a %= 65521
            }
            return r | a << 16 | 0
        }
        ;
        const iu = new Uint32Array((()=>{
            let e, t = [];
            for (var n = 0; n < 256; n++) {
                e = n;
                for (var i = 0; i < 8; i++)
                    e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                t[n] = e
            }
            return t
        }
        )());
        var ru = (e,t,n,i)=>{
            const r = iu
              , a = i + n;
            e ^= -1;
            for (let n = i; n < a; n++)
                e = e >>> 8 ^ r[255 & (e ^ t[n])];
            return -1 ^ e
        }
          , au = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
        }
          , su = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
        };
        const {_tr_init: ou, _tr_stored_block: lu, _tr_flush_block: cu, _tr_tally: hu, _tr_align: du} = tu
          , {Z_NO_FLUSH: uu, Z_PARTIAL_FLUSH: pu, Z_FULL_FLUSH: fu, Z_FINISH: mu, Z_BLOCK: gu, Z_OK: vu, Z_STREAM_END: wu, Z_STREAM_ERROR: yu, Z_DATA_ERROR: _u, Z_BUF_ERROR: xu, Z_DEFAULT_COMPRESSION: bu, Z_FILTERED: Eu, Z_HUFFMAN_ONLY: Su, Z_RLE: Mu, Z_FIXED: Tu, Z_DEFAULT_STRATEGY: ku, Z_UNKNOWN: Cu, Z_DEFLATED: Au} = su
          , Pu = 258
          , Ru = 262
          , Lu = 42
          , Iu = 113
          , Nu = 666
          , Uu = (e,t)=>(e.msg = au[t],
        t)
          , Du = e=>2 * e - (e > 4 ? 9 : 0)
          , Bu = e=>{
            let t = e.length;
            for (; --t >= 0; )
                e[t] = 0
        }
          , Ou = e=>{
            let t, n, i, r = e.w_size;
            t = e.hash_size,
            i = t;
            do {
                n = e.head[--i],
                e.head[i] = n >= r ? n - r : 0
            } while (--t);
            t = r,
            i = t;
            do {
                n = e.prev[--i],
                e.prev[i] = n >= r ? n - r : 0
            } while (--t)
        }
        ;
        let zu = (e,t,n)=>(t << e.hash_shift ^ n) & e.hash_mask;
        const Fu = e=>{
            const t = e.state;
            let n = t.pending;
            n > e.avail_out && (n = e.avail_out),
            0 !== n && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out),
            e.next_out += n,
            t.pending_out += n,
            e.total_out += n,
            e.avail_out -= n,
            t.pending -= n,
            0 === t.pending && (t.pending_out = 0))
        }
          , Wu = (e,t)=>{
            cu(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t),
            e.block_start = e.strstart,
            Fu(e.strm)
        }
          , Hu = (e,t)=>{
            e.pending_buf[e.pending++] = t
        }
          , Vu = (e,t)=>{
            e.pending_buf[e.pending++] = t >>> 8 & 255,
            e.pending_buf[e.pending++] = 255 & t
        }
          , Gu = (e,t,n,i)=>{
            let r = e.avail_in;
            return r > i && (r = i),
            0 === r ? 0 : (e.avail_in -= r,
            t.set(e.input.subarray(e.next_in, e.next_in + r), n),
            1 === e.state.wrap ? e.adler = nu(e.adler, t, r, n) : 2 === e.state.wrap && (e.adler = ru(e.adler, t, r, n)),
            e.next_in += r,
            e.total_in += r,
            r)
        }
          , ju = (e,t)=>{
            let n, i, r = e.max_chain_length, a = e.strstart, s = e.prev_length, o = e.nice_match;
            const l = e.strstart > e.w_size - Ru ? e.strstart - (e.w_size - Ru) : 0
              , c = e.window
              , h = e.w_mask
              , d = e.prev
              , u = e.strstart + Pu;
            let p = c[a + s - 1]
              , f = c[a + s];
            e.prev_length >= e.good_match && (r >>= 2),
            o > e.lookahead && (o = e.lookahead);
            do {
                if (n = t,
                c[n + s] === f && c[n + s - 1] === p && c[n] === c[a] && c[++n] === c[a + 1]) {
                    a += 2,
                    n++;
                    do {} while (c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && a < u);
                    if (i = Pu - (u - a),
                    a = u - Pu,
                    i > s) {
                        if (e.match_start = t,
                        s = i,
                        i >= o)
                            break;
                        p = c[a + s - 1],
                        f = c[a + s]
                    }
                }
            } while ((t = d[t & h]) > l && 0 != --r);
            return s <= e.lookahead ? s : e.lookahead
        }
          , Xu = e=>{
            const t = e.w_size;
            let n, i, r;
            do {
                if (i = e.window_size - e.lookahead - e.strstart,
                e.strstart >= t + (t - Ru) && (e.window.set(e.window.subarray(t, t + t - i), 0),
                e.match_start -= t,
                e.strstart -= t,
                e.block_start -= t,
                e.insert > e.strstart && (e.insert = e.strstart),
                Ou(e),
                i += t),
                0 === e.strm.avail_in)
                    break;
                if (n = Gu(e.strm, e.window, e.strstart + e.lookahead, i),
                e.lookahead += n,
                e.lookahead + e.insert >= 3)
                    for (r = e.strstart - e.insert,
                    e.ins_h = e.window[r],
                    e.ins_h = zu(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = zu(e, e.ins_h, e.window[r + 3 - 1]),
                    e.prev[r & e.w_mask] = e.head[e.ins_h],
                    e.head[e.ins_h] = r,
                    r++,
                    e.insert--,
                    !(e.lookahead + e.insert < 3)); )
                        ;
            } while (e.lookahead < Ru && 0 !== e.strm.avail_in)
        }
          , qu = (e,t)=>{
            let n, i, r, a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, s = 0, o = e.strm.avail_in;
            do {
                if (n = 65535,
                r = e.bi_valid + 42 >> 3,
                e.strm.avail_out < r)
                    break;
                if (r = e.strm.avail_out - r,
                i = e.strstart - e.block_start,
                n > i + e.strm.avail_in && (n = i + e.strm.avail_in),
                n > r && (n = r),
                n < a && (0 === n && t !== mu || t === uu || n !== i + e.strm.avail_in))
                    break;
                s = t === mu && n === i + e.strm.avail_in ? 1 : 0,
                lu(e, 0, 0, s),
                e.pending_buf[e.pending - 4] = n,
                e.pending_buf[e.pending - 3] = n >> 8,
                e.pending_buf[e.pending - 2] = ~n,
                e.pending_buf[e.pending - 1] = ~n >> 8,
                Fu(e.strm),
                i && (i > n && (i = n),
                e.strm.output.set(e.window.subarray(e.block_start, e.block_start + i), e.strm.next_out),
                e.strm.next_out += i,
                e.strm.avail_out -= i,
                e.strm.total_out += i,
                e.block_start += i,
                n -= i),
                n && (Gu(e.strm, e.strm.output, e.strm.next_out, n),
                e.strm.next_out += n,
                e.strm.avail_out -= n,
                e.strm.total_out += n)
            } while (0 === s);
            return o -= e.strm.avail_in,
            o && (o >= e.w_size ? (e.matches = 2,
            e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0),
            e.strstart = e.w_size,
            e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size,
            e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
            e.matches < 2 && e.matches++,
            e.insert > e.strstart && (e.insert = e.strstart)),
            e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart),
            e.strstart += o,
            e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o),
            e.block_start = e.strstart),
            e.high_water < e.strstart && (e.high_water = e.strstart),
            s ? 4 : t !== uu && t !== mu && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart,
            e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size,
            e.strstart -= e.w_size,
            e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
            e.matches < 2 && e.matches++,
            r += e.w_size,
            e.insert > e.strstart && (e.insert = e.strstart)),
            r > e.strm.avail_in && (r = e.strm.avail_in),
            r && (Gu(e.strm, e.window, e.strstart, r),
            e.strstart += r,
            e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r),
            e.high_water < e.strstart && (e.high_water = e.strstart),
            r = e.bi_valid + 42 >> 3,
            r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r,
            a = r > e.w_size ? e.w_size : r,
            i = e.strstart - e.block_start,
            (i >= a || (i || t === mu) && t !== uu && 0 === e.strm.avail_in && i <= r) && (n = i > r ? r : i,
            s = t === mu && 0 === e.strm.avail_in && n === i ? 1 : 0,
            lu(e, e.block_start, n, s),
            e.block_start += n,
            Fu(e.strm)),
            s ? 3 : 1)
        }
          , Yu = (e,t)=>{
            let n, i;
            for (; ; ) {
                if (e.lookahead < Ru) {
                    if (Xu(e),
                    e.lookahead < Ru && t === uu)
                        return 1;
                    if (0 === e.lookahead)
                        break
                }
                if (n = 0,
                e.lookahead >= 3 && (e.ins_h = zu(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                e.head[e.ins_h] = e.strstart),
                0 !== n && e.strstart - n <= e.w_size - Ru && (e.match_length = ju(e, n)),
                e.match_length >= 3)
                    if (i = hu(e, e.strstart - e.match_start, e.match_length - 3),
                    e.lookahead -= e.match_length,
                    e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
                        e.match_length--;
                        do {
                            e.strstart++,
                            e.ins_h = zu(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                            n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                            e.head[e.ins_h] = e.strstart
                        } while (0 != --e.match_length);
                        e.strstart++
                    } else
                        e.strstart += e.match_length,
                        e.match_length = 0,
                        e.ins_h = e.window[e.strstart],
                        e.ins_h = zu(e, e.ins_h, e.window[e.strstart + 1]);
                else
                    i = hu(e, 0, e.window[e.strstart]),
                    e.lookahead--,
                    e.strstart++;
                if (i && (Wu(e, !1),
                0 === e.strm.avail_out))
                    return 1
            }
            return e.insert = e.strstart < 2 ? e.strstart : 2,
            t === mu ? (Wu(e, !0),
            0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Wu(e, !1),
            0 === e.strm.avail_out) ? 1 : 2
        }
          , Zu = (e,t)=>{
            let n, i, r;
            for (; ; ) {
                if (e.lookahead < Ru) {
                    if (Xu(e),
                    e.lookahead < Ru && t === uu)
                        return 1;
                    if (0 === e.lookahead)
                        break
                }
                if (n = 0,
                e.lookahead >= 3 && (e.ins_h = zu(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                e.head[e.ins_h] = e.strstart),
                e.prev_length = e.match_length,
                e.prev_match = e.match_start,
                e.match_length = 2,
                0 !== n && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - Ru && (e.match_length = ju(e, n),
                e.match_length <= 5 && (e.strategy === Eu || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)),
                e.prev_length >= 3 && e.match_length <= e.prev_length) {
                    r = e.strstart + e.lookahead - 3,
                    i = hu(e, e.strstart - 1 - e.prev_match, e.prev_length - 3),
                    e.lookahead -= e.prev_length - 1,
                    e.prev_length -= 2;
                    do {
                        ++e.strstart <= r && (e.ins_h = zu(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                        n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                        e.head[e.ins_h] = e.strstart)
                    } while (0 != --e.prev_length);
                    if (e.match_available = 0,
                    e.match_length = 2,
                    e.strstart++,
                    i && (Wu(e, !1),
                    0 === e.strm.avail_out))
                        return 1
                } else if (e.match_available) {
                    if (i = hu(e, 0, e.window[e.strstart - 1]),
                    i && Wu(e, !1),
                    e.strstart++,
                    e.lookahead--,
                    0 === e.strm.avail_out)
                        return 1
                } else
                    e.match_available = 1,
                    e.strstart++,
                    e.lookahead--
            }
            return e.match_available && (i = hu(e, 0, e.window[e.strstart - 1]),
            e.match_available = 0),
            e.insert = e.strstart < 2 ? e.strstart : 2,
            t === mu ? (Wu(e, !0),
            0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Wu(e, !1),
            0 === e.strm.avail_out) ? 1 : 2
        }
        ;
        function Ku(e, t, n, i, r) {
            this.good_length = e,
            this.max_lazy = t,
            this.nice_length = n,
            this.max_chain = i,
            this.func = r
        }
        const Ju = [new Ku(0,0,0,0,qu), new Ku(4,4,8,4,Yu), new Ku(4,5,16,8,Yu), new Ku(4,6,32,32,Yu), new Ku(4,4,16,16,Zu), new Ku(8,16,32,32,Zu), new Ku(8,16,128,128,Zu), new Ku(8,32,128,256,Zu), new Ku(32,128,258,1024,Zu), new Ku(32,258,258,4096,Zu)];
        function Qu() {
            this.strm = null,
            this.status = 0,
            this.pending_buf = null,
            this.pending_buf_size = 0,
            this.pending_out = 0,
            this.pending = 0,
            this.wrap = 0,
            this.gzhead = null,
            this.gzindex = 0,
            this.method = Au,
            this.last_flush = -1,
            this.w_size = 0,
            this.w_bits = 0,
            this.w_mask = 0,
            this.window = null,
            this.window_size = 0,
            this.prev = null,
            this.head = null,
            this.ins_h = 0,
            this.hash_size = 0,
            this.hash_bits = 0,
            this.hash_mask = 0,
            this.hash_shift = 0,
            this.block_start = 0,
            this.match_length = 0,
            this.prev_match = 0,
            this.match_available = 0,
            this.strstart = 0,
            this.match_start = 0,
            this.lookahead = 0,
            this.prev_length = 0,
            this.max_chain_length = 0,
            this.max_lazy_match = 0,
            this.level = 0,
            this.strategy = 0,
            this.good_match = 0,
            this.nice_match = 0,
            this.dyn_ltree = new Uint16Array(1146),
            this.dyn_dtree = new Uint16Array(122),
            this.bl_tree = new Uint16Array(78),
            Bu(this.dyn_ltree),
            Bu(this.dyn_dtree),
            Bu(this.bl_tree),
            this.l_desc = null,
            this.d_desc = null,
            this.bl_desc = null,
            this.bl_count = new Uint16Array(16),
            this.heap = new Uint16Array(573),
            Bu(this.heap),
            this.heap_len = 0,
            this.heap_max = 0,
            this.depth = new Uint16Array(573),
            Bu(this.depth),
            this.sym_buf = 0,
            this.lit_bufsize = 0,
            this.sym_next = 0,
            this.sym_end = 0,
            this.opt_len = 0,
            this.static_len = 0,
            this.matches = 0,
            this.insert = 0,
            this.bi_buf = 0,
            this.bi_valid = 0
        }
        const $u = e=>{
            if (!e)
                return 1;
            const t = e.state;
            return !t || t.strm !== e || t.status !== Lu && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== Iu && t.status !== Nu ? 1 : 0
        }
          , ep = e=>{
            if ($u(e))
                return Uu(e, yu);
            e.total_in = e.total_out = 0,
            e.data_type = Cu;
            const t = e.state;
            return t.pending = 0,
            t.pending_out = 0,
            t.wrap < 0 && (t.wrap = -t.wrap),
            t.status = 2 === t.wrap ? 57 : t.wrap ? Lu : Iu,
            e.adler = 2 === t.wrap ? 0 : 1,
            t.last_flush = -2,
            ou(t),
            vu
        }
          , tp = e=>{
            const t = ep(e);
            var n;
            return t === vu && ((n = e.state).window_size = 2 * n.w_size,
            Bu(n.head),
            n.max_lazy_match = Ju[n.level].max_lazy,
            n.good_match = Ju[n.level].good_length,
            n.nice_match = Ju[n.level].nice_length,
            n.max_chain_length = Ju[n.level].max_chain,
            n.strstart = 0,
            n.block_start = 0,
            n.lookahead = 0,
            n.insert = 0,
            n.match_length = n.prev_length = 2,
            n.match_available = 0,
            n.ins_h = 0),
            t
        }
          , np = (e,t,n,i,r,a)=>{
            if (!e)
                return yu;
            let s = 1;
            if (t === bu && (t = 6),
            i < 0 ? (s = 0,
            i = -i) : i > 15 && (s = 2,
            i -= 16),
            r < 1 || r > 9 || n !== Au || i < 8 || i > 15 || t < 0 || t > 9 || a < 0 || a > Tu || 8 === i && 1 !== s)
                return Uu(e, yu);
            8 === i && (i = 9);
            const o = new Qu;
            return e.state = o,
            o.strm = e,
            o.status = Lu,
            o.wrap = s,
            o.gzhead = null,
            o.w_bits = i,
            o.w_size = 1 << o.w_bits,
            o.w_mask = o.w_size - 1,
            o.hash_bits = r + 7,
            o.hash_size = 1 << o.hash_bits,
            o.hash_mask = o.hash_size - 1,
            o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3),
            o.window = new Uint8Array(2 * o.w_size),
            o.head = new Uint16Array(o.hash_size),
            o.prev = new Uint16Array(o.w_size),
            o.lit_bufsize = 1 << r + 6,
            o.pending_buf_size = 4 * o.lit_bufsize,
            o.pending_buf = new Uint8Array(o.pending_buf_size),
            o.sym_buf = o.lit_bufsize,
            o.sym_end = 3 * (o.lit_bufsize - 1),
            o.level = t,
            o.strategy = a,
            o.method = n,
            tp(e)
        }
        ;
        var ip = {
            deflateInit: (e,t)=>np(e, t, Au, 15, 8, ku),
            deflateInit2: np,
            deflateReset: tp,
            deflateResetKeep: ep,
            deflateSetHeader: (e,t)=>$u(e) || 2 !== e.state.wrap ? yu : (e.state.gzhead = t,
            vu),
            deflate: (e,t)=>{
                if ($u(e) || t > gu || t < 0)
                    return e ? Uu(e, yu) : yu;
                const n = e.state;
                if (!e.output || 0 !== e.avail_in && !e.input || n.status === Nu && t !== mu)
                    return Uu(e, 0 === e.avail_out ? xu : yu);
                const i = n.last_flush;
                if (n.last_flush = t,
                0 !== n.pending) {
                    if (Fu(e),
                    0 === e.avail_out)
                        return n.last_flush = -1,
                        vu
                } else if (0 === e.avail_in && Du(t) <= Du(i) && t !== mu)
                    return Uu(e, xu);
                if (n.status === Nu && 0 !== e.avail_in)
                    return Uu(e, xu);
                if (n.status === Lu && 0 === n.wrap && (n.status = Iu),
                n.status === Lu) {
                    let t = Au + (n.w_bits - 8 << 4) << 8
                      , i = -1;
                    if (i = n.strategy >= Su || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3,
                    t |= i << 6,
                    0 !== n.strstart && (t |= 32),
                    t += 31 - t % 31,
                    Vu(n, t),
                    0 !== n.strstart && (Vu(n, e.adler >>> 16),
                    Vu(n, 65535 & e.adler)),
                    e.adler = 1,
                    n.status = Iu,
                    Fu(e),
                    0 !== n.pending)
                        return n.last_flush = -1,
                        vu
                }
                if (57 === n.status)
                    if (e.adler = 0,
                    Hu(n, 31),
                    Hu(n, 139),
                    Hu(n, 8),
                    n.gzhead)
                        Hu(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)),
                        Hu(n, 255 & n.gzhead.time),
                        Hu(n, n.gzhead.time >> 8 & 255),
                        Hu(n, n.gzhead.time >> 16 & 255),
                        Hu(n, n.gzhead.time >> 24 & 255),
                        Hu(n, 9 === n.level ? 2 : n.strategy >= Su || n.level < 2 ? 4 : 0),
                        Hu(n, 255 & n.gzhead.os),
                        n.gzhead.extra && n.gzhead.extra.length && (Hu(n, 255 & n.gzhead.extra.length),
                        Hu(n, n.gzhead.extra.length >> 8 & 255)),
                        n.gzhead.hcrc && (e.adler = ru(e.adler, n.pending_buf, n.pending, 0)),
                        n.gzindex = 0,
                        n.status = 69;
                    else if (Hu(n, 0),
                    Hu(n, 0),
                    Hu(n, 0),
                    Hu(n, 0),
                    Hu(n, 0),
                    Hu(n, 9 === n.level ? 2 : n.strategy >= Su || n.level < 2 ? 4 : 0),
                    Hu(n, 3),
                    n.status = Iu,
                    Fu(e),
                    0 !== n.pending)
                        return n.last_flush = -1,
                        vu;
                if (69 === n.status) {
                    if (n.gzhead.extra) {
                        let t = n.pending
                          , i = (65535 & n.gzhead.extra.length) - n.gzindex;
                        for (; n.pending + i > n.pending_buf_size; ) {
                            let r = n.pending_buf_size - n.pending;
                            if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + r), n.pending),
                            n.pending = n.pending_buf_size,
                            n.gzhead.hcrc && n.pending > t && (e.adler = ru(e.adler, n.pending_buf, n.pending - t, t)),
                            n.gzindex += r,
                            Fu(e),
                            0 !== n.pending)
                                return n.last_flush = -1,
                                vu;
                            t = 0,
                            i -= r
                        }
                        let r = new Uint8Array(n.gzhead.extra);
                        n.pending_buf.set(r.subarray(n.gzindex, n.gzindex + i), n.pending),
                        n.pending += i,
                        n.gzhead.hcrc && n.pending > t && (e.adler = ru(e.adler, n.pending_buf, n.pending - t, t)),
                        n.gzindex = 0
                    }
                    n.status = 73
                }
                if (73 === n.status) {
                    if (n.gzhead.name) {
                        let t, i = n.pending;
                        do {
                            if (n.pending === n.pending_buf_size) {
                                if (n.gzhead.hcrc && n.pending > i && (e.adler = ru(e.adler, n.pending_buf, n.pending - i, i)),
                                Fu(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                    vu;
                                i = 0
                            }
                            t = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0,
                            Hu(n, t)
                        } while (0 !== t);
                        n.gzhead.hcrc && n.pending > i && (e.adler = ru(e.adler, n.pending_buf, n.pending - i, i)),
                        n.gzindex = 0
                    }
                    n.status = 91
                }
                if (91 === n.status) {
                    if (n.gzhead.comment) {
                        let t, i = n.pending;
                        do {
                            if (n.pending === n.pending_buf_size) {
                                if (n.gzhead.hcrc && n.pending > i && (e.adler = ru(e.adler, n.pending_buf, n.pending - i, i)),
                                Fu(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                    vu;
                                i = 0
                            }
                            t = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0,
                            Hu(n, t)
                        } while (0 !== t);
                        n.gzhead.hcrc && n.pending > i && (e.adler = ru(e.adler, n.pending_buf, n.pending - i, i))
                    }
                    n.status = 103
                }
                if (103 === n.status) {
                    if (n.gzhead.hcrc) {
                        if (n.pending + 2 > n.pending_buf_size && (Fu(e),
                        0 !== n.pending))
                            return n.last_flush = -1,
                            vu;
                        Hu(n, 255 & e.adler),
                        Hu(n, e.adler >> 8 & 255),
                        e.adler = 0
                    }
                    if (n.status = Iu,
                    Fu(e),
                    0 !== n.pending)
                        return n.last_flush = -1,
                        vu
                }
                if (0 !== e.avail_in || 0 !== n.lookahead || t !== uu && n.status !== Nu) {
                    let i = 0 === n.level ? qu(n, t) : n.strategy === Su ? ((e,t)=>{
                        let n;
                        for (; ; ) {
                            if (0 === e.lookahead && (Xu(e),
                            0 === e.lookahead)) {
                                if (t === uu)
                                    return 1;
                                break
                            }
                            if (e.match_length = 0,
                            n = hu(e, 0, e.window[e.strstart]),
                            e.lookahead--,
                            e.strstart++,
                            n && (Wu(e, !1),
                            0 === e.strm.avail_out))
                                return 1
                        }
                        return e.insert = 0,
                        t === mu ? (Wu(e, !0),
                        0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Wu(e, !1),
                        0 === e.strm.avail_out) ? 1 : 2
                    }
                    )(n, t) : n.strategy === Mu ? ((e,t)=>{
                        let n, i, r, a;
                        const s = e.window;
                        for (; ; ) {
                            if (e.lookahead <= Pu) {
                                if (Xu(e),
                                e.lookahead <= Pu && t === uu)
                                    return 1;
                                if (0 === e.lookahead)
                                    break
                            }
                            if (e.match_length = 0,
                            e.lookahead >= 3 && e.strstart > 0 && (r = e.strstart - 1,
                            i = s[r],
                            i === s[++r] && i === s[++r] && i === s[++r])) {
                                a = e.strstart + Pu;
                                do {} while (i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && r < a);
                                e.match_length = Pu - (a - r),
                                e.match_length > e.lookahead && (e.match_length = e.lookahead)
                            }
                            if (e.match_length >= 3 ? (n = hu(e, 1, e.match_length - 3),
                            e.lookahead -= e.match_length,
                            e.strstart += e.match_length,
                            e.match_length = 0) : (n = hu(e, 0, e.window[e.strstart]),
                            e.lookahead--,
                            e.strstart++),
                            n && (Wu(e, !1),
                            0 === e.strm.avail_out))
                                return 1
                        }
                        return e.insert = 0,
                        t === mu ? (Wu(e, !0),
                        0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (Wu(e, !1),
                        0 === e.strm.avail_out) ? 1 : 2
                    }
                    )(n, t) : Ju[n.level].func(n, t);
                    if (3 !== i && 4 !== i || (n.status = Nu),
                    1 === i || 3 === i)
                        return 0 === e.avail_out && (n.last_flush = -1),
                        vu;
                    if (2 === i && (t === pu ? du(n) : t !== gu && (lu(n, 0, 0, !1),
                    t === fu && (Bu(n.head),
                    0 === n.lookahead && (n.strstart = 0,
                    n.block_start = 0,
                    n.insert = 0))),
                    Fu(e),
                    0 === e.avail_out))
                        return n.last_flush = -1,
                        vu
                }
                return t !== mu ? vu : n.wrap <= 0 ? wu : (2 === n.wrap ? (Hu(n, 255 & e.adler),
                Hu(n, e.adler >> 8 & 255),
                Hu(n, e.adler >> 16 & 255),
                Hu(n, e.adler >> 24 & 255),
                Hu(n, 255 & e.total_in),
                Hu(n, e.total_in >> 8 & 255),
                Hu(n, e.total_in >> 16 & 255),
                Hu(n, e.total_in >> 24 & 255)) : (Vu(n, e.adler >>> 16),
                Vu(n, 65535 & e.adler)),
                Fu(e),
                n.wrap > 0 && (n.wrap = -n.wrap),
                0 !== n.pending ? vu : wu)
            }
            ,
            deflateEnd: e=>{
                if ($u(e))
                    return yu;
                const t = e.state.status;
                return e.state = null,
                t === Iu ? Uu(e, _u) : vu
            }
            ,
            deflateSetDictionary: (e,t)=>{
                let n = t.length;
                if ($u(e))
                    return yu;
                const i = e.state
                  , r = i.wrap;
                if (2 === r || 1 === r && i.status !== Lu || i.lookahead)
                    return yu;
                if (1 === r && (e.adler = nu(e.adler, t, n, 0)),
                i.wrap = 0,
                n >= i.w_size) {
                    0 === r && (Bu(i.head),
                    i.strstart = 0,
                    i.block_start = 0,
                    i.insert = 0);
                    let e = new Uint8Array(i.w_size);
                    e.set(t.subarray(n - i.w_size, n), 0),
                    t = e,
                    n = i.w_size
                }
                const a = e.avail_in
                  , s = e.next_in
                  , o = e.input;
                for (e.avail_in = n,
                e.next_in = 0,
                e.input = t,
                Xu(i); i.lookahead >= 3; ) {
                    let e = i.strstart
                      , t = i.lookahead - 2;
                    do {
                        i.ins_h = zu(i, i.ins_h, i.window[e + 3 - 1]),
                        i.prev[e & i.w_mask] = i.head[i.ins_h],
                        i.head[i.ins_h] = e,
                        e++
                    } while (--t);
                    i.strstart = e,
                    i.lookahead = 2,
                    Xu(i)
                }
                return i.strstart += i.lookahead,
                i.block_start = i.strstart,
                i.insert = i.lookahead,
                i.lookahead = 0,
                i.match_length = i.prev_length = 2,
                i.match_available = 0,
                e.next_in = s,
                e.input = o,
                e.avail_in = a,
                i.wrap = r,
                vu
            }
            ,
            deflateInfo: "pako deflate (from Nodeca project)"
        };
        const rp = (e,t)=>Object.prototype.hasOwnProperty.call(e, t);
        var ap = function(e) {
            const t = Array.prototype.slice.call(arguments, 1);
            for (; t.length; ) {
                const n = t.shift();
                if (n) {
                    if ("object" != typeof n)
                        throw new TypeError(n + "must be non-object");
                    for (const t in n)
                        rp(n, t) && (e[t] = n[t])
                }
            }
            return e
        }
          , sp = e=>{
            let t = 0;
            for (let n = 0, i = e.length; n < i; n++)
                t += e[n].length;
            const n = new Uint8Array(t);
            for (let t = 0, i = 0, r = e.length; t < r; t++) {
                let r = e[t];
                n.set(r, i),
                i += r.length
            }
            return n
        }
        ;
        let op = !0;
        try {
            String.fromCharCode.apply(null, new Uint8Array(1))
        } catch (e) {
            op = !1
        }
        const lp = new Uint8Array(256);
        for (let e = 0; e < 256; e++)
            lp[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
        lp[254] = lp[254] = 1;
        var cp = e=>{
            if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
                return (new TextEncoder).encode(e);
            let t, n, i, r, a, s = e.length, o = 0;
            for (r = 0; r < s; r++)
                n = e.charCodeAt(r),
                55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                r++)),
                o += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
            for (t = new Uint8Array(o),
            a = 0,
            r = 0; a < o; r++)
                n = e.charCodeAt(r),
                55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                r++)),
                n < 128 ? t[a++] = n : n < 2048 ? (t[a++] = 192 | n >>> 6,
                t[a++] = 128 | 63 & n) : n < 65536 ? (t[a++] = 224 | n >>> 12,
                t[a++] = 128 | n >>> 6 & 63,
                t[a++] = 128 | 63 & n) : (t[a++] = 240 | n >>> 18,
                t[a++] = 128 | n >>> 12 & 63,
                t[a++] = 128 | n >>> 6 & 63,
                t[a++] = 128 | 63 & n);
            return t
        }
          , hp = (e,t)=>{
            const n = t || e.length;
            if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
                return (new TextDecoder).decode(e.subarray(0, t));
            let i, r;
            const a = new Array(2 * n);
            for (r = 0,
            i = 0; i < n; ) {
                let t = e[i++];
                if (t < 128) {
                    a[r++] = t;
                    continue
                }
                let s = lp[t];
                if (s > 4)
                    a[r++] = 65533,
                    i += s - 1;
                else {
                    for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && i < n; )
                        t = t << 6 | 63 & e[i++],
                        s--;
                    s > 1 ? a[r++] = 65533 : t < 65536 ? a[r++] = t : (t -= 65536,
                    a[r++] = 55296 | t >> 10 & 1023,
                    a[r++] = 56320 | 1023 & t)
                }
            }
            return ((e,t)=>{
                if (t < 65534 && e.subarray && op)
                    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                let n = "";
                for (let i = 0; i < t; i++)
                    n += String.fromCharCode(e[i]);
                return n
            }
            )(a, r)
        }
          , dp = (e,t)=>{
            (t = t || e.length) > e.length && (t = e.length);
            let n = t - 1;
            for (; n >= 0 && 128 == (192 & e[n]); )
                n--;
            return n < 0 || 0 === n ? t : n + lp[e[n]] > t ? n : t
        }
        ;
        var up = function() {
            this.input = null,
            this.next_in = 0,
            this.avail_in = 0,
            this.total_in = 0,
            this.output = null,
            this.next_out = 0,
            this.avail_out = 0,
            this.total_out = 0,
            this.msg = "",
            this.state = null,
            this.data_type = 2,
            this.adler = 0
        };
        const pp = Object.prototype.toString
          , {Z_NO_FLUSH: fp, Z_SYNC_FLUSH: mp, Z_FULL_FLUSH: gp, Z_FINISH: vp, Z_OK: wp, Z_STREAM_END: yp, Z_DEFAULT_COMPRESSION: _p, Z_DEFAULT_STRATEGY: xp, Z_DEFLATED: bp} = su;
        function Ep(e) {
            this.options = ap({
                level: _p,
                method: bp,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: xp
            }, e || {});
            let t = this.options;
            t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16),
            this.err = 0,
            this.msg = "",
            this.ended = !1,
            this.chunks = [],
            this.strm = new up,
            this.strm.avail_out = 0;
            let n = ip.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
            if (n !== wp)
                throw new Error(au[n]);
            if (t.header && ip.deflateSetHeader(this.strm, t.header),
            t.dictionary) {
                let e;
                if (e = "string" == typeof t.dictionary ? cp(t.dictionary) : "[object ArrayBuffer]" === pp.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary,
                n = ip.deflateSetDictionary(this.strm, e),
                n !== wp)
                    throw new Error(au[n]);
                this._dict_set = !0
            }
        }
        function Sp(e, t) {
            const n = new Ep(t);
            if (n.push(e, !0),
            n.err)
                throw n.msg || au[n.err];
            return n.result
        }
        Ep.prototype.push = function(e, t) {
            const n = this.strm
              , i = this.options.chunkSize;
            let r, a;
            if (this.ended)
                return !1;
            for (a = t === ~~t ? t : !0 === t ? vp : fp,
            "string" == typeof e ? n.input = cp(e) : "[object ArrayBuffer]" === pp.call(e) ? n.input = new Uint8Array(e) : n.input = e,
            n.next_in = 0,
            n.avail_in = n.input.length; ; )
                if (0 === n.avail_out && (n.output = new Uint8Array(i),
                n.next_out = 0,
                n.avail_out = i),
                (a === mp || a === gp) && n.avail_out <= 6)
                    this.onData(n.output.subarray(0, n.next_out)),
                    n.avail_out = 0;
                else {
                    if (r = ip.deflate(n, a),
                    r === yp)
                        return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)),
                        r = ip.deflateEnd(this.strm),
                        this.onEnd(r),
                        this.ended = !0,
                        r === wp;
                    if (0 !== n.avail_out) {
                        if (a > 0 && n.next_out > 0)
                            this.onData(n.output.subarray(0, n.next_out)),
                            n.avail_out = 0;
                        else if (0 === n.avail_in)
                            break
                    } else
                        this.onData(n.output)
                }
            return !0
        }
        ,
        Ep.prototype.onData = function(e) {
            this.chunks.push(e)
        }
        ,
        Ep.prototype.onEnd = function(e) {
            e === wp && (this.result = sp(this.chunks)),
            this.chunks = [],
            this.err = e,
            this.msg = this.strm.msg
        }
        ;
        var Mp = function(e, t) {
            return (t = t || {}).raw = !0,
            Sp(e, t)
        }
          , Tp = function(e, t) {
            return (t = t || {}).gzip = !0,
            Sp(e, t)
        }
          , kp = {
            Deflate: Ep,
            deflate: Sp,
            deflateRaw: Mp,
            gzip: Tp,
            constants: su
        };
        const Cp = 16209;
        var Ap = function(e, t) {
            let n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, y, _, x, b, E, S, M;
            const T = e.state;
            n = e.next_in,
            S = e.input,
            i = n + (e.avail_in - 5),
            r = e.next_out,
            M = e.output,
            a = r - (t - e.avail_out),
            s = r + (e.avail_out - 257),
            o = T.dmax,
            l = T.wsize,
            c = T.whave,
            h = T.wnext,
            d = T.window,
            u = T.hold,
            p = T.bits,
            f = T.lencode,
            m = T.distcode,
            g = (1 << T.lenbits) - 1,
            v = (1 << T.distbits) - 1;
            e: do {
                p < 15 && (u += S[n++] << p,
                p += 8,
                u += S[n++] << p,
                p += 8),
                w = f[u & g];
                t: for (; ; ) {
                    if (y = w >>> 24,
                    u >>>= y,
                    p -= y,
                    y = w >>> 16 & 255,
                    0 === y)
                        M[r++] = 65535 & w;
                    else {
                        if (!(16 & y)) {
                            if (0 == (64 & y)) {
                                w = f[(65535 & w) + (u & (1 << y) - 1)];
                                continue t
                            }
                            if (32 & y) {
                                T.mode = 16191;
                                break e
                            }
                            e.msg = "invalid literal/length code",
                            T.mode = Cp;
                            break e
                        }
                        _ = 65535 & w,
                        y &= 15,
                        y && (p < y && (u += S[n++] << p,
                        p += 8),
                        _ += u & (1 << y) - 1,
                        u >>>= y,
                        p -= y),
                        p < 15 && (u += S[n++] << p,
                        p += 8,
                        u += S[n++] << p,
                        p += 8),
                        w = m[u & v];
                        n: for (; ; ) {
                            if (y = w >>> 24,
                            u >>>= y,
                            p -= y,
                            y = w >>> 16 & 255,
                            !(16 & y)) {
                                if (0 == (64 & y)) {
                                    w = m[(65535 & w) + (u & (1 << y) - 1)];
                                    continue n
                                }
                                e.msg = "invalid distance code",
                                T.mode = Cp;
                                break e
                            }
                            if (x = 65535 & w,
                            y &= 15,
                            p < y && (u += S[n++] << p,
                            p += 8,
                            p < y && (u += S[n++] << p,
                            p += 8)),
                            x += u & (1 << y) - 1,
                            x > o) {
                                e.msg = "invalid distance too far back",
                                T.mode = Cp;
                                break e
                            }
                            if (u >>>= y,
                            p -= y,
                            y = r - a,
                            x > y) {
                                if (y = x - y,
                                y > c && T.sane) {
                                    e.msg = "invalid distance too far back",
                                    T.mode = Cp;
                                    break e
                                }
                                if (b = 0,
                                E = d,
                                0 === h) {
                                    if (b += l - y,
                                    y < _) {
                                        _ -= y;
                                        do {
                                            M[r++] = d[b++]
                                        } while (--y);
                                        b = r - x,
                                        E = M
                                    }
                                } else if (h < y) {
                                    if (b += l + h - y,
                                    y -= h,
                                    y < _) {
                                        _ -= y;
                                        do {
                                            M[r++] = d[b++]
                                        } while (--y);
                                        if (b = 0,
                                        h < _) {
                                            y = h,
                                            _ -= y;
                                            do {
                                                M[r++] = d[b++]
                                            } while (--y);
                                            b = r - x,
                                            E = M
                                        }
                                    }
                                } else if (b += h - y,
                                y < _) {
                                    _ -= y;
                                    do {
                                        M[r++] = d[b++]
                                    } while (--y);
                                    b = r - x,
                                    E = M
                                }
                                for (; _ > 2; )
                                    M[r++] = E[b++],
                                    M[r++] = E[b++],
                                    M[r++] = E[b++],
                                    _ -= 3;
                                _ && (M[r++] = E[b++],
                                _ > 1 && (M[r++] = E[b++]))
                            } else {
                                b = r - x;
                                do {
                                    M[r++] = M[b++],
                                    M[r++] = M[b++],
                                    M[r++] = M[b++],
                                    _ -= 3
                                } while (_ > 2);
                                _ && (M[r++] = M[b++],
                                _ > 1 && (M[r++] = M[b++]))
                            }
                            break
                        }
                    }
                    break
                }
            } while (n < i && r < s);
            _ = p >> 3,
            n -= _,
            p -= _ << 3,
            u &= (1 << p) - 1,
            e.next_in = n,
            e.next_out = r,
            e.avail_in = n < i ? i - n + 5 : 5 - (n - i),
            e.avail_out = r < s ? s - r + 257 : 257 - (r - s),
            T.hold = u,
            T.bits = p
        };
        const Pp = 15
          , Rp = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
          , Lp = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
          , Ip = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
          , Np = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
        var Up = (e,t,n,i,r,a,s,o)=>{
            const l = o.bits;
            let c, h, d, u, p, f, m = 0, g = 0, v = 0, w = 0, y = 0, _ = 0, x = 0, b = 0, E = 0, S = 0, M = null;
            const T = new Uint16Array(16)
              , k = new Uint16Array(16);
            let C, A, P, R = null;
            for (m = 0; m <= Pp; m++)
                T[m] = 0;
            for (g = 0; g < i; g++)
                T[t[n + g]]++;
            for (y = l,
            w = Pp; w >= 1 && 0 === T[w]; w--)
                ;
            if (y > w && (y = w),
            0 === w)
                return r[a++] = 20971520,
                r[a++] = 20971520,
                o.bits = 1,
                0;
            for (v = 1; v < w && 0 === T[v]; v++)
                ;
            for (y < v && (y = v),
            b = 1,
            m = 1; m <= Pp; m++)
                if (b <<= 1,
                b -= T[m],
                b < 0)
                    return -1;
            if (b > 0 && (0 === e || 1 !== w))
                return -1;
            for (k[1] = 0,
            m = 1; m < Pp; m++)
                k[m + 1] = k[m] + T[m];
            for (g = 0; g < i; g++)
                0 !== t[n + g] && (s[k[t[n + g]]++] = g);
            if (0 === e ? (M = R = s,
            f = 20) : 1 === e ? (M = Rp,
            R = Lp,
            f = 257) : (M = Ip,
            R = Np,
            f = 0),
            S = 0,
            g = 0,
            m = v,
            p = a,
            _ = y,
            x = 0,
            d = -1,
            E = 1 << y,
            u = E - 1,
            1 === e && E > 852 || 2 === e && E > 592)
                return 1;
            for (; ; ) {
                C = m - x,
                s[g] + 1 < f ? (A = 0,
                P = s[g]) : s[g] >= f ? (A = R[s[g] - f],
                P = M[s[g] - f]) : (A = 96,
                P = 0),
                c = 1 << m - x,
                h = 1 << _,
                v = h;
                do {
                    h -= c,
                    r[p + (S >> x) + h] = C << 24 | A << 16 | P | 0
                } while (0 !== h);
                for (c = 1 << m - 1; S & c; )
                    c >>= 1;
                if (0 !== c ? (S &= c - 1,
                S += c) : S = 0,
                g++,
                0 == --T[m]) {
                    if (m === w)
                        break;
                    m = t[n + s[g]]
                }
                if (m > y && (S & u) !== d) {
                    for (0 === x && (x = y),
                    p += v,
                    _ = m - x,
                    b = 1 << _; _ + x < w && (b -= T[_ + x],
                    !(b <= 0)); )
                        _++,
                        b <<= 1;
                    if (E += 1 << _,
                    1 === e && E > 852 || 2 === e && E > 592)
                        return 1;
                    d = S & u,
                    r[d] = y << 24 | _ << 16 | p - a | 0
                }
            }
            return 0 !== S && (r[p + S] = m - x << 24 | 64 << 16 | 0),
            o.bits = y,
            0
        }
        ;
        const {Z_FINISH: Dp, Z_BLOCK: Bp, Z_TREES: Op, Z_OK: zp, Z_STREAM_END: Fp, Z_NEED_DICT: Wp, Z_STREAM_ERROR: Hp, Z_DATA_ERROR: Vp, Z_MEM_ERROR: Gp, Z_BUF_ERROR: jp, Z_DEFLATED: Xp} = su
          , qp = 16180
          , Yp = 16190
          , Zp = 16191
          , Kp = 16192
          , Jp = 16194
          , Qp = 16199
          , $p = 16200
          , ef = 16206
          , tf = 16209
          , nf = e=>(e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
        function rf() {
            this.strm = null,
            this.mode = 0,
            this.last = !1,
            this.wrap = 0,
            this.havedict = !1,
            this.flags = 0,
            this.dmax = 0,
            this.check = 0,
            this.total = 0,
            this.head = null,
            this.wbits = 0,
            this.wsize = 0,
            this.whave = 0,
            this.wnext = 0,
            this.window = null,
            this.hold = 0,
            this.bits = 0,
            this.length = 0,
            this.offset = 0,
            this.extra = 0,
            this.lencode = null,
            this.distcode = null,
            this.lenbits = 0,
            this.distbits = 0,
            this.ncode = 0,
            this.nlen = 0,
            this.ndist = 0,
            this.have = 0,
            this.next = null,
            this.lens = new Uint16Array(320),
            this.work = new Uint16Array(288),
            this.lendyn = null,
            this.distdyn = null,
            this.sane = 0,
            this.back = 0,
            this.was = 0
        }
        const af = e=>{
            if (!e)
                return 1;
            const t = e.state;
            return !t || t.strm !== e || t.mode < qp || t.mode > 16211 ? 1 : 0
        }
          , sf = e=>{
            if (af(e))
                return Hp;
            const t = e.state;
            return e.total_in = e.total_out = t.total = 0,
            e.msg = "",
            t.wrap && (e.adler = 1 & t.wrap),
            t.mode = qp,
            t.last = 0,
            t.havedict = 0,
            t.flags = -1,
            t.dmax = 32768,
            t.head = null,
            t.hold = 0,
            t.bits = 0,
            t.lencode = t.lendyn = new Int32Array(852),
            t.distcode = t.distdyn = new Int32Array(592),
            t.sane = 1,
            t.back = -1,
            zp
        }
          , of = e=>{
            if (af(e))
                return Hp;
            const t = e.state;
            return t.wsize = 0,
            t.whave = 0,
            t.wnext = 0,
            sf(e)
        }
          , lf = (e,t)=>{
            let n;
            if (af(e))
                return Hp;
            const i = e.state;
            return t < 0 ? (n = 0,
            t = -t) : (n = 5 + (t >> 4),
            t < 48 && (t &= 15)),
            t && (t < 8 || t > 15) ? Hp : (null !== i.window && i.wbits !== t && (i.window = null),
            i.wrap = n,
            i.wbits = t,
            of(e))
        }
          , cf = (e,t)=>{
            if (!e)
                return Hp;
            const n = new rf;
            e.state = n,
            n.strm = e,
            n.window = null,
            n.mode = qp;
            const i = lf(e, t);
            return i !== zp && (e.state = null),
            i
        }
        ;
        let hf, df, uf = !0;
        const pf = e=>{
            if (uf) {
                hf = new Int32Array(512),
                df = new Int32Array(32);
                let t = 0;
                for (; t < 144; )
                    e.lens[t++] = 8;
                for (; t < 256; )
                    e.lens[t++] = 9;
                for (; t < 280; )
                    e.lens[t++] = 7;
                for (; t < 288; )
                    e.lens[t++] = 8;
                for (Up(1, e.lens, 0, 288, hf, 0, e.work, {
                    bits: 9
                }),
                t = 0; t < 32; )
                    e.lens[t++] = 5;
                Up(2, e.lens, 0, 32, df, 0, e.work, {
                    bits: 5
                }),
                uf = !1
            }
            e.lencode = hf,
            e.lenbits = 9,
            e.distcode = df,
            e.distbits = 5
        }
          , ff = (e,t,n,i)=>{
            let r;
            const a = e.state;
            return null === a.window && (a.wsize = 1 << a.wbits,
            a.wnext = 0,
            a.whave = 0,
            a.window = new Uint8Array(a.wsize)),
            i >= a.wsize ? (a.window.set(t.subarray(n - a.wsize, n), 0),
            a.wnext = 0,
            a.whave = a.wsize) : (r = a.wsize - a.wnext,
            r > i && (r = i),
            a.window.set(t.subarray(n - i, n - i + r), a.wnext),
            (i -= r) ? (a.window.set(t.subarray(n - i, n), 0),
            a.wnext = i,
            a.whave = a.wsize) : (a.wnext += r,
            a.wnext === a.wsize && (a.wnext = 0),
            a.whave < a.wsize && (a.whave += r))),
            0
        }
        ;
        var mf = {
            inflateReset: of,
            inflateReset2: lf,
            inflateResetKeep: sf,
            inflateInit: e=>cf(e, 15),
            inflateInit2: cf,
            inflate: (e,t)=>{
                let n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, y, _, x, b, E, S = 0;
                const M = new Uint8Array(4);
                let T, k;
                const C = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                if (af(e) || !e.output || !e.input && 0 !== e.avail_in)
                    return Hp;
                n = e.state,
                n.mode === Zp && (n.mode = Kp),
                s = e.next_out,
                r = e.output,
                l = e.avail_out,
                a = e.next_in,
                i = e.input,
                o = e.avail_in,
                c = n.hold,
                h = n.bits,
                d = o,
                u = l,
                E = zp;
                e: for (; ; )
                    switch (n.mode) {
                    case qp:
                        if (0 === n.wrap) {
                            n.mode = Kp;
                            break
                        }
                        for (; h < 16; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (2 & n.wrap && 35615 === c) {
                            0 === n.wbits && (n.wbits = 15),
                            n.check = 0,
                            M[0] = 255 & c,
                            M[1] = c >>> 8 & 255,
                            n.check = ru(n.check, M, 2, 0),
                            c = 0,
                            h = 0,
                            n.mode = 16181;
                            break
                        }
                        if (n.head && (n.head.done = !1),
                        !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31) {
                            e.msg = "incorrect header check",
                            n.mode = tf;
                            break
                        }
                        if ((15 & c) !== Xp) {
                            e.msg = "unknown compression method",
                            n.mode = tf;
                            break
                        }
                        if (c >>>= 4,
                        h -= 4,
                        b = 8 + (15 & c),
                        0 === n.wbits && (n.wbits = b),
                        b > 15 || b > n.wbits) {
                            e.msg = "invalid window size",
                            n.mode = tf;
                            break
                        }
                        n.dmax = 1 << n.wbits,
                        n.flags = 0,
                        e.adler = n.check = 1,
                        n.mode = 512 & c ? 16189 : Zp,
                        c = 0,
                        h = 0;
                        break;
                    case 16181:
                        for (; h < 16; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (n.flags = c,
                        (255 & n.flags) !== Xp) {
                            e.msg = "unknown compression method",
                            n.mode = tf;
                            break
                        }
                        if (57344 & n.flags) {
                            e.msg = "unknown header flags set",
                            n.mode = tf;
                            break
                        }
                        n.head && (n.head.text = c >> 8 & 1),
                        512 & n.flags && 4 & n.wrap && (M[0] = 255 & c,
                        M[1] = c >>> 8 & 255,
                        n.check = ru(n.check, M, 2, 0)),
                        c = 0,
                        h = 0,
                        n.mode = 16182;
                    case 16182:
                        for (; h < 32; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        n.head && (n.head.time = c),
                        512 & n.flags && 4 & n.wrap && (M[0] = 255 & c,
                        M[1] = c >>> 8 & 255,
                        M[2] = c >>> 16 & 255,
                        M[3] = c >>> 24 & 255,
                        n.check = ru(n.check, M, 4, 0)),
                        c = 0,
                        h = 0,
                        n.mode = 16183;
                    case 16183:
                        for (; h < 16; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        n.head && (n.head.xflags = 255 & c,
                        n.head.os = c >> 8),
                        512 & n.flags && 4 & n.wrap && (M[0] = 255 & c,
                        M[1] = c >>> 8 & 255,
                        n.check = ru(n.check, M, 2, 0)),
                        c = 0,
                        h = 0,
                        n.mode = 16184;
                    case 16184:
                        if (1024 & n.flags) {
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.length = c,
                            n.head && (n.head.extra_len = c),
                            512 & n.flags && 4 & n.wrap && (M[0] = 255 & c,
                            M[1] = c >>> 8 & 255,
                            n.check = ru(n.check, M, 2, 0)),
                            c = 0,
                            h = 0
                        } else
                            n.head && (n.head.extra = null);
                        n.mode = 16185;
                    case 16185:
                        if (1024 & n.flags && (p = n.length,
                        p > o && (p = o),
                        p && (n.head && (b = n.head.extra_len - n.length,
                        n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)),
                        n.head.extra.set(i.subarray(a, a + p), b)),
                        512 & n.flags && 4 & n.wrap && (n.check = ru(n.check, i, p, a)),
                        o -= p,
                        a += p,
                        n.length -= p),
                        n.length))
                            break e;
                        n.length = 0,
                        n.mode = 16186;
                    case 16186:
                        if (2048 & n.flags) {
                            if (0 === o)
                                break e;
                            p = 0;
                            do {
                                b = i[a + p++],
                                n.head && b && n.length < 65536 && (n.head.name += String.fromCharCode(b))
                            } while (b && p < o);
                            if (512 & n.flags && 4 & n.wrap && (n.check = ru(n.check, i, p, a)),
                            o -= p,
                            a += p,
                            b)
                                break e
                        } else
                            n.head && (n.head.name = null);
                        n.length = 0,
                        n.mode = 16187;
                    case 16187:
                        if (4096 & n.flags) {
                            if (0 === o)
                                break e;
                            p = 0;
                            do {
                                b = i[a + p++],
                                n.head && b && n.length < 65536 && (n.head.comment += String.fromCharCode(b))
                            } while (b && p < o);
                            if (512 & n.flags && 4 & n.wrap && (n.check = ru(n.check, i, p, a)),
                            o -= p,
                            a += p,
                            b)
                                break e
                        } else
                            n.head && (n.head.comment = null);
                        n.mode = 16188;
                    case 16188:
                        if (512 & n.flags) {
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (4 & n.wrap && c !== (65535 & n.check)) {
                                e.msg = "header crc mismatch",
                                n.mode = tf;
                                break
                            }
                            c = 0,
                            h = 0
                        }
                        n.head && (n.head.hcrc = n.flags >> 9 & 1,
                        n.head.done = !0),
                        e.adler = n.check = 0,
                        n.mode = Zp;
                        break;
                    case 16189:
                        for (; h < 32; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        e.adler = n.check = nf(c),
                        c = 0,
                        h = 0,
                        n.mode = Yp;
                    case Yp:
                        if (0 === n.havedict)
                            return e.next_out = s,
                            e.avail_out = l,
                            e.next_in = a,
                            e.avail_in = o,
                            n.hold = c,
                            n.bits = h,
                            Wp;
                        e.adler = n.check = 1,
                        n.mode = Zp;
                    case Zp:
                        if (t === Bp || t === Op)
                            break e;
                    case Kp:
                        if (n.last) {
                            c >>>= 7 & h,
                            h -= 7 & h,
                            n.mode = ef;
                            break
                        }
                        for (; h < 3; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        switch (n.last = 1 & c,
                        c >>>= 1,
                        h -= 1,
                        3 & c) {
                        case 0:
                            n.mode = 16193;
                            break;
                        case 1:
                            if (pf(n),
                            n.mode = Qp,
                            t === Op) {
                                c >>>= 2,
                                h -= 2;
                                break e
                            }
                            break;
                        case 2:
                            n.mode = 16196;
                            break;
                        case 3:
                            e.msg = "invalid block type",
                            n.mode = tf
                        }
                        c >>>= 2,
                        h -= 2;
                        break;
                    case 16193:
                        for (c >>>= 7 & h,
                        h -= 7 & h; h < 32; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if ((65535 & c) != (c >>> 16 ^ 65535)) {
                            e.msg = "invalid stored block lengths",
                            n.mode = tf;
                            break
                        }
                        if (n.length = 65535 & c,
                        c = 0,
                        h = 0,
                        n.mode = Jp,
                        t === Op)
                            break e;
                    case Jp:
                        n.mode = 16195;
                    case 16195:
                        if (p = n.length,
                        p) {
                            if (p > o && (p = o),
                            p > l && (p = l),
                            0 === p)
                                break e;
                            r.set(i.subarray(a, a + p), s),
                            o -= p,
                            a += p,
                            l -= p,
                            s += p,
                            n.length -= p;
                            break
                        }
                        n.mode = Zp;
                        break;
                    case 16196:
                        for (; h < 14; ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (n.nlen = 257 + (31 & c),
                        c >>>= 5,
                        h -= 5,
                        n.ndist = 1 + (31 & c),
                        c >>>= 5,
                        h -= 5,
                        n.ncode = 4 + (15 & c),
                        c >>>= 4,
                        h -= 4,
                        n.nlen > 286 || n.ndist > 30) {
                            e.msg = "too many length or distance symbols",
                            n.mode = tf;
                            break
                        }
                        n.have = 0,
                        n.mode = 16197;
                    case 16197:
                        for (; n.have < n.ncode; ) {
                            for (; h < 3; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.lens[C[n.have++]] = 7 & c,
                            c >>>= 3,
                            h -= 3
                        }
                        for (; n.have < 19; )
                            n.lens[C[n.have++]] = 0;
                        if (n.lencode = n.lendyn,
                        n.lenbits = 7,
                        T = {
                            bits: n.lenbits
                        },
                        E = Up(0, n.lens, 0, 19, n.lencode, 0, n.work, T),
                        n.lenbits = T.bits,
                        E) {
                            e.msg = "invalid code lengths set",
                            n.mode = tf;
                            break
                        }
                        n.have = 0,
                        n.mode = 16198;
                    case 16198:
                        for (; n.have < n.nlen + n.ndist; ) {
                            for (; S = n.lencode[c & (1 << n.lenbits) - 1],
                            g = S >>> 24,
                            v = S >>> 16 & 255,
                            w = 65535 & S,
                            !(g <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (w < 16)
                                c >>>= g,
                                h -= g,
                                n.lens[n.have++] = w;
                            else {
                                if (16 === w) {
                                    for (k = g + 2; h < k; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                        c += i[a++] << h,
                                        h += 8
                                    }
                                    if (c >>>= g,
                                    h -= g,
                                    0 === n.have) {
                                        e.msg = "invalid bit length repeat",
                                        n.mode = tf;
                                        break
                                    }
                                    b = n.lens[n.have - 1],
                                    p = 3 + (3 & c),
                                    c >>>= 2,
                                    h -= 2
                                } else if (17 === w) {
                                    for (k = g + 3; h < k; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                        c += i[a++] << h,
                                        h += 8
                                    }
                                    c >>>= g,
                                    h -= g,
                                    b = 0,
                                    p = 3 + (7 & c),
                                    c >>>= 3,
                                    h -= 3
                                } else {
                                    for (k = g + 7; h < k; ) {
                                        if (0 === o)
                                            break e;
                                        o--,
                                        c += i[a++] << h,
                                        h += 8
                                    }
                                    c >>>= g,
                                    h -= g,
                                    b = 0,
                                    p = 11 + (127 & c),
                                    c >>>= 7,
                                    h -= 7
                                }
                                if (n.have + p > n.nlen + n.ndist) {
                                    e.msg = "invalid bit length repeat",
                                    n.mode = tf;
                                    break
                                }
                                for (; p--; )
                                    n.lens[n.have++] = b
                            }
                        }
                        if (n.mode === tf)
                            break;
                        if (0 === n.lens[256]) {
                            e.msg = "invalid code -- missing end-of-block",
                            n.mode = tf;
                            break
                        }
                        if (n.lenbits = 9,
                        T = {
                            bits: n.lenbits
                        },
                        E = Up(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, T),
                        n.lenbits = T.bits,
                        E) {
                            e.msg = "invalid literal/lengths set",
                            n.mode = tf;
                            break
                        }
                        if (n.distbits = 6,
                        n.distcode = n.distdyn,
                        T = {
                            bits: n.distbits
                        },
                        E = Up(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, T),
                        n.distbits = T.bits,
                        E) {
                            e.msg = "invalid distances set",
                            n.mode = tf;
                            break
                        }
                        if (n.mode = Qp,
                        t === Op)
                            break e;
                    case Qp:
                        n.mode = $p;
                    case $p:
                        if (o >= 6 && l >= 258) {
                            e.next_out = s,
                            e.avail_out = l,
                            e.next_in = a,
                            e.avail_in = o,
                            n.hold = c,
                            n.bits = h,
                            Ap(e, u),
                            s = e.next_out,
                            r = e.output,
                            l = e.avail_out,
                            a = e.next_in,
                            i = e.input,
                            o = e.avail_in,
                            c = n.hold,
                            h = n.bits,
                            n.mode === Zp && (n.back = -1);
                            break
                        }
                        for (n.back = 0; S = n.lencode[c & (1 << n.lenbits) - 1],
                        g = S >>> 24,
                        v = S >>> 16 & 255,
                        w = 65535 & S,
                        !(g <= h); ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (v && 0 == (240 & v)) {
                            for (y = g,
                            _ = v,
                            x = w; S = n.lencode[x + ((c & (1 << y + _) - 1) >> y)],
                            g = S >>> 24,
                            v = S >>> 16 & 255,
                            w = 65535 & S,
                            !(y + g <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            c >>>= y,
                            h -= y,
                            n.back += y
                        }
                        if (c >>>= g,
                        h -= g,
                        n.back += g,
                        n.length = w,
                        0 === v) {
                            n.mode = 16205;
                            break
                        }
                        if (32 & v) {
                            n.back = -1,
                            n.mode = Zp;
                            break
                        }
                        if (64 & v) {
                            e.msg = "invalid literal/length code",
                            n.mode = tf;
                            break
                        }
                        n.extra = 15 & v,
                        n.mode = 16201;
                    case 16201:
                        if (n.extra) {
                            for (k = n.extra; h < k; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.length += c & (1 << n.extra) - 1,
                            c >>>= n.extra,
                            h -= n.extra,
                            n.back += n.extra
                        }
                        n.was = n.length,
                        n.mode = 16202;
                    case 16202:
                        for (; S = n.distcode[c & (1 << n.distbits) - 1],
                        g = S >>> 24,
                        v = S >>> 16 & 255,
                        w = 65535 & S,
                        !(g <= h); ) {
                            if (0 === o)
                                break e;
                            o--,
                            c += i[a++] << h,
                            h += 8
                        }
                        if (0 == (240 & v)) {
                            for (y = g,
                            _ = v,
                            x = w; S = n.distcode[x + ((c & (1 << y + _) - 1) >> y)],
                            g = S >>> 24,
                            v = S >>> 16 & 255,
                            w = 65535 & S,
                            !(y + g <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            c >>>= y,
                            h -= y,
                            n.back += y
                        }
                        if (c >>>= g,
                        h -= g,
                        n.back += g,
                        64 & v) {
                            e.msg = "invalid distance code",
                            n.mode = tf;
                            break
                        }
                        n.offset = w,
                        n.extra = 15 & v,
                        n.mode = 16203;
                    case 16203:
                        if (n.extra) {
                            for (k = n.extra; h < k; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.offset += c & (1 << n.extra) - 1,
                            c >>>= n.extra,
                            h -= n.extra,
                            n.back += n.extra
                        }
                        if (n.offset > n.dmax) {
                            e.msg = "invalid distance too far back",
                            n.mode = tf;
                            break
                        }
                        n.mode = 16204;
                    case 16204:
                        if (0 === l)
                            break e;
                        if (p = u - l,
                        n.offset > p) {
                            if (p = n.offset - p,
                            p > n.whave && n.sane) {
                                e.msg = "invalid distance too far back",
                                n.mode = tf;
                                break
                            }
                            p > n.wnext ? (p -= n.wnext,
                            f = n.wsize - p) : f = n.wnext - p,
                            p > n.length && (p = n.length),
                            m = n.window
                        } else
                            m = r,
                            f = s - n.offset,
                            p = n.length;
                        p > l && (p = l),
                        l -= p,
                        n.length -= p;
                        do {
                            r[s++] = m[f++]
                        } while (--p);
                        0 === n.length && (n.mode = $p);
                        break;
                    case 16205:
                        if (0 === l)
                            break e;
                        r[s++] = n.length,
                        l--,
                        n.mode = $p;
                        break;
                    case ef:
                        if (n.wrap) {
                            for (; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c |= i[a++] << h,
                                h += 8
                            }
                            if (u -= l,
                            e.total_out += u,
                            n.total += u,
                            4 & n.wrap && u && (e.adler = n.check = n.flags ? ru(n.check, r, u, s - u) : nu(n.check, r, u, s - u)),
                            u = l,
                            4 & n.wrap && (n.flags ? c : nf(c)) !== n.check) {
                                e.msg = "incorrect data check",
                                n.mode = tf;
                                break
                            }
                            c = 0,
                            h = 0
                        }
                        n.mode = 16207;
                    case 16207:
                        if (n.wrap && n.flags) {
                            for (; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (4 & n.wrap && c !== (4294967295 & n.total)) {
                                e.msg = "incorrect length check",
                                n.mode = tf;
                                break
                            }
                            c = 0,
                            h = 0
                        }
                        n.mode = 16208;
                    case 16208:
                        E = Fp;
                        break e;
                    case tf:
                        E = Vp;
                        break e;
                    case 16210:
                        return Gp;
                    default:
                        return Hp
                    }
                return e.next_out = s,
                e.avail_out = l,
                e.next_in = a,
                e.avail_in = o,
                n.hold = c,
                n.bits = h,
                (n.wsize || u !== e.avail_out && n.mode < tf && (n.mode < ef || t !== Dp)) && ff(e, e.output, e.next_out, u - e.avail_out),
                d -= e.avail_in,
                u -= e.avail_out,
                e.total_in += d,
                e.total_out += u,
                n.total += u,
                4 & n.wrap && u && (e.adler = n.check = n.flags ? ru(n.check, r, u, e.next_out - u) : nu(n.check, r, u, e.next_out - u)),
                e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === Zp ? 128 : 0) + (n.mode === Qp || n.mode === Jp ? 256 : 0),
                (0 === d && 0 === u || t === Dp) && E === zp && (E = jp),
                E
            }
            ,
            inflateEnd: e=>{
                if (af(e))
                    return Hp;
                let t = e.state;
                return t.window && (t.window = null),
                e.state = null,
                zp
            }
            ,
            inflateGetHeader: (e,t)=>{
                if (af(e))
                    return Hp;
                const n = e.state;
                return 0 == (2 & n.wrap) ? Hp : (n.head = t,
                t.done = !1,
                zp)
            }
            ,
            inflateSetDictionary: (e,t)=>{
                const n = t.length;
                let i, r, a;
                return af(e) ? Hp : (i = e.state,
                0 !== i.wrap && i.mode !== Yp ? Hp : i.mode === Yp && (r = 1,
                r = nu(r, t, n, 0),
                r !== i.check) ? Vp : (a = ff(e, t, n, n),
                a ? (i.mode = 16210,
                Gp) : (i.havedict = 1,
                zp)))
            }
            ,
            inflateInfo: "pako inflate (from Nodeca project)"
        };
        var gf = function() {
            this.text = 0,
            this.time = 0,
            this.xflags = 0,
            this.os = 0,
            this.extra = null,
            this.extra_len = 0,
            this.name = "",
            this.comment = "",
            this.hcrc = 0,
            this.done = !1
        };
        const vf = Object.prototype.toString
          , {Z_NO_FLUSH: wf, Z_FINISH: yf, Z_OK: _f, Z_STREAM_END: xf, Z_NEED_DICT: bf, Z_STREAM_ERROR: Ef, Z_DATA_ERROR: Sf, Z_MEM_ERROR: Mf} = su;
        function Tf(e) {
            this.options = ap({
                chunkSize: 65536,
                windowBits: 15,
                to: ""
            }, e || {});
            const t = this.options;
            t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits,
            0 === t.windowBits && (t.windowBits = -15)),
            !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32),
            t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15),
            this.err = 0,
            this.msg = "",
            this.ended = !1,
            this.chunks = [],
            this.strm = new up,
            this.strm.avail_out = 0;
            let n = mf.inflateInit2(this.strm, t.windowBits);
            if (n !== _f)
                throw new Error(au[n]);
            if (this.header = new gf,
            mf.inflateGetHeader(this.strm, this.header),
            t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = cp(t.dictionary) : "[object ArrayBuffer]" === vf.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)),
            t.raw && (n = mf.inflateSetDictionary(this.strm, t.dictionary),
            n !== _f)))
                throw new Error(au[n])
        }
        function kf(e, t) {
            const n = new Tf(t);
            if (n.push(e),
            n.err)
                throw n.msg || au[n.err];
            return n.result
        }
        Tf.prototype.push = function(e, t) {
            const n = this.strm
              , i = this.options.chunkSize
              , r = this.options.dictionary;
            let a, s, o;
            if (this.ended)
                return !1;
            for (s = t === ~~t ? t : !0 === t ? yf : wf,
            "[object ArrayBuffer]" === vf.call(e) ? n.input = new Uint8Array(e) : n.input = e,
            n.next_in = 0,
            n.avail_in = n.input.length; ; ) {
                for (0 === n.avail_out && (n.output = new Uint8Array(i),
                n.next_out = 0,
                n.avail_out = i),
                a = mf.inflate(n, s),
                a === bf && r && (a = mf.inflateSetDictionary(n, r),
                a === _f ? a = mf.inflate(n, s) : a === Sf && (a = bf)); n.avail_in > 0 && a === xf && n.state.wrap > 0 && 0 !== e[n.next_in]; )
                    mf.inflateReset(n),
                    a = mf.inflate(n, s);
                switch (a) {
                case Ef:
                case Sf:
                case bf:
                case Mf:
                    return this.onEnd(a),
                    this.ended = !0,
                    !1
                }
                if (o = n.avail_out,
                n.next_out && (0 === n.avail_out || a === xf))
                    if ("string" === this.options.to) {
                        let e = dp(n.output, n.next_out)
                          , t = n.next_out - e
                          , r = hp(n.output, e);
                        n.next_out = t,
                        n.avail_out = i - t,
                        t && n.output.set(n.output.subarray(e, e + t), 0),
                        this.onData(r)
                    } else
                        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
                if (a !== _f || 0 !== o) {
                    if (a === xf)
                        return a = mf.inflateEnd(this.strm),
                        this.onEnd(a),
                        this.ended = !0,
                        !0;
                    if (0 === n.avail_in)
                        break
                }
            }
            return !0
        }
        ,
        Tf.prototype.onData = function(e) {
            this.chunks.push(e)
        }
        ,
        Tf.prototype.onEnd = function(e) {
            e === _f && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = sp(this.chunks)),
            this.chunks = [],
            this.err = e,
            this.msg = this.strm.msg
        }
        ;
        var Cf = function(e, t) {
            return (t = t || {}).raw = !0,
            kf(e, t)
        }
          , Af = {
            Inflate: Tf,
            inflate: kf,
            inflateRaw: Cf,
            ungzip: kf,
            constants: su
        };
        const {Deflate: Pf, deflate: Rf, deflateRaw: Lf, gzip: If} = kp
          , {Inflate: Nf, inflate: Uf, inflateRaw: Df, ungzip: Bf} = Af;
        var Of = {
            Deflate: Pf,
            deflate: Rf,
            deflateRaw: Lf,
            gzip: If,
            Inflate: Nf,
            inflate: Uf,
            inflateRaw: Df,
            ungzip: Bf,
            constants: su
        };
        function zf(e) {
            let t;
            e = (e = e.replace(/-/g, "+")).replace(/_/g, "/");
            try {
                t = atob(e)
            } catch (e) {
                return null
            }
            const n = new Uint8Array(t.length);
            for (let e = 0; e < t.length; ++e) {
                const i = t.charCodeAt(e);
                if (i > 255)
                    return null;
                n[e] = i
            }
            return n
        }
        var Ff, Wf = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Hf = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Vf {
            constructor(e) {
                Ff.set(this, []),
                null != e && Wf(this, Ff, e, "f")
            }
            recordFrame(e, t) {
                if (Hf(this, Ff, "f").length > 0) {
                    const e = Hf(this, Ff, "f")[Hf(this, Ff, "f").length - 1];
                    if (e.controls.up == t.up && e.controls.right == t.right && e.controls.down == t.down && e.controls.left == t.left)
                        return
                }
                Hf(this, Ff, "f").push({
                    frame: e,
                    controls: t
                })
            }
            getFrame(e) {
                for (let t = 0; t < Hf(this, Ff, "f").length; ++t) {
                    const n = Hf(this, Ff, "f")[t];
                    if (n.frame == e)
                        return [n.controls.up, n.controls.right, n.controls.down, n.controls.left];
                    if (n.frame > e && t > 0) {
                        const e = Hf(this, Ff, "f")[t - 1];
                        return [e.controls.up, e.controls.right, e.controls.down, e.controls.left]
                    }
                }
                if (Hf(this, Ff, "f").length > 0) {
                    const e = Hf(this, Ff, "f")[Hf(this, Ff, "f").length - 1];
                    return [e.controls.up, e.controls.right, e.controls.down, e.controls.left]
                }
                return [!1, !1, !1, !1]
            }
            getRecording() {
                return Hf(this, Ff, "f")
            }
            serialize() {
                const e = new Uint8Array(Math.ceil(3.5 * Hf(this, Ff, "f").length));
                for (let t = 0; t < Hf(this, Ff, "f").length; ++t) {
                    const n = Hf(this, Ff, "f")[t];
                    e[3 * t] = 255 & n.frame,
                    e[3 * t + 1] = n.frame >>> 8 & 255,
                    e[3 * t + 2] = n.frame >>> 16 & 255
                }
                for (let t = 0; t < Hf(this, Ff, "f").length; t += 2) {
                    const n = Hf(this, Ff, "f")[t];
                    let i = 0;
                    if (i |= n.controls.up ? 1 : 0,
                    i |= (n.controls.right ? 1 : 0) << 1,
                    i |= (n.controls.down ? 1 : 0) << 2,
                    i |= (n.controls.left ? 1 : 0) << 3,
                    t + 1 < Hf(this, Ff, "f").length) {
                        const e = Hf(this, Ff, "f")[t + 1];
                        i |= (e.controls.up ? 1 : 0) << 4,
                        i |= (e.controls.right ? 1 : 0) << 5,
                        i |= (e.controls.down ? 1 : 0) << 6,
                        i |= (e.controls.left ? 1 : 0) << 7
                    }
                    e[3 * Hf(this, Ff, "f").length + Math.floor(t / 2)] = i
                }
                const t = new Of.Deflate({
                    level: 9
                });
                return t.push(new Uint8Array(e), !0),
                function(e) {
                    let t = "";
                    e.forEach((e=>{
                        t += String.fromCharCode(e)
                    }
                    ));
                    let n = btoa(t);
                    return n = n.replace(/\+/g, "-"),
                    n = n.replace(/\//g, "_"),
                    n = n.replace(/=/g, ""),
                    n
                }(t.result)
            }
            static deserialize(e) {
                const t = zf(e);
                if (null == t)
                    return null;
                const n = new Of.Inflate;
                if (n.push(t, !0),
                n.err)
                    return null;
                const i = n.result
                  , r = []
                  , a = Math.round(i.length / 3.5);
                for (let e = 0; e < a; ++e) {
                    const t = i[3 * e + 0] | i[3 * e + 1] << 8 | i[3 * e + 2] << 16;
                    let n;
                    const s = i[3 * a + Math.floor(e / 2)];
                    n = e % 2 == 0 ? {
                        up: 1 == (1 & s),
                        right: 1 == (s >>> 1 & 1),
                        down: 1 == (s >>> 2 & 1),
                        left: 1 == (s >>> 3 & 1)
                    } : {
                        up: 1 == (s >>> 4 & 1),
                        right: 1 == (s >>> 5 & 1),
                        down: 1 == (s >>> 6 & 1),
                        left: 1 == (s >>> 7 & 1)
                    },
                    r.push({
                        frame: t,
                        controls: n
                    })
                }
                return new Vf(r)
            }
        }
        Ff = new WeakMap;
        const Gf = Vf;
        var jf, Xf, qf, Yf, Zf, Kf, Jf, Qf, $f, em, tm, nm, im, rm, am, sm, om, lm, cm, hm, dm, um, pm, fm, mm, gm, vm, wm, ym, _m, xm, bm, Em, Sm, Mm, Tm, km, Cm, Am, Pm, Rm, Lm, Im, Nm, Um, Dm, Bm, Om, zm, Fm, Wm, Hm, Vm, Gm, jm, Xm, qm, Ym = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Zm = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Km {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                if (jf.add(this),
                qf.set(this, void 0),
                Yf.set(this, null),
                Zf.set(this, 1),
                Kf.set(this, null),
                Jf.set(this, 0),
                Qf.set(this, []),
                $f.set(this, null),
                em.set(this, null),
                tm.set(this, null),
                nm.set(this, []),
                im.set(this, void 0),
                rm.set(this, void 0),
                am.set(this, void 0),
                sm.set(this, void 0),
                om.set(this, !1),
                lm.set(this, void 0),
                cm.set(this, void 0),
                hm.set(this, void 0),
                dm.set(this, void 0),
                um.set(this, []),
                pm.set(this, [0, 0, 0, 0]),
                fm.set(this, [0, 0, 0, 0]),
                mm.set(this, void 0),
                gm.set(this, null),
                vm.set(this, null),
                wm.set(this, null),
                ym.set(this, []),
                _m.set(this, null),
                xm.set(this, void 0),
                bm.set(this, void 0),
                Em.set(this, void 0),
                Sm.set(this, void 0),
                Mm.set(this, void 0),
                Tm.set(this, void 0),
                km.set(this, void 0),
                Cm.set(this, []),
                Am.set(this, null),
                Pm.set(this, [.075, .075, .075, .075]),
                Rm.set(this, void 0),
                Lm.set(this, null),
                Ym(this, qf, s, "f"),
                Ym(this, mm, a, "f"),
                Ym(this, Mm, o, "f"),
                Ym(this, Tm, l, "f"),
                Ym(this, km, c, "f"),
                Ym(this, sm, e, "f"),
                Ym(this, im, r, "f"),
                (null == c ? void 0 : c.getSettingBoolean(uc.ParticlesEnabled)) ? Ym(this, Rm, new Jh(a), "f") : Ym(this, Rm, null, "f"),
                null != Zm(this, Mm, "f") && null != Zm(this, Tm, "f") && Ym(this, Cm, [new ud(Zm(this, mm, "f"),Zm(this, Mm, "f"),Zm(this, Tm, "f")), new ud(Zm(this, mm, "f"),Zm(this, Mm, "f"),Zm(this, Tm, "f")), new ud(Zm(this, mm, "f"),Zm(this, Mm, "f"),Zm(this, Tm, "f")), new ud(Zm(this, mm, "f"),Zm(this, Mm, "f"),Zm(this, Tm, "f"))], "f"),
                Ym(this, rm, new Fh, "f"),
                Zm(this, rm, "f").reset(t.position, t.quaternion),
                a.scene.add(Zm(this, rm, "f").camera),
                Ym(this, am, new Ah, "f"),
                Zm(this, am, "f").reset(t.position, t.quaternion),
                a.scene.add(Zm(this, am, "f").camera),
                null == Xf.models)
                    throw "Car model isn't loaded yet";
                if (null != Zm(this, sm, "f") && null != Zm(this, Mm, "f") && null != Zm(this, Tm, "f"))
                    Ym(this, lm, Zm(this, sm, "f").createCar(t, Zm(this, Mm, "f").getMountainVertices(), Zm(this, Mm, "f").getMountainOffset(), Zm(this, Tm, "f").getTrackData(), n, (e=>this.setCarState(e))), "f");
                else {
                    const e = .11898833513259888
                      , n = [new ht(.627909,.27 - e,1.3478).applyQuaternion(t.quaternion).add(t.position), new ht(-.627909,.27 - e,1.3478).applyQuaternion(t.quaternion).add(t.position), new ht(.720832,.27 - e,-1.52686).applyQuaternion(t.quaternion).add(t.position), new ht(-.720832,.27 - e,-1.52686).applyQuaternion(t.quaternion).add(t.position)]
                      , i = [(new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(t.quaternion), (new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(t.quaternion), (new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(t.quaternion), (new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(t.quaternion)];
                    Ym(this, lm, {
                        id: 0,
                        frames: 0,
                        totalFrames: 0,
                        speedKmh: 0,
                        hasStarted: !1,
                        hasFinished: !1,
                        nextCheckpointIndex: 0,
                        position: {
                            x: t.position.x,
                            y: t.position.y,
                            z: t.position.z
                        },
                        quaternion: {
                            x: t.quaternion.x,
                            y: t.quaternion.y,
                            z: t.quaternion.z,
                            w: t.quaternion.w
                        },
                        collisionImpulses: [],
                        wheelInContact: [!1, !1, !1, !1],
                        wheelSuspensionLength: [e, e, e, e],
                        wheelSuspensionVelocity: [0, 0, 0, 0],
                        wheelRotation: [0, 0, 0, 0],
                        wheelDeltaRotation: [0, 0, 0, 0],
                        wheelSkidInfo: [0, 0, 0, 0],
                        wheelPosition: n,
                        wheelQuaternion: i,
                        brakeLightEnabled: !1,
                        controls: {
                            up: !1,
                            right: !1,
                            down: !1,
                            left: !1
                        }
                    }, "f")
                }
                if (Ym(this, cm, i, "f"),
                null == n)
                    Ym(this, hm, null != Zm(this, cm, "f"), "f"),
                    Ym(this, dm, new Gf, "f");
                else {
                    if (null != Zm(this, cm, "f"))
                        throw "Can't control car when recording is set";
                    Ym(this, hm, !1, "f"),
                    Ym(this, dm, n, "f")
                }
                Ym(this, gm, new ls, "f"),
                Zm(this, gm, "f").add(Xf.models.chassis.clone()),
                Zm(this, gm, "f").add(Xf.models.suspension.clone()),
                Zm(this, gm, "f").add(Xf.models.wheelFL.clone()),
                Zm(this, gm, "f").add(Xf.models.wheelFR.clone()),
                Zm(this, gm, "f").add(Xf.models.wheelBL.clone()),
                Zm(this, gm, "f").add(Xf.models.wheelBR.clone()),
                Zm(this, gm, "f").children.forEach((e=>{
                    const t = e;
                    Array.isArray(t.material) ? t.material = t.material.map((e=>e.clone())) : t.material = t.material.clone(),
                    t.castShadow = !0,
                    t.receiveShadow = !0,
                    t.frustumCulled = !1
                }
                )),
                Zm(this, mm, "f").scene.add(Zm(this, gm, "f")),
                Ym(this, vm, Zm(this, gm, "f").getObjectByName("Body"), "f"),
                Ym(this, wm, Zm(this, gm, "f").getObjectByName("Suspension"), "f");
                {
                    const e = document.createElement("canvas");
                    e.width = 2048,
                    e.height = 2048;
                    const t = e.getContext("2d");
                    if (null == t)
                        throw "Failed to get context for car texture";
                    const n = new it(e);
                    let i;
                    n.flipY = !1,
                    n.anisotropy = Zm(this, mm, "f").getMaxAnisotropy(),
                    n.needsUpdate = !0,
                    Ym(this, xm, t, "f"),
                    Ym(this, bm, n, "f"),
                    Ym(this, Sm, Rh.random(), "f"),
                    Zm(this, jf, "m", Nm).call(this),
                    Ym(this, Em, {
                        value: new ht(0,0,0)
                    }, "f"),
                    i = Array.isArray(Zm(this, vm, "f").material) ? Zm(this, vm, "f").material : [Zm(this, vm, "f").material];
                    for (let e = 0; e < i.length; ++e) {
                        const t = i[e];
                        "Main" == t.name ? t.onBeforeCompile = e=>{
                            e.fragmentShader = "uniform sampler2D carColorPattern;\nuniform vec3 carColorSecondary;\n" + e.fragmentShader,
                            e.fragmentShader = e.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );", "float colorSource = texture(carColorPattern, vUv).a;\nvec4 diffuseColor = vec4( carColorSecondary * colorSource + diffuse * (1.0 - colorSource), opacity );"),
                            e.uniforms.carColorPattern = {
                                value: n
                            },
                            e.uniforms.carColorSecondary = Zm(this, Em, "f"),
                            null == e.defines && (e.defines = {}),
                            e.defines.USE_UV = !0
                        }
                        : "Metal" == t.name ? t.needsUpdate = !0 : "BrakeLight" == t.name && Ym(this, _m, t, "f")
                    }
                }
                Zm(this, wm, "f").geometry.morphAttributes.position = [];
                const h = Zm(this, wm, "f")
                  , d = Xf.models.suspensionFL
                  , u = Xf.models.suspensionFR
                  , p = Xf.models.suspensionBL
                  , f = Xf.models.suspensionBR;
                Zm(this, gm, "f").children.forEach((e=>{
                    if (e != Zm(this, vm, "f") && e != Zm(this, wm, "f")) {
                        const t = e;
                        if (!(d.geometry.attributes.position instanceof Dn && u.geometry.attributes.position instanceof Dn && p.geometry.attributes.position instanceof Dn && f.geometry.attributes.position instanceof Dn))
                            throw "Vertices must use BufferAttribute";
                        const n = d.geometry.attributes.position.array
                          , i = u.geometry.attributes.position.array
                          , r = p.geometry.attributes.position.array
                          , a = f.geometry.attributes.position.array
                          , s = h.geometry.morphAttributes.position;
                        if ("WheelFL" == t.name)
                            s.push(new Dn(n,3));
                        else if ("WheelFR" == t.name)
                            s.push(new Dn(i,3));
                        else if ("WheelBL" == t.name)
                            s.push(new Dn(r,3));
                        else {
                            if ("WheelBR" != t.name)
                                throw "Unidentified wheel";
                            s.push(new Dn(a,3))
                        }
                        Zm(this, ym, "f").push(t)
                    }
                }
                )),
                Zm(this, wm, "f").updateMorphTargets(),
                null != Zm(this, cm, "f") && Zm(this, cm, "f").addChangeCallback(Ym(this, Lm, (e=>{
                    var t;
                    null === (t = Zm(this, sm, "f")) || void 0 === t || t.controlCar(Zm(this, lm, "f").id, e.up, e.right, e.down, e.left)
                }
                ), "f"))
            }
            dispose() {
                var e, t, n;
                Zm(this, jf, "m", Im).call(this),
                Zm(this, mm, "f").scene.remove(Zm(this, rm, "f").camera),
                Zm(this, mm, "f").scene.remove(Zm(this, am, "f").camera),
                null === (e = Zm(this, Rm, "f")) || void 0 === e || e.dispose(),
                Zm(this, Cm, "f").forEach((e=>{
                    e.dispose()
                }
                )),
                Zm(this, Cm, "f").length = 0,
                null != Zm(this, gm, "f") && (Zm(this, gm, "f").children.forEach((e=>{
                    const t = e;
                    Array.isArray(t.material) ? t.material.forEach((e=>e.dispose())) : t.material.dispose(),
                    t.geometry.dispose()
                }
                )),
                Zm(this, mm, "f").scene.remove(Zm(this, gm, "f"))),
                Zm(this, bm, "f").dispose(),
                null === (t = Zm(this, sm, "f")) || void 0 === t || t.deleteCar(Zm(this, lm, "f").id),
                null != Zm(this, Lm, "f") && (null === (n = Zm(this, cm, "f")) || void 0 === n || n.removeChangeCallback(Zm(this, Lm, "f")))
            }
            addFinishCallback(e) {
                Zm(this, um, "f").push(e)
            }
            getChassisMatrix() {
                return null != Zm(this, vm, "f") ? Zm(this, vm, "f").matrix : null
            }
            getSpeedKmh() {
                return Zm(this, lm, "f").speedKmh
            }
            start() {
                var e;
                null === (e = Zm(this, sm, "f")) || void 0 === e || e.startCar(Zm(this, lm, "f").id, null)
            }
            hasStarted() {
                return Zm(this, lm, "f").hasStarted
            }
            hasFinished() {
                return Zm(this, lm, "f").hasFinished
            }
            getRecording() {
                return Zm(this, dm, "f")
            }
            getTime() {
                return new vd(Zm(this, lm, "f").frames)
            }
            getTotalTime() {
                return new vd(Zm(this, lm, "f").totalFrames)
            }
            getNextCheckpointIndex() {
                return Zm(this, lm, "f").nextCheckpointIndex
            }
            getPosition() {
                return new ht(Zm(this, lm, "f").position.x,Zm(this, lm, "f").position.y,Zm(this, lm, "f").position.z)
            }
            getQuaternion() {
                return new ct(Zm(this, lm, "f").quaternion.x,Zm(this, lm, "f").quaternion.y,Zm(this, lm, "f").quaternion.z,Zm(this, lm, "f").quaternion.w)
            }
            getMatrix4() {
                const e = this.getPosition()
                  , t = this.getQuaternion()
                  , n = (new Ft).makeRotationFromQuaternion(t);
                return n.setPosition(e),
                n
            }
            get isPaused() {
                return Zm(this, om, "f")
            }
            set isPaused(e) {
                var t;
                Zm(this, om, "f") != e && (null === (t = Zm(this, sm, "f")) || void 0 === t || t.pauseCar(Zm(this, lm, "f").id, e),
                Ym(this, om, e, "f"))
            }
            getControls() {
                return null != Zm(this, cm, "f") ? Zm(this, cm, "f").getControls() : Zm(this, lm, "f").controls
            }
            getColors() {
                return Zm(this, Sm, "f")
            }
            setColors(e) {
                if (Zm(this, Em, "f").value = (new ht).setFromColor(e.secondary),
                null != Zm(this, vm, "f") && Array.isArray(Zm(this, vm, "f").material))
                    for (let t = 0; t < Zm(this, vm, "f").material.length; ++t) {
                        const n = Zm(this, vm, "f").material[t];
                        "Main" == n.name ? n.color.set(e.primary) : "Metal" == n.name && n.color.set(e.frame)
                    }
                if (null != Zm(this, wm, "f") && !Array.isArray(Zm(this, wm, "f").material)) {
                    const t = Zm(this, wm, "f").material;
                    "Metal" == t.name && t.color.set(e.frame)
                }
                for (let t = 0; t < Zm(this, ym, "f").length; ++t) {
                    const n = Zm(this, ym, "f")[t];
                    if (Array.isArray(n.material))
                        for (let t = 0; t < n.material.length; ++t) {
                            const i = n.material[t];
                            "Metal" == i.name ? i.color.set(e.frame) : "Rim" == i.name && i.color.set(e.rims)
                        }
                }
                Ym(this, Sm, e, "f")
            }
            setOpacity(e) {
                var t;
                null === (t = Zm(this, gm, "f")) || void 0 === t || t.children.forEach((t=>{
                    const n = t;
                    let i;
                    i = Array.isArray(n.material) ? n.material : [n.material],
                    i.forEach((t=>{
                        t.opacity = e;
                        const n = e < 1;
                        t.needsUpdate = n != t.transparent,
                        t.transparent = n
                    }
                    ))
                }
                ))
            }
            setCarState(e) {
                var t;
                const n = Zm(this, lm, "f");
                Ym(this, lm, e, "f");
                const i = Zm(this, lm, "f").frames != n.frames && Zm(this, lm, "f").frames != n.frames + 1;
                Zm(this, lm, "f").nextCheckpointIndex > n.nextCheckpointIndex && Zm(this, im, "f") && Zm(this, jf, "m", Dm).call(this),
                Zm(this, lm, "f").hasFinished && !n.hasFinished && (Zm(this, im, "f") && Zm(this, jf, "m", Bm).call(this),
                Zm(this, um, "f").forEach((e=>e(this))));
                const r = .001;
                i && (null === (t = Zm(this, Rm, "f")) || void 0 === t || t.clear(),
                Zm(this, Cm, "f").forEach((e=>{
                    e.clear()
                }
                ))),
                this.getTotalTime().numberOfFrames % 10 == 0 && Zm(this, jf, "m", Om).call(this, .01),
                Zm(this, lm, "f").hasFinished || (i && (Zm(this, rm, "f").reset(this.getPosition(), this.getQuaternion()),
                Zm(this, am, "f").reset(this.getPosition(), this.getQuaternion())),
                Zm(this, rm, "f").update(this.getPosition(), this.getQuaternion(), this.getSpeedKmh()),
                Zm(this, am, "f").update(this.getPosition(), this.getQuaternion(), this.getSpeedKmh())),
                Zm(this, jf, "m", Wm).call(this, r),
                Zm(this, jf, "m", Vm).call(this, r),
                Zm(this, hm, "f") && Zm(this, lm, "f").hasStarted && !Zm(this, lm, "f").hasFinished && Zm(this, dm, "f").recordFrame(n.frames, Zm(this, lm, "f").controls)
            }
            update(e) {
                var t, n, i;
                if (null != Zm(this, vm, "f") && null != Zm(this, wm, "f")) {
                    Zm(this, jf, "m", zm).call(this),
                    null === (t = Zm(this, Rm, "f")) || void 0 === t || t.update(e);
                    const r = this.getMatrix4()
                      , a = this.getQuaternion();
                    Zm(this, vm, "f").matrixAutoUpdate = !1,
                    Zm(this, vm, "f").matrix.copy(r),
                    Zm(this, vm, "f").matrix.multiply((new Ft).makeTranslation(0, Xf.massOffset, 0)),
                    Zm(this, wm, "f").matrixAutoUpdate = !1,
                    Zm(this, wm, "f").matrix.copy(Zm(this, vm, "f").matrix);
                    const s = 4;
                    for (let t = 0; t < s; t++) {
                        const r = Zm(this, lm, "f").wheelInContact[t]
                          , s = Zm(this, lm, "f").wheelDeltaRotation[t];
                        if (this.hasStarted()) {
                            if (r)
                                Zm(this, pm, "f")[t] = 1e3 * s;
                            else {
                                const {up: i, down: r} = null !== (n = this.getControls()) && void 0 !== n ? n : {
                                    up: !1,
                                    down: !1
                                };
                                (2 == t || 3 == t) && (i ? Zm(this, pm, "f")[t] += 50 * e : r && (Zm(this, pm, "f")[t] -= 25 * e)),
                                Zm(this, pm, "f")[t] *= Math.max(0, 1 - e)
                            }
                            Zm(this, fm, "f")[t] += Zm(this, pm, "f")[t] * e
                        }
                        const o = Zm(this, lm, "f").wheelPosition[t]
                          , l = new ct(Zm(this, lm, "f").wheelQuaternion[t].x,Zm(this, lm, "f").wheelQuaternion[t].y,Zm(this, lm, "f").wheelQuaternion[t].z,Zm(this, lm, "f").wheelQuaternion[t].w)
                          , c = Zm(this, lm, "f").wheelRotation[t];
                        l.multiply((new ct).setFromAxisAngle(new ht(-1,0,0), Zm(this, fm, "f")[t] - c)),
                        Zm(this, ym, "f")[t].position.set(o.x, o.y, o.z),
                        Zm(this, ym, "f")[t].quaternion.set(l.x, l.y, l.z, l.w);
                        const h = Zm(this, lm, "f").wheelSuspensionLength[t]
                          , d = Zm(this, lm, "f").wheelSkidInfo[t];
                        Zm(this, wm, "f").morphTargetInfluences || (Zm(this, wm, "f").morphTargetInfluences = []),
                        Zm(this, wm, "f").morphTargetInfluences[t] = 2 * h + .06,
                        e > 0 && (null === (i = Zm(this, km, "f")) || void 0 === i ? void 0 : i.getSettingBoolean(uc.SkidmarksEnabled)) && t < Zm(this, Cm, "f").length && r && s > .06 && d < .5 && 0 == Zm(this, Pm, "f")[t] && Zm(this, Cm, "f")[t].spawn(o.x, o.y, o.z, a)
                    }
                    Zm(this, jf, "m", Xm).call(this, Zm(this, lm, "f").brakeLightEnabled)
                }
            }
            get cameraOrbit() {
                return Zm(this, rm, "f").camera
            }
            get cameraCockpit() {
                return Zm(this, am, "f").camera
            }
            set audioVolume(e) {
                Ym(this, Zf, e, "f"),
                null != Zm(this, Yf, "f") && Zm(this, Yf, "f").gain.setTargetAtTime(Zm(this, Zf, "f"), 0, .01)
            }
            static initResources(e) {
                e.addResource();
                (new Cc).load("models/car.glb", (t=>{
                    function n(e) {
                        const n = t.scene.getObjectByName(e);
                        if (null == n)
                            throw 'Mesh "' + e + '" does not exist';
                        if (0 == n.children.length) {
                            const e = n;
                            return e.updateMatrixWorld(!0),
                            e.geometry.applyMatrix4(e.matrix.clone()),
                            e.matrix.identity(),
                            e
                        }
                        const i = Mc(n.children.map((e=>e.geometry)), !0);
                        n.updateMatrixWorld(!0),
                        i.applyMatrix4(n.matrix.clone());
                        const r = n.children.map((e=>e.material))
                          , a = new di(i,r);
                        return a.name = e,
                        a
                    }
                    function i(e) {
                        let t;
                        return t = Array.isArray(e.material) ? e.material : [e.material],
                        t.forEach((e=>e.side = 0)),
                        e
                    }
                    Xf.models = {
                        chassis: i(n("Body")),
                        suspension: i(n("Suspension")),
                        suspensionFL: i(n("SuspensionFL")),
                        suspensionFR: i(n("SuspensionFR")),
                        suspensionBL: i(n("SuspensionBL")),
                        suspensionBR: i(n("SuspensionBR")),
                        wheelFL: i(n("WheelFL")),
                        wheelFR: i(n("WheelFR")),
                        wheelBL: i(n("WheelBL")),
                        wheelBR: i(n("WheelBR")),
                        collisionShapeVertices: Zm(Xf, Xf, "m", qm).call(Xf, n("Collision"))
                    },
                    Xf.models.wheelFL.geometry.translate(-.627909, .218824, -1.3478),
                    Xf.models.wheelFR.geometry.translate(.627909, .218824, -1.3478),
                    Xf.models.wheelBL.geometry.translate(-.720832, .218824, 1.52686),
                    Xf.models.wheelBR.geometry.translate(.720832, .218824, 1.52686),
                    Xf.models.wheelFL.geometry.rotateZ(Math.PI),
                    Xf.models.wheelFR.geometry.rotateZ(Math.PI),
                    Xf.models.wheelBL.geometry.rotateZ(Math.PI),
                    Xf.models.wheelBR.geometry.rotateZ(Math.PI),
                    e.loadedResource()
                }
                )),
                e.addResource();
                const t = new Image;
                t.addEventListener("load", (()=>{
                    e.loadedResource()
                }
                )),
                t.src = "images/car_stripe.svg",
                Xf.images = {
                    stripe: t
                }
            }
        }
        Xf = Km,
        qf = new WeakMap,
        Yf = new WeakMap,
        Zf = new WeakMap,
        Kf = new WeakMap,
        Jf = new WeakMap,
        Qf = new WeakMap,
        $f = new WeakMap,
        em = new WeakMap,
        tm = new WeakMap,
        nm = new WeakMap,
        im = new WeakMap,
        rm = new WeakMap,
        am = new WeakMap,
        sm = new WeakMap,
        om = new WeakMap,
        lm = new WeakMap,
        cm = new WeakMap,
        hm = new WeakMap,
        dm = new WeakMap,
        um = new WeakMap,
        pm = new WeakMap,
        fm = new WeakMap,
        mm = new WeakMap,
        gm = new WeakMap,
        vm = new WeakMap,
        wm = new WeakMap,
        ym = new WeakMap,
        _m = new WeakMap,
        xm = new WeakMap,
        bm = new WeakMap,
        Em = new WeakMap,
        Sm = new WeakMap,
        Mm = new WeakMap,
        Tm = new WeakMap,
        km = new WeakMap,
        Cm = new WeakMap,
        Am = new WeakMap,
        Pm = new WeakMap,
        Rm = new WeakMap,
        Lm = new WeakMap,
        jf = new WeakSet,
        Im = function() {
            Zm(this, jf, "m", Um).call(this),
            setTimeout((()=>{
                null != Zm(this, Kf, "f") && (Zm(this, Kf, "f").source.stop(),
                Ym(this, Kf, null, "f")),
                null != Zm(this, $f, "f") && (Zm(this, $f, "f").forEach((({source: e})=>{
                    e.stop()
                }
                )),
                Ym(this, $f, null, "f"))
            }
            ), 200)
        }
        ,
        Nm = function() {
            if (null == Xf.images)
                throw "Car images are not loaded yet";
            Zm(this, xm, "f").clearRect(0, 0, Zm(this, xm, "f").canvas.width, Zm(this, xm, "f").canvas.height),
            Zm(this, xm, "f").drawImage(Xf.images.stripe, 0, 0, Zm(this, xm, "f").canvas.width, Zm(this, xm, "f").canvas.height),
            Zm(this, bm, "f").needsUpdate = !0
        }
        ,
        Um = function() {
            if (null != Zm(this, Kf, "f") && (Zm(this, Kf, "f").source.playbackRate.setTargetAtTime(.7, 0, .15),
            Zm(this, Kf, "f").gain.gain.setTargetAtTime(0, 0, .15)),
            null != Zm(this, $f, "f"))
                for (let e = 0; e < Zm(this, $f, "f").length; ++e) {
                    const t = Zm(this, $f, "f")[e];
                    t.source.playbackRate.setTargetAtTime(.3, 0, .15),
                    t.gain.gain.setTargetAtTime(0, 0, .15)
                }
            null != Zm(this, Am, "f") && (Zm(this, Am, "f").forEach((({source: e})=>{
                e.stop()
            }
            )),
            Ym(this, Am, null, "f"))
        }
        ,
        Dm = function() {
            var e, t;
            const n = null !== (t = null === (e = Zm(this, km, "f")) || void 0 === e ? void 0 : e.getSettingFloat(uc.CheckpointVolume)) && void 0 !== t ? t : 0;
            let i = Math.min(Math.max(Zm(this, Zf, "f") * n, 0), 1);
            if (Number.isNaN(i) && (i = 0),
            i > 0 && null != Zm(this, qf, "f")) {
                const e = Zm(this, qf, "f").getBuffer("checkpoint");
                if (null != e && null != Zm(this, qf, "f").context && null != Zm(this, qf, "f").destinationRaw) {
                    const t = Zm(this, qf, "f").context.createBufferSource();
                    t.buffer = e,
                    t.playbackRate.value = 1.25;
                    const n = Zm(this, qf, "f").context.createGain();
                    n.gain.value = .03 * i,
                    t.connect(n),
                    n.connect(Zm(this, qf, "f").destinationRaw),
                    t.start(0)
                }
            }
        }
        ,
        Bm = function() {
            var e, t;
            const n = null !== (t = null === (e = Zm(this, km, "f")) || void 0 === e ? void 0 : e.getSettingFloat(uc.CheckpointVolume)) && void 0 !== t ? t : 0;
            let i = Math.min(Math.max(Zm(this, Zf, "f") * n, 0), 1);
            if (Number.isNaN(i) && (i = 0),
            i > 0 && null != Zm(this, qf, "f")) {
                const e = Zm(this, qf, "f").getBuffer("finish");
                if (null != e && null != Zm(this, qf, "f").context && null != Zm(this, qf, "f").destinationRaw) {
                    const t = Zm(this, qf, "f").context.createBufferSource();
                    t.buffer = e,
                    t.playbackRate.value = 1.25;
                    const n = Zm(this, qf, "f").context.createGain();
                    n.gain.value = .03,
                    t.connect(n),
                    n.connect(Zm(this, qf, "f").destinationRaw),
                    t.start(0)
                }
            }
        }
        ,
        Om = function(e) {
            var t;
            for (let n = 0; n < 4; n++) {
                const i = Zm(this, lm, "f").wheelPosition[n]
                  , r = Zm(this, lm, "f").wheelInContact[n]
                  , a = Zm(this, lm, "f").wheelDeltaRotation[n]
                  , s = Zm(this, lm, "f").wheelSkidInfo[n];
                r && a > .06 && s < .5 ? (n < Zm(this, Cm, "f").length && (Zm(this, Pm, "f")[n] = Math.max(0, Zm(this, Pm, "f")[n] - e)),
                0 == Zm(this, Pm, "f")[n] && null != Zm(this, Rm, "f") && Zm(this, Rm, "f").spawn(i.x, i.y, i.z)) : (n < Zm(this, Cm, "f").length && (null === (t = Zm(this, km, "f")) || void 0 === t ? void 0 : t.getSettingBoolean(uc.SkidmarksEnabled)) && Zm(this, Cm, "f")[n].break(),
                Zm(this, Pm, "f")[n] = .075)
            }
        }
        ,
        zm = function() {
            if (null != Zm(this, qf, "f") && null != Zm(this, qf, "f").context && null != Zm(this, qf, "f").destinationSfx) {
                null == Zm(this, Yf, "f") && (Ym(this, Yf, Zm(this, qf, "f").context.createGain(), "f"),
                Zm(this, Yf, "f").gain.value = Zm(this, Zf, "f"),
                Zm(this, Yf, "f").connect(Zm(this, qf, "f").destinationSfx)),
                null == Zm(this, tm, "f") && (Ym(this, tm, Zm(this, qf, "f").context.createPanner(), "f"),
                Zm(this, tm, "f").refDistance = 5,
                Zm(this, tm, "f").connect(Zm(this, Yf, "f")));
                const e = this.getPosition();
                Zm(this, tm, "f").positionX.value = e.x,
                Zm(this, tm, "f").positionY.value = e.y,
                Zm(this, tm, "f").positionZ.value = e.z;
                const t = 4;
                if (Zm(this, nm, "f").length < t) {
                    Zm(this, nm, "f").length = 0;
                    for (let e = 0; e < t; ++e) {
                        const e = Zm(this, qf, "f").context.createPanner();
                        e.refDistance = 5,
                        e.connect(Zm(this, Yf, "f")),
                        Zm(this, nm, "f").push(e)
                    }
                }
                for (let e = 0; e < t; ++e) {
                    const t = Zm(this, nm, "f")[e]
                      , n = Zm(this, lm, "f").wheelPosition[e];
                    t.positionX.value = n.x,
                    t.positionY.value = n.y,
                    t.positionZ.value = n.z
                }
                Zm(this, mm, "f").camera != Zm(this, rm, "f").camera && Zm(this, mm, "f").camera != Zm(this, am, "f").camera || Zm(this, qf, "f").refreshListener(Zm(this, mm, "f")),
                Zm(this, jf, "m", Fm).call(this),
                Zm(this, jf, "m", Hm).call(this),
                Zm(this, jf, "m", jm).call(this)
            }
        }
        ,
        Fm = function() {
            var e;
            if (null == Zm(this, Kf, "f") && null != Zm(this, tm, "f") && null != Zm(this, qf, "f")) {
                const e = Zm(this, qf, "f").getBuffer("engine");
                if (null != e && null != Zm(this, qf, "f").context) {
                    const t = Zm(this, qf, "f").context.createBufferSource();
                    t.buffer = e,
                    t.loop = !0,
                    t.playbackRate.value = .7;
                    const n = Zm(this, qf, "f").context.createGain();
                    n.gain.value = 0,
                    t.connect(n),
                    n.connect(Zm(this, tm, "f")),
                    t.start(0, 2 * Math.random()),
                    Ym(this, Kf, {
                        source: t,
                        gain: n
                    }, "f")
                }
            }
            if (null != Zm(this, Kf, "f")) {
                const t = (Zm(this, pm, "f")[0] + Zm(this, pm, "f")[1] + Zm(this, pm, "f")[2] + Zm(this, pm, "f")[3]) / 4
                  , n = .7 + Math.pow(Math.abs(t), 1 / 3) / 3
                  , i = Zm(this, lm, "f").wheelInContact[0] || Zm(this, lm, "f").wheelInContact[1] || Zm(this, lm, "f").wheelInContact[2] || Zm(this, lm, "f").wheelInContact[3]
                  , {up: r, down: a} = null !== (e = this.getControls()) && void 0 !== e ? e : {
                    up: !1,
                    down: !1
                };
                i ? (r || a && t < 0) && this.hasStarted() && !this.hasFinished() ? Ym(this, Jf, n, "f") : Ym(this, Jf, Math.max(.7, n / 2), "f") : (r || a && t < 0) && this.hasStarted() && !this.hasFinished() ? Ym(this, Jf, Math.max(.7, 1.15 * n), "f") : Ym(this, Jf, Math.max(.7, n / 2), "f"),
                Zm(this, Kf, "f").source.playbackRate.setTargetAtTime(Zm(this, Jf, "f"), 0, .05),
                Zm(this, Kf, "f").gain.gain.setTargetAtTime(Math.min(.285, Zm(this, Jf, "f") / 14), 0, .05)
            }
        }
        ,
        Wm = function(e) {
            if (Zm(this, Qf, "f").length < 4) {
                Zm(this, Qf, "f").length = 0;
                for (let e = 0; e < 4; ++e)
                    Zm(this, Qf, "f").push(0)
            }
            for (let t = 0; t < 4 && t < Zm(this, nm, "f").length; t++)
                if (Zm(this, Qf, "f")[t] -= e,
                Zm(this, Qf, "f")[t] <= 0) {
                    const e = Math.abs(Zm(this, lm, "f").wheelSuspensionVelocity[t]);
                    if (e > 4 && null != Zm(this, qf, "f")) {
                        const n = Zm(this, qf, "f").getBuffer("suspension");
                        if (null != n && null != Zm(this, qf, "f").context) {
                            const i = Zm(this, qf, "f").context.createBufferSource();
                            i.buffer = n,
                            i.playbackRate.value = .7 + .1 * Math.random();
                            const r = Zm(this, qf, "f").context.createGain();
                            r.gain.value = Math.min(.285, e / 140),
                            i.connect(r),
                            r.connect(Zm(this, nm, "f")[t]),
                            i.start(Zm(this, qf, "f").context.currentTime + .02 * Math.random()),
                            Zm(this, Qf, "f")[t] = .1
                        }
                    }
                }
        }
        ,
        Hm = function() {
            if (null == Zm(this, $f, "f") && null != Zm(this, qf, "f")) {
                const e = Zm(this, qf, "f").getBuffer("tires");
                if (null != e && null != Zm(this, qf, "f").context) {
                    Ym(this, $f, [], "f");
                    const t = 4;
                    for (let n = 0; n < t; n++) {
                        const i = Zm(this, qf, "f").context.createBufferSource();
                        i.buffer = e,
                        i.loop = !0,
                        i.playbackRate.value = .3;
                        const r = Zm(this, qf, "f").context.createGain();
                        r.gain.value = 0,
                        i.connect(r),
                        r.connect(Zm(this, nm, "f")[n]),
                        i.start(0, n / t * 3.5 + .25 * Math.random()),
                        Zm(this, $f, "f").push({
                            source: i,
                            gain: r
                        })
                    }
                }
            }
            if (null != Zm(this, $f, "f"))
                for (let e = 0; e < Zm(this, $f, "f").length; ++e) {
                    const t = Zm(this, $f, "f")[e];
                    if (Zm(this, lm, "f").wheelInContact[e]) {
                        const e = Math.min(3, Math.abs(this.getSpeedKmh()) / 110);
                        t.gain.gain.setTargetAtTime(e / 10.5, 0, .15)
                    } else
                        t.gain.gain.setTargetAtTime(0, 0, .15);
                    const n = .3 + Math.min(.4, Math.abs(this.getSpeedKmh()) / 800);
                    t.source.playbackRate.setTargetAtTime(n, 0, .15)
                }
        }
        ,
        Vm = function(e) {
            null != Zm(this, em, "f") && (Zm(this, em, "f").timeout -= e,
            Zm(this, em, "f").timeout <= 0 && Ym(this, em, null, "f"));
            Zm(this, lm, "f").collisionImpulses.forEach((e=>{
                Zm(this, jf, "m", Gm).call(this, e)
            }
            ))
        }
        ,
        Gm = function(e) {
            if (e > 25 && null != Zm(this, tm, "f") && null != Zm(this, qf, "f") && (null == Zm(this, em, "f") || Zm(this, em, "f").impulse + 100 < e)) {
                Ym(this, em, {
                    timeout: .2,
                    impulse: e
                }, "f");
                const t = Zm(this, qf, "f").getBuffer("collision");
                if (null != t && null != Zm(this, qf, "f").context) {
                    const n = Zm(this, qf, "f").context.createBufferSource();
                    n.buffer = t,
                    n.playbackRate.value = .5 - .3 * Math.max(0, Math.min(1, e / 1e3)) + .2 * Math.random();
                    const i = Zm(this, qf, "f").context.createGain();
                    i.gain.value = Math.max(.3, Math.min(e / 2e3, 1)) / 3.5,
                    n.connect(i),
                    i.connect(Zm(this, tm, "f")),
                    n.start(0)
                }
            }
        }
        ,
        jm = function() {
            if (null == Zm(this, Am, "f") && null != Zm(this, qf, "f")) {
                const e = Zm(this, qf, "f").getBuffer("skidding");
                if (null != e && null != Zm(this, qf, "f").context) {
                    Ym(this, Am, [], "f");
                    const t = 4;
                    for (let n = 0; n < t; ++n) {
                        const i = Zm(this, qf, "f").context.createBufferSource();
                        i.buffer = e,
                        i.loop = !0,
                        i.playbackRate.value = .5;
                        const r = Zm(this, qf, "f").context.createGain();
                        r.gain.value = 0,
                        i.connect(r),
                        r.connect(Zm(this, nm, "f")[n]),
                        i.start(0, n / t * 3.5 + .25 * Math.random()),
                        Zm(this, Am, "f").push({
                            source: i,
                            gain: r
                        })
                    }
                }
            }
            if (null != Zm(this, Am, "f"))
                for (let e = 0; e < Zm(this, Am, "f").length; ++e) {
                    const t = Zm(this, Am, "f")[e];
                    0 == Zm(this, Pm, "f")[e] ? t.gain.gain.setTargetAtTime(.75 / 3.5, 0, .1) : t.gain.gain.setTargetAtTime(0, 0, .1)
                }
        }
        ,
        Xm = function(e) {
            null != Zm(this, _m, "f") && (e ? Zm(this, _m, "f").emissive.setRGB(1, .4, .3) : Zm(this, _m, "f").emissive.setRGB(0, 0, 0))
        }
        ,
        qm = function(e) {
            const t = e.geometry.toNonIndexed();
            if (!(t.attributes.position instanceof Dn))
                throw "Vertices must use BufferAttribute";
            return Array.from(t.attributes.position.array)
        }
        ,
        Km.massOffset = .6,
        Km.models = null,
        Km.images = null;
        const Jm = Km;
        var Qm = n(27)
          , $m = {};
        $m.styleTagTransform = u(),
        $m.setAttributes = l(),
        $m.insert = s().bind(null, "head"),
        $m.domAPI = r(),
        $m.insertStyleElement = h();
        t()(Qm.Z, $m);
        Qm.Z && Qm.Z.locals && Qm.Z.locals;
        const eg = {
            type: "change"
        }
          , tg = {
            type: "start"
        }
          , ng = {
            type: "end"
        }
          , ig = new zt
          , rg = new Ci
          , ag = Math.cos(70 * Ue.DEG2RAD);
        class sg extends be {
            constructor(e, t) {
                super(),
                this.object = e,
                this.domElement = t,
                this.domElement.style.touchAction = "none",
                this.enabled = !0,
                this.target = new ht,
                this.cursor = new ht,
                this.minDistance = 0,
                this.maxDistance = 1 / 0,
                this.minZoom = 0,
                this.maxZoom = 1 / 0,
                this.minTargetRadius = 0,
                this.maxTargetRadius = 1 / 0,
                this.minPolarAngle = 0,
                this.maxPolarAngle = Math.PI,
                this.minAzimuthAngle = -1 / 0,
                this.maxAzimuthAngle = 1 / 0,
                this.enableDamping = !1,
                this.dampingFactor = .05,
                this.enableZoom = !0,
                this.zoomSpeed = 1,
                this.enableRotate = !0,
                this.rotateSpeed = 1,
                this.enablePan = !0,
                this.panSpeed = 1,
                this.screenSpacePanning = !0,
                this.keyPanSpeed = 7,
                this.zoomToCursor = !1,
                this.autoRotate = !1,
                this.autoRotateSpeed = 2,
                this.keys = {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                },
                this.mouseButtons = {
                    LEFT: g,
                    MIDDLE: v,
                    RIGHT: w
                },
                this.touches = {
                    ONE: y,
                    TWO: x
                },
                this.target0 = this.target.clone(),
                this.position0 = this.object.position.clone(),
                this.zoom0 = this.object.zoom,
                this._domElementKeyEvents = null,
                this.getPolarAngle = function() {
                    return s.phi
                }
                ,
                this.getAzimuthalAngle = function() {
                    return s.theta
                }
                ,
                this.getDistance = function() {
                    return this.object.position.distanceTo(this.target)
                }
                ,
                this.listenToKeyEvents = function(e) {
                    e.addEventListener("keydown", $),
                    this._domElementKeyEvents = e
                }
                ,
                this.stopListenToKeyEvents = function() {
                    this._domElementKeyEvents.removeEventListener("keydown", $),
                    this._domElementKeyEvents = null
                }
                ,
                this.saveState = function() {
                    n.target0.copy(n.target),
                    n.position0.copy(n.object.position),
                    n.zoom0 = n.object.zoom
                }
                ,
                this.reset = function() {
                    n.target.copy(n.target0),
                    n.object.position.copy(n.position0),
                    n.object.zoom = n.zoom0,
                    n.object.updateProjectionMatrix(),
                    n.dispatchEvent(eg),
                    n.update(),
                    r = i.NONE
                }
                ,
                this.update = function() {
                    const t = new ht
                      , h = (new ct).setFromUnitVectors(e.up, new ht(0,1,0))
                      , d = h.clone().invert()
                      , u = new ht
                      , p = new ct
                      , f = new ht
                      , m = 2 * Math.PI;
                    return function(g=null) {
                        const v = n.object.position;
                        t.copy(v).sub(n.target),
                        t.applyQuaternion(h),
                        s.setFromVector3(t),
                        n.autoRotate && r === i.NONE && L(function(e) {
                            return null !== e ? 2 * Math.PI / 60 * n.autoRotateSpeed * e : 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
                        }(g)),
                        n.enableDamping ? (s.theta += o.theta * n.dampingFactor,
                        s.phi += o.phi * n.dampingFactor) : (s.theta += o.theta,
                        s.phi += o.phi);
                        let w = n.minAzimuthAngle
                          , y = n.maxAzimuthAngle;
                        isFinite(w) && isFinite(y) && (w < -Math.PI ? w += m : w > Math.PI && (w -= m),
                        y < -Math.PI ? y += m : y > Math.PI && (y -= m),
                        s.theta = w <= y ? Math.max(w, Math.min(y, s.theta)) : s.theta > (w + y) / 2 ? Math.max(w, s.theta) : Math.min(y, s.theta)),
                        s.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, s.phi)),
                        s.makeSafe(),
                        !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c),
                        n.target.sub(n.cursor),
                        n.target.clampLength(n.minTargetRadius, n.maxTargetRadius),
                        n.target.add(n.cursor),
                        n.zoomToCursor && C || n.object.isOrthographicCamera ? s.radius = F(s.radius) : s.radius = F(s.radius * l),
                        t.setFromSpherical(s),
                        t.applyQuaternion(d),
                        v.copy(n.target).add(t),
                        n.object.lookAt(n.target),
                        !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor,
                        o.phi *= 1 - n.dampingFactor,
                        c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0),
                        c.set(0, 0, 0));
                        let _ = !1;
                        if (n.zoomToCursor && C) {
                            let i = null;
                            if (n.object.isPerspectiveCamera) {
                                const e = t.length();
                                i = F(e * l);
                                const r = e - i;
                                n.object.position.addScaledVector(T, r),
                                n.object.updateMatrixWorld()
                            } else if (n.object.isOrthographicCamera) {
                                const e = new ht(k.x,k.y,0);
                                e.unproject(n.object),
                                n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / l)),
                                n.object.updateProjectionMatrix(),
                                _ = !0;
                                const r = new ht(k.x,k.y,0);
                                r.unproject(n.object),
                                n.object.position.sub(r).add(e),
                                n.object.updateMatrixWorld(),
                                i = t.length()
                            } else
                                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                                n.zoomToCursor = !1;
                            null !== i && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(i).add(n.object.position) : (ig.origin.copy(n.object.position),
                            ig.direction.set(0, 0, -1).transformDirection(n.object.matrix),
                            Math.abs(n.object.up.dot(ig.direction)) < ag ? e.lookAt(n.target) : (rg.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                            ig.intersectPlane(rg, n.target))))
                        } else
                            n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / l)),
                            n.object.updateProjectionMatrix(),
                            _ = !0);
                        return l = 1,
                        C = !1,
                        !!(_ || u.distanceToSquared(n.object.position) > a || 8 * (1 - p.dot(n.object.quaternion)) > a || f.distanceToSquared(n.target) > 0) && (n.dispatchEvent(eg),
                        u.copy(n.object.position),
                        p.copy(n.object.quaternion),
                        f.copy(n.target),
                        !0)
                    }
                }(),
                this.dispose = function() {
                    n.domElement.removeEventListener("contextmenu", ee),
                    n.domElement.removeEventListener("pointerdown", Z),
                    n.domElement.removeEventListener("pointercancel", J),
                    n.domElement.removeEventListener("wheel", Q),
                    n.domElement.removeEventListener("pointermove", K),
                    n.domElement.removeEventListener("pointerup", J),
                    null !== n._domElementKeyEvents && (n._domElementKeyEvents.removeEventListener("keydown", $),
                    n._domElementKeyEvents = null)
                }
                ;
                const n = this
                  , i = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_PAN: 4,
                    TOUCH_DOLLY_PAN: 5,
                    TOUCH_DOLLY_ROTATE: 6
                };
                let r = i.NONE;
                const a = 1e-6
                  , s = new cc
                  , o = new cc;
                let l = 1;
                const c = new ht
                  , h = new De
                  , d = new De
                  , u = new De
                  , p = new De
                  , f = new De
                  , m = new De
                  , E = new De
                  , S = new De
                  , M = new De
                  , T = new ht
                  , k = new De;
                let C = !1;
                const A = []
                  , P = {};
                function R(e) {
                    const t = Math.abs(e) / (100 * (0 | window.devicePixelRatio));
                    return Math.pow(.95, n.zoomSpeed * t)
                }
                function L(e) {
                    o.theta -= e
                }
                function I(e) {
                    o.phi -= e
                }
                const N = function() {
                    const e = new ht;
                    return function(t, n) {
                        e.setFromMatrixColumn(n, 0),
                        e.multiplyScalar(-t),
                        c.add(e)
                    }
                }()
                  , U = function() {
                    const e = new ht;
                    return function(t, i) {
                        !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0),
                        e.crossVectors(n.object.up, e)),
                        e.multiplyScalar(t),
                        c.add(e)
                    }
                }()
                  , D = function() {
                    const e = new ht;
                    return function(t, i) {
                        const r = n.domElement;
                        if (n.object.isPerspectiveCamera) {
                            const a = n.object.position;
                            e.copy(a).sub(n.target);
                            let s = e.length();
                            s *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                            N(2 * t * s / r.clientHeight, n.object.matrix),
                            U(2 * i * s / r.clientHeight, n.object.matrix)
                        } else
                            n.object.isOrthographicCamera ? (N(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix),
                            U(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                            n.enablePan = !1)
                    }
                }();
                function B(e) {
                    n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? l /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    n.enableZoom = !1)
                }
                function O(e) {
                    n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? l *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    n.enableZoom = !1)
                }
                function z(e, t) {
                    if (!n.zoomToCursor)
                        return;
                    C = !0;
                    const i = n.domElement.getBoundingClientRect()
                      , r = e - i.left
                      , a = t - i.top
                      , s = i.width
                      , o = i.height;
                    k.x = r / s * 2 - 1,
                    k.y = -a / o * 2 + 1,
                    T.set(k.x, k.y, 1).unproject(n.object).sub(n.object.position).normalize()
                }
                function F(e) {
                    return Math.max(n.minDistance, Math.min(n.maxDistance, e))
                }
                function W(e) {
                    h.set(e.clientX, e.clientY)
                }
                function H(e) {
                    p.set(e.clientX, e.clientY)
                }
                function V(e) {
                    if (1 === A.length)
                        h.set(e.pageX, e.pageY);
                    else {
                        const t = ne(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        h.set(n, i)
                    }
                }
                function G(e) {
                    if (1 === A.length)
                        p.set(e.pageX, e.pageY);
                    else {
                        const t = ne(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        p.set(n, i)
                    }
                }
                function j(e) {
                    const t = ne(e)
                      , n = e.pageX - t.x
                      , i = e.pageY - t.y
                      , r = Math.sqrt(n * n + i * i);
                    E.set(0, r)
                }
                function X(e) {
                    if (1 == A.length)
                        d.set(e.pageX, e.pageY);
                    else {
                        const t = ne(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        d.set(n, i)
                    }
                    u.subVectors(d, h).multiplyScalar(n.rotateSpeed);
                    const t = n.domElement;
                    L(2 * Math.PI * u.x / t.clientHeight),
                    I(2 * Math.PI * u.y / t.clientHeight),
                    h.copy(d)
                }
                function q(e) {
                    if (1 === A.length)
                        f.set(e.pageX, e.pageY);
                    else {
                        const t = ne(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        f.set(n, i)
                    }
                    m.subVectors(f, p).multiplyScalar(n.panSpeed),
                    D(m.x, m.y),
                    p.copy(f)
                }
                function Y(e) {
                    const t = ne(e)
                      , i = e.pageX - t.x
                      , r = e.pageY - t.y
                      , a = Math.sqrt(i * i + r * r);
                    S.set(0, a),
                    M.set(0, Math.pow(S.y / E.y, n.zoomSpeed)),
                    B(M.y),
                    E.copy(S);
                    z(.5 * (e.pageX + t.x), .5 * (e.pageY + t.y))
                }
                function Z(e) {
                    !1 !== n.enabled && (0 === A.length && (n.domElement.setPointerCapture(e.pointerId),
                    n.domElement.addEventListener("pointermove", K),
                    n.domElement.addEventListener("pointerup", J)),
                    function(e) {
                        A.push(e.pointerId)
                    }(e),
                    "touch" === e.pointerType ? function(e) {
                        switch (te(e),
                        A.length) {
                        case 1:
                            switch (n.touches.ONE) {
                            case y:
                                if (!1 === n.enableRotate)
                                    return;
                                V(e),
                                r = i.TOUCH_ROTATE;
                                break;
                            case _:
                                if (!1 === n.enablePan)
                                    return;
                                G(e),
                                r = i.TOUCH_PAN;
                                break;
                            default:
                                r = i.NONE
                            }
                            break;
                        case 2:
                            switch (n.touches.TWO) {
                            case x:
                                if (!1 === n.enableZoom && !1 === n.enablePan)
                                    return;
                                !function(e) {
                                    n.enableZoom && j(e),
                                    n.enablePan && G(e)
                                }(e),
                                r = i.TOUCH_DOLLY_PAN;
                                break;
                            case b:
                                if (!1 === n.enableZoom && !1 === n.enableRotate)
                                    return;
                                !function(e) {
                                    n.enableZoom && j(e),
                                    n.enableRotate && V(e)
                                }(e),
                                r = i.TOUCH_DOLLY_ROTATE;
                                break;
                            default:
                                r = i.NONE
                            }
                            break;
                        default:
                            r = i.NONE
                        }
                        r !== i.NONE && n.dispatchEvent(tg)
                    }(e) : function(e) {
                        let t;
                        switch (e.button) {
                        case 0:
                            t = n.mouseButtons.LEFT;
                            break;
                        case 1:
                            t = n.mouseButtons.MIDDLE;
                            break;
                        case 2:
                            t = n.mouseButtons.RIGHT;
                            break;
                        default:
                            t = -1
                        }
                        switch (t) {
                        case v:
                            if (!1 === n.enableZoom)
                                return;
                            !function(e) {
                                z(e.clientX, e.clientX),
                                E.set(e.clientX, e.clientY)
                            }(e),
                            r = i.DOLLY;
                            break;
                        case g:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === n.enablePan)
                                    return;
                                H(e),
                                r = i.PAN
                            } else {
                                if (!1 === n.enableRotate)
                                    return;
                                W(e),
                                r = i.ROTATE
                            }
                            break;
                        case w:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === n.enableRotate)
                                    return;
                                W(e),
                                r = i.ROTATE
                            } else {
                                if (!1 === n.enablePan)
                                    return;
                                H(e),
                                r = i.PAN
                            }
                            break;
                        default:
                            r = i.NONE
                        }
                        r !== i.NONE && n.dispatchEvent(tg)
                    }(e))
                }
                function K(e) {
                    !1 !== n.enabled && ("touch" === e.pointerType ? function(e) {
                        switch (te(e),
                        r) {
                        case i.TOUCH_ROTATE:
                            if (!1 === n.enableRotate)
                                return;
                            X(e),
                            n.update();
                            break;
                        case i.TOUCH_PAN:
                            if (!1 === n.enablePan)
                                return;
                            q(e),
                            n.update();
                            break;
                        case i.TOUCH_DOLLY_PAN:
                            if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                            !function(e) {
                                n.enableZoom && Y(e),
                                n.enablePan && q(e)
                            }(e),
                            n.update();
                            break;
                        case i.TOUCH_DOLLY_ROTATE:
                            if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                            !function(e) {
                                n.enableZoom && Y(e),
                                n.enableRotate && X(e)
                            }(e),
                            n.update();
                            break;
                        default:
                            r = i.NONE
                        }
                    }(e) : function(e) {
                        switch (r) {
                        case i.ROTATE:
                            if (!1 === n.enableRotate)
                                return;
                            !function(e) {
                                d.set(e.clientX, e.clientY),
                                u.subVectors(d, h).multiplyScalar(n.rotateSpeed);
                                const t = n.domElement;
                                L(2 * Math.PI * u.x / t.clientHeight),
                                I(2 * Math.PI * u.y / t.clientHeight),
                                h.copy(d),
                                n.update()
                            }(e);
                            break;
                        case i.DOLLY:
                            if (!1 === n.enableZoom)
                                return;
                            !function(e) {
                                S.set(e.clientX, e.clientY),
                                M.subVectors(S, E),
                                M.y > 0 ? B(R(M.y)) : M.y < 0 && O(R(M.y)),
                                E.copy(S),
                                n.update()
                            }(e);
                            break;
                        case i.PAN:
                            if (!1 === n.enablePan)
                                return;
                            !function(e) {
                                f.set(e.clientX, e.clientY),
                                m.subVectors(f, p).multiplyScalar(n.panSpeed),
                                D(m.x, m.y),
                                p.copy(f),
                                n.update()
                            }(e)
                        }
                    }(e))
                }
                function J(e) {
                    !function(e) {
                        delete P[e.pointerId];
                        for (let t = 0; t < A.length; t++)
                            if (A[t] == e.pointerId)
                                return void A.splice(t, 1)
                    }(e),
                    0 === A.length && (n.domElement.releasePointerCapture(e.pointerId),
                    n.domElement.removeEventListener("pointermove", K),
                    n.domElement.removeEventListener("pointerup", J)),
                    n.dispatchEvent(ng),
                    r = i.NONE
                }
                function Q(e) {
                    !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (e.preventDefault(),
                    n.dispatchEvent(tg),
                    function(e) {
                        z(e.clientX, e.clientY),
                        e.deltaY < 0 ? O(R(e.deltaY)) : e.deltaY > 0 && B(R(e.deltaY)),
                        n.update()
                    }(e),
                    n.dispatchEvent(ng))
                }
                function $(e) {
                    !1 !== n.enabled && !1 !== n.enablePan && function(e) {
                        let t = !1;
                        switch (e.code) {
                        case n.keys.UP:
                            e.ctrlKey || e.metaKey || e.shiftKey ? I(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(0, n.keyPanSpeed),
                            t = !0;
                            break;
                        case n.keys.BOTTOM:
                            e.ctrlKey || e.metaKey || e.shiftKey ? I(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(0, -n.keyPanSpeed),
                            t = !0;
                            break;
                        case n.keys.LEFT:
                            e.ctrlKey || e.metaKey || e.shiftKey ? L(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(n.keyPanSpeed, 0),
                            t = !0;
                            break;
                        case n.keys.RIGHT:
                            e.ctrlKey || e.metaKey || e.shiftKey ? L(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : D(-n.keyPanSpeed, 0),
                            t = !0
                        }
                        t && (e.preventDefault(),
                        n.update())
                    }(e)
                }
                function ee(e) {
                    !1 !== n.enabled && e.preventDefault()
                }
                function te(e) {
                    let t = P[e.pointerId];
                    void 0 === t && (t = new De,
                    P[e.pointerId] = t),
                    t.set(e.pageX, e.pageY)
                }
                function ne(e) {
                    const t = e.pointerId === A[0] ? A[1] : A[0];
                    return P[t]
                }
                n.domElement.addEventListener("contextmenu", ee),
                n.domElement.addEventListener("pointerdown", Z),
                n.domElement.addEventListener("pointercancel", J),
                n.domElement.addEventListener("wheel", Q, {
                    passive: !1
                }),
                this.update()
            }
        }
        var og = n(416)
          , lg = {};
        lg.styleTagTransform = u(),
        lg.setAttributes = l(),
        lg.insert = s().bind(null, "head"),
        lg.domAPI = r(),
        lg.insertStyleElement = h();
        t()(og.Z, lg);
        og.Z && og.Z.locals && og.Z.locals;
        var cg, hg, dg, ug, pg, fg, mg, gg, vg, wg, yg, _g, xg, bg, Eg, Sg, Mg, Tg, kg, Cg = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Ag = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        hg = new WeakMap,
        dg = new WeakMap,
        ug = new WeakMap,
        pg = new WeakMap,
        fg = new WeakMap,
        mg = new WeakMap,
        gg = new WeakMap,
        vg = new WeakMap,
        wg = new WeakMap,
        yg = new WeakMap,
        _g = new WeakMap,
        xg = new WeakMap,
        bg = new WeakMap,
        Eg = new WeakMap,
        Sg = new WeakMap,
        Mg = new WeakMap,
        cg = new WeakSet,
        Tg = function() {
            Ag(this, vg, "f").style.left = "calc(" + 100 * Ag(this, xg, "f") / 360 + "% - 1px)",
            Ag(this, pg, "f").style.backgroundImage = "linear-gradient(transparent, #000), linear-gradient(to right, transparent, hsla(" + Ag(this, xg, "f") + ", 100%, 50%, 1))"
        }
        ,
        kg = function() {
            Ag(this, fg, "f").style.left = "calc(" + Ag(this, _g, "f") + "% - 6px)",
            Ag(this, fg, "f").style.top = "calc(" + (100 - Ag(this, yg, "f")) + "% - 6px)"
        }
        ;
        const Pg = class {
            constructor(e, t) {
                cg.add(this),
                hg.set(this, void 0),
                dg.set(this, void 0),
                ug.set(this, void 0),
                pg.set(this, void 0),
                fg.set(this, void 0),
                mg.set(this, !1),
                gg.set(this, void 0),
                vg.set(this, void 0),
                wg.set(this, !1),
                yg.set(this, 0),
                _g.set(this, 0),
                xg.set(this, 0),
                bg.set(this, void 0),
                Eg.set(this, void 0),
                Sg.set(this, void 0),
                Mg.set(this, void 0),
                Cg(this, hg, e, "f"),
                Cg(this, dg, t, "f"),
                Cg(this, ug, document.createElement("div"), "f"),
                Ag(this, ug, "f").className = "color-picker",
                Cg(this, pg, document.createElement("div"), "f"),
                Ag(this, pg, "f").className = "value-saturation-picker",
                Ag(this, ug, "f").appendChild(Ag(this, pg, "f")),
                Cg(this, fg, document.createElement("div"), "f"),
                Ag(this, fg, "f").className = "marker",
                Ag(this, pg, "f").appendChild(Ag(this, fg, "f")),
                Cg(this, gg, document.createElement("div"), "f"),
                Ag(this, gg, "f").className = "hue-picker",
                Ag(this, ug, "f").appendChild(Ag(this, gg, "f")),
                Cg(this, vg, document.createElement("div"), "f"),
                Ag(this, vg, "f").className = "marker",
                Ag(this, gg, "f").appendChild(Ag(this, vg, "f")),
                Ag(this, hg, "f").appendChild(Ag(this, ug, "f"));
                Cg(this, bg, (e=>{
                    let n = null;
                    if (e instanceof MouseEvent ? Ag(this, mg, "f") && (n = e) : e instanceof TouchEvent && e.targetTouches.length > 0 && (n = e.targetTouches[e.targetTouches.length - 1]),
                    null != n) {
                        const e = Ag(this, pg, "f").getBoundingClientRect()
                          , i = Math.max(0, Math.min(1, (n.clientX - e.left) / e.width))
                          , r = Math.max(0, Math.min(1, (n.clientY - e.top) / e.height));
                        Cg(this, _g, 100 * i, "f"),
                        Cg(this, yg, 100 * (1 - r), "f"),
                        Ag(this, cg, "m", kg).call(this),
                        t(this.color)
                    }
                }
                ), "f"),
                Cg(this, Eg, (e=>{
                    0 == e.button && Cg(this, mg, !1, "f")
                }
                ), "f"),
                Ag(this, pg, "f").addEventListener("mousedown", (e=>{
                    0 == e.button && Cg(this, mg, !0, "f"),
                    Ag(this, bg, "f").call(this, e)
                }
                )),
                window.addEventListener("mouseup", Ag(this, Eg, "f")),
                window.addEventListener("mousemove", Ag(this, bg, "f")),
                Ag(this, pg, "f").addEventListener("touchstart", Ag(this, bg, "f")),
                Ag(this, pg, "f").addEventListener("touchmove", Ag(this, bg, "f")),
                Cg(this, Sg, (e=>{
                    let n = null;
                    if (e instanceof MouseEvent ? Ag(this, wg, "f") && (n = e) : e instanceof TouchEvent && e.targetTouches.length > 0 && (n = e.targetTouches[e.targetTouches.length - 1]),
                    null != n) {
                        const e = Ag(this, gg, "f").getBoundingClientRect()
                          , i = Math.max(0, Math.min(1, (n.clientX - e.left) / e.width));
                        Cg(this, xg, 360 * i, "f"),
                        Ag(this, cg, "m", Tg).call(this),
                        t(this.color)
                    }
                }
                ), "f"),
                Cg(this, Mg, (e=>{
                    0 == e.button && Cg(this, wg, !1, "f")
                }
                ), "f"),
                Ag(this, gg, "f").addEventListener("mousedown", (e=>{
                    0 == e.button && Cg(this, wg, !0, "f"),
                    Ag(this, Sg, "f").call(this, e)
                }
                )),
                window.addEventListener("mouseup", Ag(this, Mg, "f")),
                window.addEventListener("mousemove", Ag(this, Sg, "f")),
                Ag(this, gg, "f").addEventListener("touchstart", Ag(this, Sg, "f")),
                Ag(this, gg, "f").addEventListener("touchmove", Ag(this, Sg, "f")),
                Ag(this, cg, "m", Tg).call(this),
                Ag(this, cg, "m", kg).call(this)
            }
            dispose() {
                window.removeEventListener("mouseup", Ag(this, Eg, "f")),
                window.removeEventListener("mousemove", Ag(this, bg, "f")),
                window.removeEventListener("mouseup", Ag(this, Mg, "f")),
                window.removeEventListener("mousemove", Ag(this, Sg, "f"))
            }
            get color() {
                const e = Ag(this, _g, "f") / 100
                  , t = Ag(this, yg, "f") / 100
                  , n = t - t * e / 2
                  , i = Math.min(n, 1 - n)
                  , r = 0 != i ? (t - n) / i : 0;
                return new An("hsl(" + Ag(this, xg, "f") + "," + 100 * r + "%," + 100 * n + "%)")
            }
            set color(e) {
                const {h: t, s: n, l: i} = e.getHSL({
                    h: 0,
                    s: 0,
                    l: 0
                }, le)
                  , r = i + n * Math.min(i, 1 - i)
                  , a = 0 == r ? 0 : 2 * (1 - i / r);
                Cg(this, xg, 360 * t, "f"),
                Cg(this, _g, 100 * a, "f"),
                Cg(this, yg, 100 * r, "f"),
                Ag(this, cg, "m", Tg).call(this),
                Ag(this, cg, "m", kg).call(this),
                Ag(this, dg, "f").call(this, this.color)
            }
        }
        ;
        var Rg, Lg, Ig, Ng, Ug, Dg, Bg, Og, zg, Fg, Wg, Hg, Vg, Gg, jg, Xg, qg, Yg = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Zg = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Lg = new WeakMap,
        Ig = new WeakMap,
        Ng = new WeakMap,
        Ug = new WeakMap,
        Dg = new WeakMap,
        Bg = new WeakMap,
        Og = new WeakMap,
        zg = new WeakMap,
        Fg = new WeakMap,
        Wg = new WeakMap,
        Hg = new WeakMap,
        Vg = new WeakMap,
        Rg = new WeakSet,
        Gg = function(e) {
            const t = document.createElement("div");
            t.className = "color",
            Zg(this, Wg, "f").appendChild(t);
            const n = document.createElement("h2");
            n.textContent = e,
            t.appendChild(n);
            const i = document.createElement("input");
            i.type = "text",
            i.addEventListener("input", (()=>{
                r.color = new An(i.value),
                Zg(this, Lg, "f").setColors(Zg(this, Rg, "m", Xg).call(this)),
                Yg(this, Vg, !0, "f")
            }
            )),
            i.addEventListener("blur", (()=>{
                i.value = "#" + r.color.getHexString()
            }
            )),
            t.appendChild(i);
            const r = new Pg(t,(e=>{
                document.activeElement != i && (i.value = "#" + e.getHexString()),
                Zg(this, Lg, "f").setColors(Zg(this, Rg, "m", Xg).call(this)),
                Yg(this, Vg, !0, "f")
            }
            ));
            i.value = "#" + r.color.getHexString(),
            Zg(this, Hg, "f").push(r)
        }
        ,
        jg = function() {
            const e = Rh.random();
            Zg(this, Hg, "f")[0].color = e.primary.clone(),
            Zg(this, Hg, "f")[1].color = e.secondary.clone(),
            Zg(this, Hg, "f")[2].color = e.frame.clone(),
            Zg(this, Hg, "f")[3].color = e.rims.clone()
        }
        ,
        Xg = function() {
            return new Rh(Zg(this, Hg, "f")[0].color.clone(),Zg(this, Hg, "f")[1].color.clone(),Zg(this, Hg, "f")[2].color.clone(),Zg(this, Hg, "f")[3].color.clone())
        }
        ,
        qg = function(e) {
            Zg(this, Hg, "f")[0].color = e.primary.clone(),
            Zg(this, Hg, "f")[1].color = e.secondary.clone(),
            Zg(this, Hg, "f")[2].color = e.frame.clone(),
            Zg(this, Hg, "f")[3].color = e.rims.clone()
        }
        ;
        const Kg = class {
            constructor(e, t, n, i, r, a, s) {
                Rg.add(this),
                Lg.set(this, void 0),
                Ig.set(this, void 0),
                Ng.set(this, void 0),
                Ug.set(this, void 0),
                Dg.set(this, void 0),
                Bg.set(this, void 0),
                Og.set(this, void 0),
                zg.set(this, void 0),
                Fg.set(this, void 0),
                Wg.set(this, void 0),
                Hg.set(this, []),
                Vg.set(this, !1),
                Yg(this, Lg, e, "f"),
                Yg(this, Ig, n, "f"),
                Yg(this, Ng, r, "f"),
                Yg(this, Ug, a, "f"),
                Yg(this, Og, new _i(70,1,.1,1e4), "f"),
                Zg(this, Og, "f").position.set(4, 3, 4),
                n.scene.add(Zg(this, Og, "f")),
                Yg(this, zg, new sg(Zg(this, Og, "f"),n.canvas), "f"),
                Zg(this, zg, "f").target.set(0, .7, 1.2),
                Zg(this, zg, "f").update(),
                Zg(this, zg, "f").mouseButtons = {
                    LEFT: g,
                    MIDDLE: g,
                    RIGHT: g
                },
                Zg(this, zg, "f").enablePan = !1,
                Zg(this, zg, "f").minDistance = 2.5,
                Zg(this, zg, "f").maxDistance = 5.8,
                Zg(this, zg, "f").maxPolarAngle = Math.PI / 2 + .06,
                Yg(this, Dg, document.getElementById("ui"), "f"),
                Yg(this, Fg, document.createElement("div"), "f"),
                Zg(this, Fg, "f").className = "customization";
                const o = document.createElement("div");
                o.className = "top",
                Zg(this, Fg, "f").appendChild(o);
                const l = document.createElement("button");
                l.className = "button",
                l.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                l.append(document.createTextNode(t.get("Exit"))),
                l.addEventListener("click", (()=>{
                    i.playUIClick(),
                    s()
                }
                )),
                o.appendChild(l),
                window.addEventListener("keydown", Yg(this, Bg, (e=>{
                    "Escape" == e.code && (s(),
                    e.preventDefault())
                }
                ), "f"));
                const c = document.createElement("button");
                c.className = "button",
                c.innerHTML = '<img class="button-icon" src="images/random.svg"> ',
                c.append(document.createTextNode(t.get("Random"))),
                c.addEventListener("click", (()=>{
                    i.playUIClick(),
                    Zg(this, Rg, "m", jg).call(this)
                }
                )),
                o.appendChild(c),
                Yg(this, Wg, document.createElement("div"), "f"),
                Zg(this, Wg, "f").className = "colors",
                Zg(this, Fg, "f").appendChild(Zg(this, Wg, "f")),
                Zg(this, Rg, "m", Gg).call(this, t.get("Primary")),
                Zg(this, Rg, "m", Gg).call(this, t.get("Secondary")),
                Zg(this, Rg, "m", Gg).call(this, t.get("Frame")),
                Zg(this, Rg, "m", Gg).call(this, t.get("Rims")),
                Zg(this, Dg, "f").appendChild(Zg(this, Fg, "f"));
                const h = Zg(this, Ug, "f").getCarColors();
                Zg(this, Rg, "m", qg).call(this, h),
                Zg(this, Lg, "f").setColors(h),
                Yg(this, Vg, !1, "f")
            }
            save() {
                if (Zg(this, Vg, "f")) {
                    const e = Zg(this, Rg, "m", Xg).call(this);
                    Zg(this, Ug, "f").setCarColors(e),
                    Zg(this, Ng, "f").submitUserProfile(Zg(this, Ug, "f").getToken(), Zg(this, Ug, "f").getNickname(), e),
                    Yg(this, Vg, !1, "f")
                }
            }
            dispose() {
                Zg(this, Hg, "f").forEach((e=>{
                    e.dispose()
                }
                )),
                Zg(this, Ig, "f").scene.remove(Zg(this, Og, "f")),
                window.removeEventListener("keydown", Zg(this, Bg, "f")),
                Zg(this, Dg, "f").removeChild(Zg(this, Fg, "f")),
                Zg(this, zg, "f").dispose()
            }
            get camera() {
                return Zg(this, Og, "f")
            }
        }
        ;
        var Jg;
        !function(e) {
            e[e.Straight = 0] = "Straight",
            e[e.TurnSharp = 1] = "TurnSharp",
            e[e.SlopeUp = 2] = "SlopeUp",
            e[e.SlopeDown = 3] = "SlopeDown",
            e[e.Slope = 4] = "Slope",
            e[e.Start = 5] = "Start",
            e[e.Finish = 6] = "Finish",
            e[e.ToWideMiddle = 7] = "ToWideMiddle",
            e[e.ToWideLeft = 8] = "ToWideLeft",
            e[e.ToWideRight = 9] = "ToWideRight",
            e[e.StraightWide = 10] = "StraightWide",
            e[e.InnerCornerWide = 11] = "InnerCornerWide",
            e[e.OuterCornerWide = 12] = "OuterCornerWide",
            e[e.SlopeUpLeftWide = 13] = "SlopeUpLeftWide",
            e[e.SlopeUpRightWide = 14] = "SlopeUpRightWide",
            e[e.SlopeDownLeftWide = 15] = "SlopeDownLeftWide",
            e[e.SlopeDownRightWide = 16] = "SlopeDownRightWide",
            e[e.SlopeLeftWide = 17] = "SlopeLeftWide",
            e[e.SlopeRightWide = 18] = "SlopeRightWide",
            e[e.PillarTop = 19] = "PillarTop",
            e[e.PillarMiddle = 20] = "PillarMiddle",
            e[e.PillarBottom = 21] = "PillarBottom",
            e[e.PillarShort = 22] = "PillarShort",
            e[e.PlanePillarBottom = 23] = "PlanePillarBottom",
            e[e.PlanePillarShort = 24] = "PlanePillarShort",
            e[e.Plane = 25] = "Plane",
            e[e.PlaneWall = 26] = "PlaneWall",
            e[e.PlaneWallCorner = 27] = "PlaneWallCorner",
            e[e.PlaneWallInnerCorner = 28] = "PlaneWallInnerCorner",
            e[e.Block = 29] = "Block",
            e[e.WallTrackTop = 30] = "WallTrackTop",
            e[e.WallTrackMiddle = 31] = "WallTrackMiddle",
            e[e.WallTrackBottom = 32] = "WallTrackBottom",
            e[e.PlaneSlopeUp = 33] = "PlaneSlopeUp",
            e[e.PlaneSlopeDown = 34] = "PlaneSlopeDown",
            e[e.PlaneSlope = 35] = "PlaneSlope",
            e[e.TurnShort = 36] = "TurnShort",
            e[e.TurnLong = 37] = "TurnLong",
            e[e.SlopeUpLong = 38] = "SlopeUpLong",
            e[e.SlopeDownLong = 39] = "SlopeDownLong",
            e[e.SlopePillar = 40] = "SlopePillar",
            e[e.TurnSLeft = 41] = "TurnSLeft",
            e[e.TurnSRight = 42] = "TurnSRight",
            e[e.IntersectionT = 43] = "IntersectionT",
            e[e.IntersectionCross = 44] = "IntersectionCross",
            e[e.PillarBranch1 = 45] = "PillarBranch1",
            e[e.PillarBranch2 = 46] = "PillarBranch2",
            e[e.PillarBranch3 = 47] = "PillarBranch3",
            e[e.PillarBranch4 = 48] = "PillarBranch4",
            e[e.WallTrackBottomCorner = 49] = "WallTrackBottomCorner",
            e[e.WallTrackMiddleCorner = 50] = "WallTrackMiddleCorner",
            e[e.WallTrackTopCorner = 51] = "WallTrackTopCorner",
            e[e.Checkpoint = 52] = "Checkpoint",
            e[e.HalfBlock = 53] = "HalfBlock",
            e[e.QuarterBlock = 54] = "QuarterBlock",
            e[e.HalfPlane = 55] = "HalfPlane",
            e[e.QuarterPlane = 56] = "QuarterPlane",
            e[e.PlaneBridge = 57] = "PlaneBridge",
            e[e.SignArrowLeft = 58] = "SignArrowLeft",
            e[e.SignArrowRight = 59] = "SignArrowRight",
            e[e.SignArrowUp = 61] = "SignArrowUp",
            e[e.SignArrowDown = 62] = "SignArrowDown",
            e[e.SignWarning = 63] = "SignWarning",
            e[e.SignWrongWay = 64] = "SignWrongWay",
            e[e.CheckpointWide = 65] = "CheckpointWide",
            e[e.WallTrackCeiling = 66] = "WallTrackCeiling",
            e[e.WallTrackFloor = 67] = "WallTrackFloor",
            e[e.BlockSlopedDown = 68] = "BlockSlopedDown",
            e[e.BlockSlopedDownInnerCorner = 69] = "BlockSlopedDownInnerCorner",
            e[e.BlockSlopedDownOuterCorner = 70] = "BlockSlopedDownOuterCorner",
            e[e.BlockSlopedUp = 71] = "BlockSlopedUp",
            e[e.BlockSlopedUpInnerCorner = 72] = "BlockSlopedUpInnerCorner",
            e[e.BlockSlopedUpOuterCorner = 73] = "BlockSlopedUpOuterCorner",
            e[e.FinishWide = 74] = "FinishWide",
            e[e.PlaneCheckpoint = 75] = "PlaneCheckpoint",
            e[e.PlaneFinish = 76] = "PlaneFinish",
            e[e.PlaneCheckpointWide = 77] = "PlaneCheckpointWide",
            e[e.PlaneFinishWide = 78] = "PlaneFinishWide",
            e[e.WallTrackBottomInnerCorner = 79] = "WallTrackBottomInnerCorner",
            e[e.WallTrackInnerCorner = 80] = "WallTrackInnerCorner",
            e[e.WallTrackTopInnerCorner = 81] = "WallTrackTopInnerCorner",
            e[e.TurnLong2 = 82] = "TurnLong2",
            e[e.TurnLong3 = 83] = "TurnLong3",
            e[e.SlopePillarShort = 84] = "SlopePillarShort",
            e[e.BlockSlopeUp = 85] = "BlockSlopeUp",
            e[e.BlockSlopeDown = 86] = "BlockSlopeDown",
            e[e.SlopeBlock = 87] = "SlopeBlock",
            e[e.SlopeUpBlock = 88] = "SlopeUpBlock",
            e[e.SlopeDownBlock = 89] = "SlopeDownBlock",
            e[e.SlopeUpLeftWideBlock = 90] = "SlopeUpLeftWideBlock",
            e[e.SlopeUpRightWideBlock = 91] = "SlopeUpRightWideBlock",
            e[e.SlopeDownLeftWideBlock = 92] = "SlopeDownLeftWideBlock",
            e[e.SlopeDownRightWideBlock = 93] = "SlopeDownRightWideBlock",
            e[e.SlopeLeftWideBlock = 94] = "SlopeLeftWideBlock",
            e[e.SlopeRightWideBlock = 95] = "SlopeRightWideBlock",
            e[e.PlaneSlopeUpBlock = 96] = "PlaneSlopeUpBlock",
            e[e.PlaneSlopeDownBlock = 97] = "PlaneSlopeDownBlock",
            e[e.PlaneSlopeBlock = 98] = "PlaneSlopeBlock",
            e[e.PlaneSlopePillar = 99] = "PlaneSlopePillar",
            e[e.PlaneSlopePillarShort = 100] = "PlaneSlopePillarShort",
            e[e.PillarBranch1Top = 101] = "PillarBranch1Top",
            e[e.PillarBranch1Bottom = 102] = "PillarBranch1Bottom",
            e[e.PillarBranch1Middle = 103] = "PillarBranch1Middle",
            e[e.PillarBranch2Top = 104] = "PillarBranch2Top",
            e[e.PillarBranch2Middle = 105] = "PillarBranch2Middle",
            e[e.PillarBranch2Bottom = 106] = "PillarBranch2Bottom",
            e[e.PillarBranch3Top = 107] = "PillarBranch3Top",
            e[e.PillarBranch3Middle = 108] = "PillarBranch3Middle",
            e[e.PillarBranch3Bottom = 109] = "PillarBranch3Bottom",
            e[e.PillarBranch4Top = 110] = "PillarBranch4Top",
            e[e.PillarBranch4Middle = 111] = "PillarBranch4Middle",
            e[e.PillarBranch4Bottom = 112] = "PillarBranch4Bottom",
            e[e.PillarBranch5 = 113] = "PillarBranch5",
            e[e.PillarBranch5Top = 114] = "PillarBranch5Top",
            e[e.PillarBranch5Middle = 115] = "PillarBranch5Middle",
            e[e.PillarBranch5Bottom = 116] = "PillarBranch5Bottom",
            e[e.ToWideDouble = 117] = "ToWideDouble",
            e[e.ToWideDiagonal = 118] = "ToWideDiagonal",
            e[e.StraightPillarBottom = 119] = "StraightPillarBottom",
            e[e.StraightPillarShort = 120] = "StraightPillarShort",
            e[e.TurnSharpPillarBottom = 121] = "TurnSharpPillarBottom",
            e[e.TurnSharpPillarShort = 122] = "TurnSharpPillarShort",
            e[e.IntersectionTPillarBottom = 123] = "IntersectionTPillarBottom",
            e[e.IntersectionTPillarShort = 124] = "IntersectionTPillarShort",
            e[e.IntersectionCrossPillarBottom = 125] = "IntersectionCrossPillarBottom",
            e[e.IntersectionCrossPillarShort = 126] = "IntersectionCrossPillarShort",
            e[e.PlaneBridgeCorner = 127] = "PlaneBridgeCorner",
            e[e.PlaneBridgeIntersectionT = 128] = "PlaneBridgeIntersectionT",
            e[e.PlaneBridgeIntersectionCross = 129] = "PlaneBridgeIntersectionCross",
            e[e.BlockBridge = 130] = "BlockBridge",
            e[e.BlockBridgeCorner = 131] = "BlockBridgeCorner",
            e[e.BlockBridgeIntersectionT = 132] = "BlockBridgeIntersectionT",
            e[e.BlockBridgeIntersectionCross = 133] = "BlockBridgeIntersectionCross",
            e[e.RedBlock = 134] = "RedBlock",
            e[e.RedHalfBlock = 135] = "RedHalfBlock",
            e[e.RedQuarterBlock = 136] = "RedQuarterBlock",
            e[e.RedBlockSlopedDown = 137] = "RedBlockSlopedDown",
            e[e.RedBlockSlopedDownInnerCorner = 138] = "RedBlockSlopedDownInnerCorner",
            e[e.RedBlockSlopedDownOuterCorner = 139] = "RedBlockSlopedDownOuterCorner",
            e[e.RedBlockSlopedUp = 140] = "RedBlockSlopedUp",
            e[e.RedBlockSlopedUpInnerCorner = 141] = "RedBlockSlopedUpInnerCorner",
            e[e.RedBlockSlopedUpOuterCorner = 142] = "RedBlockSlopedUpOuterCorner",
            e[e.RedBlockSlopeDown = 143] = "RedBlockSlopeDown",
            e[e.RedBlockSlopeUp = 144] = "RedBlockSlopeUp",
            e[e.RedBlockBridge = 145] = "RedBlockBridge",
            e[e.RedBlockBridgeCorner = 146] = "RedBlockBridgeCorner",
            e[e.RedBlockBridgeIntersectionT = 147] = "RedBlockBridgeIntersectionT",
            e[e.RedBlockBridgeIntersectionCross = 148] = "RedBlockBridgeIntersectionCross",
            e[e.BlueBlock = 149] = "BlueBlock",
            e[e.BlueHalfBlock = 150] = "BlueHalfBlock",
            e[e.BlueQuarterBlock = 151] = "BlueQuarterBlock",
            e[e.BlueBlockSlopedDown = 152] = "BlueBlockSlopedDown",
            e[e.BlueBlockSlopedDownInnerCorner = 153] = "BlueBlockSlopedDownInnerCorner",
            e[e.BlueBlockSlopedDownOuterCorner = 154] = "BlueBlockSlopedDownOuterCorner",
            e[e.BlueBlockSlopedUp = 155] = "BlueBlockSlopedUp",
            e[e.BlueBlockSlopedUpInnerCorner = 156] = "BlueBlockSlopedUpInnerCorner",
            e[e.BlueBlockSlopedUpOuterCorner = 157] = "BlueBlockSlopedUpOuterCorner",
            e[e.BlueBlockSlopeDown = 158] = "BlueBlockSlopeDown",
            e[e.BlueBlockSlopeUp = 159] = "BlueBlockSlopeUp",
            e[e.BlueBlockBridge = 160] = "BlueBlockBridge",
            e[e.BlueBlockBridgeCorner = 161] = "BlueBlockBridgeCorner",
            e[e.BlueBlockBridgeIntersectionT = 162] = "BlueBlockBridgeIntersectionT",
            e[e.BlueBlockBridgeIntersectionCross = 163] = "BlueBlockBridgeIntersectionCross",
            e[e.BlackBlock = 164] = "BlackBlock",
            e[e.BlackHalfBlock = 165] = "BlackHalfBlock",
            e[e.BlackQuarterBlock = 166] = "BlackQuarterBlock",
            e[e.BlackBlockSlopedDown = 167] = "BlackBlockSlopedDown",
            e[e.BlackBlockSlopedDownInnerCorner = 168] = "BlackBlockSlopedDownInnerCorner",
            e[e.BlackBlockSlopedDownOuterCorner = 169] = "BlackBlockSlopedDownOuterCorner",
            e[e.BlackBlockSlopedUp = 170] = "BlackBlockSlopedUp",
            e[e.BlackBlockSlopedUpInnerCorner = 171] = "BlackBlockSlopedUpInnerCorner",
            e[e.BlackBlockSlopedUpOuterCorner = 172] = "BlackBlockSlopedUpOuterCorner",
            e[e.BlackBlockSlopeDown = 173] = "BlackBlockSlopeDown",
            e[e.BlackBlockSlopeUp = 174] = "BlackBlockSlopeUp",
            e[e.BlackBlockBridge = 175] = "BlackBlockBridge",
            e[e.BlackBlockBridgeCorner = 176] = "BlackBlockBridgeCorner",
            e[e.BlackBlockBridgeIntersectionT = 177] = "BlackBlockBridgeIntersectionT",
            e[e.BlackBlockBridgeIntersectionCross = 178] = "BlackBlockBridgeIntersectionCross"
        }(Jg || (Jg = {}));
        const Qg = Jg;
        var $g, ev, tv, nv, iv, rv, av, sv = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, ov = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        $g = new WeakMap,
        ev = new WeakMap,
        tv = new WeakMap,
        nv = new WeakMap,
        iv = new WeakMap,
        rv = new WeakMap,
        av = new WeakMap;
        const lv = class {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                $g.set(this, void 0),
                ev.set(this, void 0),
                tv.set(this, void 0),
                nv.set(this, void 0),
                iv.set(this, void 0),
                rv.set(this, void 0),
                av.set(this, void 0),
                sv(this, $g, a, "f"),
                sv(this, ev, n, "f"),
                sv(this, tv, i, "f"),
                sv(this, nv, r, "f"),
                sv(this, iv, o, "f");
                for (let e = -100; e < 100; ++e)
                    0 == e ? n.setPart(0, 0, e, Qg.Start, 2, null) : n.setPart(0, 0, e, Qg.Straight, 0, null);
                n.generateMeshes(),
                i.generateMountains(n.getBounds()),
                sv(this, av, new Jm(e,ov(this, ev, "f").getStartTransform(),null,null,!1,r,a,i,n,o), "f"),
                ov(this, av, "f").audioVolume = 0,
                ov(this, av, "f").update(0),
                sv(this, rv, new Kg(ov(this, av, "f"),t,r,a,l,s,c), "f"),
                r.setCamera(ov(this, rv, "f").camera)
            }
            dispose() {
                ov(this, ev, "f").clear(),
                ov(this, tv, "f").clearMountains(),
                ov(this, rv, "f").save(),
                ov(this, rv, "f").dispose(),
                ov(this, av, "f").dispose()
            }
            update(e) {
                ov(this, nv, "f").update(ov(this, av, "f").getPosition()),
                ov(this, $g, "f").update(e, !0, ov(this, nv, "f"), ov(this, iv, "f"))
            }
        }
        ;
        var cv = n(486)
          , hv = {};
        hv.styleTagTransform = u(),
        hv.setAttributes = l(),
        hv.insert = s().bind(null, "head"),
        hv.domAPI = r(),
        hv.insertStyleElement = h();
        t()(cv.Z, hv);
        cv.Z && cv.Z.locals && cv.Z.locals;
        var dv, uv, pv, fv, mv = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, gv = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        dv = new WeakMap,
        uv = new WeakMap,
        pv = new WeakMap,
        fv = new WeakMap;
        const vv = class {
            constructor() {
                dv.set(this, !1),
                uv.set(this, void 0),
                pv.set(this, 0),
                fv.set(this, 0);
                const e = document.getElementById("ui");
                mv(this, uv, document.createElement("div"), "f"),
                gv(this, uv, "f").className = "hidden",
                e.appendChild(gv(this, uv, "f"))
            }
            show() {
                gv(this, uv, "f").className = "debug",
                mv(this, dv, !0, "f")
            }
            hide() {
                gv(this, uv, "f").className = "hidden",
                mv(this, dv, !1, "f")
            }
            toggle() {
                gv(this, dv, "f") ? this.hide() : this.show()
            }
            update(e) {
                mv(this, pv, gv(this, pv, "f") + e, "f"),
                mv(this, fv, gv(this, fv, "f") + 1, "f"),
                gv(this, pv, "f") >= 1 && (gv(this, uv, "f").textContent = "FPS: " + gv(this, fv, "f"),
                mv(this, pv, gv(this, pv, "f") - Math.trunc(gv(this, pv, "f")), "f"),
                mv(this, fv, 0, "f"))
            }
        }
        ;
        var wv = n(986)
          , yv = {};
        yv.styleTagTransform = u(),
        yv.setAttributes = l(),
        yv.insert = s().bind(null, "head"),
        yv.domAPI = r(),
        yv.insertStyleElement = h();
        t()(wv.Z, yv);
        wv.Z && wv.Z.locals && wv.Z.locals;
        class _v extends sg {
            constructor(e, t) {
                super(e, t),
                this.screenSpacePanning = !1,
                this.mouseButtons = {
                    LEFT: w,
                    MIDDLE: v,
                    RIGHT: g
                },
                this.touches = {
                    ONE: _,
                    TWO: b
                }
            }
        }
        class xv extends Pl {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this
                  , a = new Il(this.manager);
                a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(e, (function(e) {
                    const n = r.parse(JSON.parse(e));
                    t && t(n)
                }
                ), n, i)
            }
            parse(e) {
                return new bv(e)
            }
        }
        class bv {
            constructor(e) {
                this.isFont = !0,
                this.type = "Font",
                this.data = e
            }
            generateShapes(e, t=100) {
                const n = []
                  , i = function(e, t, n) {
                    const i = Array.from(e)
                      , r = t / n.resolution
                      , a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r
                      , s = [];
                    let o = 0
                      , l = 0;
                    for (let e = 0; e < i.length; e++) {
                        const t = i[e];
                        if ("\n" === t)
                            o = 0,
                            l -= a;
                        else {
                            const e = Ev(t, r, o, l, n);
                            o += e.offsetX,
                            s.push(e.path)
                        }
                    }
                    return s
                }(e, t, this.data);
                for (let e = 0, t = i.length; e < t; e++)
                    n.push(...i[e].toShapes());
                return n
            }
        }
        function Ev(e, t, n, i, r) {
            const a = r.glyphs[e] || r.glyphs["?"];
            if (!a)
                return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".");
            const s = new hc;
            let o, l, c, h, d, u, p, f;
            if (a.o) {
                const e = a._cachedOutline || (a._cachedOutline = a.o.split(" "));
                for (let r = 0, a = e.length; r < a; ) {
                    switch (e[r++]) {
                    case "m":
                        o = e[r++] * t + n,
                        l = e[r++] * t + i,
                        s.moveTo(o, l);
                        break;
                    case "l":
                        o = e[r++] * t + n,
                        l = e[r++] * t + i,
                        s.lineTo(o, l);
                        break;
                    case "q":
                        c = e[r++] * t + n,
                        h = e[r++] * t + i,
                        d = e[r++] * t + n,
                        u = e[r++] * t + i,
                        s.quadraticCurveTo(d, u, c, h);
                        break;
                    case "b":
                        c = e[r++] * t + n,
                        h = e[r++] * t + i,
                        d = e[r++] * t + n,
                        u = e[r++] * t + i,
                        p = e[r++] * t + n,
                        f = e[r++] * t + i,
                        s.bezierCurveTo(d, u, p, f, c, h)
                    }
                }
            }
            return {
                offsetX: a.ha * t,
                path: s
            }
        }
        class Sv extends Vs {
            constructor(e, t) {
                const n = new In({
                    color: t,
                    depthWrite: !1
                });
                super(e.geometry, n, e.count);
                for (let t = 0; t < e.count; ++t) {
                    const n = new Ft;
                    e.getMatrixAt(t, n),
                    this.setMatrixAt(t, n)
                }
                this.meshMatrix = e.matrixWorld,
                this.frustumCulled = !1,
                this.matrixAutoUpdate = !1,
                this.renderOrder = -1
            }
            update(e, t) {
                var n = new Ft
                  , i = e.normal.x * t.x + e.normal.y * t.y + e.normal.z * t.z + -e.constant * t.w
                  , r = n.elements;
                r[0] = i - t.x * e.normal.x,
                r[4] = -t.x * e.normal.y,
                r[8] = -t.x * e.normal.z,
                r[12] = -t.x * -e.constant,
                r[1] = -t.y * e.normal.x,
                r[5] = i - t.y * e.normal.y,
                r[9] = -t.y * e.normal.z,
                r[13] = -t.y * -e.constant,
                r[2] = -t.z * e.normal.x,
                r[6] = -t.z * e.normal.y,
                r[10] = i - t.z * e.normal.z,
                r[14] = -t.z * -e.constant,
                r[3] = -t.w * e.normal.x,
                r[7] = -t.w * e.normal.y,
                r[11] = -t.w * e.normal.z,
                r[15] = i - t.w * -e.constant,
                this.matrix.multiplyMatrices(n, this.meshMatrix)
            }
        }
        var Mv = n(23);
        const Tv = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
          , kv = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
        function Cv(e) {
            let t = 0
              , n = "";
            for (; t < 8 * e.length; ) {
                const i = Pv(e, t);
                let r;
                30 == (30 & i) ? (r = 31 & i,
                t += 5) : (r = i,
                t += 6),
                n += Tv[r]
            }
            return n
        }
        function Av(e) {
            let t = 0;
            const n = []
              , i = e.length;
            for (let r = 0; r < i; r++) {
                const a = e.charCodeAt(r);
                if (a >= kv.length)
                    return null;
                const s = kv[a];
                if (-1 == s)
                    return null;
                30 == (30 & s) ? (Rv(n, t, 5, s, r == i - 1),
                t += 5) : (Rv(n, t, 6, s, r == i - 1),
                t += 6)
            }
            return new Uint8Array(n)
        }
        function Pv(e, t) {
            if (t >= 8 * e.length)
                throw "Out of range";
            const n = Math.floor(t / 8)
              , i = e[n]
              , r = t - 8 * n;
            if (r <= 2 || n >= e.length - 1)
                return (i & 63 << r) >>> r;
            return (i & 63 << r) >>> r | (e[n + 1] & 63 >>> 8 - r) << 8 - r
        }
        function Rv(e, t, n, i, r) {
            const a = Math.floor(t / 8);
            for (; a >= e.length; )
                e.push(0);
            const s = t - 8 * a;
            if (e[a] |= i << s & 255,
            s > 8 - n && !r) {
                const t = a + 1;
                t >= e.length && e.push(0),
                e[t] |= i >> 8 - s
            }
        }
        var Lv;
        !function(e) {
            e[e.Checkpoint = 0] = "Checkpoint",
            e[e.Finish = 1] = "Finish"
        }(Lv || (Lv = {}));
        const Iv = Lv;
        function Nv(e, t) {
            const n = e.parts;
            if ("object" != typeof n && null !== n && !Array.isArray(n))
                return null;
            const i = t.getPartTypesWithDetector(Iv.Checkpoint)
              , r = new Gv
              , a = Object.keys(n);
            for (let e = 0; e < a.length; ++e) {
                const t = parseInt(a[e], 10);
                if (!(t in Qg))
                    return null;
                {
                    const e = n[t];
                    if (!Array.isArray(e))
                        return null;
                    if (e.length % 4 != 0)
                        return null;
                    for (let n = 0; n < e.length; n += 4) {
                        const a = parseInt(e[n + 0], 10)
                          , s = parseInt(e[n + 1], 10)
                          , o = parseInt(e[n + 2], 10)
                          , l = parseInt(e[n + 3], 10);
                        if (isNaN(a) || isNaN(s) || isNaN(o) || isNaN(l))
                            return null;
                        if (!(l >= 0 && l <= 3 && Math.abs(a) <= 1e9 && s >= 0 && s <= 1e9 && Math.abs(o) <= 1e9))
                            return null;
                        if (i.includes(t))
                            return null;
                        r.addPart(a, s, o, t, l, null)
                    }
                }
            }
            return r
        }
        function Uv(e, t) {
            if ("string" != typeof e.name)
                return null;
            if ("string" != typeof e.track)
                return null;
            let n;
            try {
                n = JSON.parse(e.track)
            } catch (e) {
                return console.error(e),
                null
            }
            const i = Nv(n, t);
            return null == i ? null : {
                trackName: e.name,
                trackData: i
            }
        }
        function Dv(e, t) {
            const n = zf(e);
            if (null == n)
                return null;
            const i = t.getPartTypesWithDetector(Iv.Checkpoint)
              , r = new Gv;
            let a = 0;
            for (; a < n.length; ) {
                if (n.length - a < 2)
                    return null;
                const e = n[a + 0] | n[a + 1] << 8;
                if (a += 2,
                !(e in Qg))
                    return null;
                if (n.length - a < 4)
                    return null;
                const t = n[a + 0] | n[a + 1] << 8 | n[a + 2] << 16 | n[a + 3] << 24;
                a += 4;
                for (let s = 0; s < t; ++s) {
                    if (n.length - a < 3)
                        return null;
                    const t = (n[a + 0] | n[a + 1] << 8 | n[a + 2] << 16) - Math.pow(2, 23);
                    if (a += 3,
                    n.length - a < 3)
                        return null;
                    const s = n[a + 0] | n[a + 1] << 8 | n[a + 2] << 16;
                    if (a += 3,
                    n.length - a < 3)
                        return null;
                    const o = (n[a + 0] | n[a + 1] << 8 | n[a + 2] << 16) - Math.pow(2, 23);
                    if (a += 3,
                    n.length - a < 1)
                        return null;
                    const l = 3 & n[a + 0];
                    if (a += 1,
                    i.includes(e))
                        return null;
                    r.addPart(t, s, o, e, l, null)
                }
            }
            return r
        }
        function Bv(e, t) {
            const n = Av(e);
            if (null == n)
                return null;
            const i = new Of.Inflate;
            if (i.push(n, !0),
            i.err)
                return null;
            const r = i.result
              , a = t.getPartTypesWithDetector(Iv.Checkpoint)
              , s = new Gv;
            let o = 0;
            for (; o < r.length; ) {
                if (r.length - o < 2)
                    return null;
                const e = r[o + 0] | r[o + 1] << 8;
                if (o += 2,
                !(e in Qg))
                    return null;
                if (r.length - o < 4)
                    return null;
                const t = r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16 | r[o + 3] << 24;
                o += 4;
                for (let n = 0; n < t; ++n) {
                    if (r.length - o < 3)
                        return null;
                    const t = (r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16) - Math.pow(2, 23);
                    if (o += 3,
                    r.length - o < 3)
                        return null;
                    const n = r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16;
                    if (o += 3,
                    r.length - o < 3)
                        return null;
                    const i = (r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16) - Math.pow(2, 23);
                    if (o += 3,
                    r.length - o < 1)
                        return null;
                    const l = 3 & r[o + 0];
                    o += 1;
                    let c = null;
                    a.includes(e) && (c = r[o + 0] | r[o + 1] << 8,
                    o += 2),
                    s.addPart(t, n, i, e, l, c)
                }
            }
            return s
        }
        function Ov(e, t) {
            const n = Av(e);
            if (null == n)
                return null;
            const i = new Of.Inflate;
            if (i.push(n, !0),
            i.err)
                return null;
            const r = i.result
              , a = t.getPartTypesWithDetector(Iv.Checkpoint)
              , s = new Gv;
            let o = 0;
            for (; o < r.length; ) {
                if (r.length - o < 2)
                    return null;
                const e = r[o + 0] | r[o + 1] << 8;
                if (o += 2,
                !(e in Qg))
                    return null;
                if (r.length - o < 4)
                    return null;
                const t = r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16 | r[o + 3] << 24;
                o += 4;
                for (let n = 0; n < t; ++n) {
                    if (r.length - o < 3)
                        return null;
                    const t = (r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16) - Math.pow(2, 23);
                    if (o += 3,
                    r.length - o < 3)
                        return null;
                    const n = r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16;
                    if (o += 3,
                    r.length - o < 3)
                        return null;
                    const i = (r[o + 0] | r[o + 1] << 8 | r[o + 2] << 16) - Math.pow(2, 23);
                    if (o += 3,
                    r.length - o < 1)
                        return null;
                    const l = 3 & r[o + 0];
                    o += 1;
                    let c = null;
                    a.includes(e) && (c = r[o + 0] | r[o + 1] << 8,
                    o += 2),
                    s.addPart(t, n, i, e, l, c)
                }
            }
            return s
        }
        var zv, Fv, Wv, Hv, Vv = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Fv = new WeakMap,
        zv = new WeakSet,
        Wv = function() {
            const e = Vv(this, Fv, "f").get(Qg.Start);
            return null != e && e.length > 0 ? e[e.length - 1] : null
        }
        ,
        Hv = function(e) {
            const t = e.getPartTypesWithDetector(Iv.Checkpoint)
              , n = [];
            return Vv(this, Fv, "f").forEach(((e,i)=>{
                if (i < 0 || i > 65535)
                    throw "Type id is out of range";
                const r = e.length;
                n.push(255 & i, i >>> 8 & 255, 255 & r, r >>> 8 & 255, r >>> 16 & 255, r >>> 24 & 255),
                e.forEach((e=>{
                    const r = e.x + Math.pow(2, 23)
                      , a = e.y
                      , s = e.z + Math.pow(2, 23);
                    if (n.push(255 & r, r >>> 8 & 255, r >>> 16 & 255, 255 & a, a >>> 8 & 255, a >>> 16 & 255, 255 & s, s >>> 8 & 255, s >>> 16 & 255, 3 & e.rotation),
                    t.includes(i)) {
                        if (null == e.checkpointOrder)
                            throw "Checkpoint has no checkpoint order";
                        n.push(255 & e.checkpointOrder, e.checkpointOrder >>> 8 & 255)
                    }
                }
                ))
            }
            )),
            new Uint8Array(n)
        }
        ;
        const Gv = class {
            constructor() {
                zv.add(this),
                Fv.set(this, new Map)
            }
            addPart(e, t, n, i, r, a) {
                const s = Vv(this, Fv, "f").get(i);
                null != s ? s.push({
                    x: e,
                    y: t,
                    z: n,
                    rotation: r,
                    checkpointOrder: a
                }) : Vv(this, Fv, "f").set(i, [{
                    x: e,
                    y: t,
                    z: n,
                    rotation: r,
                    checkpointOrder: a
                }])
            }
            forEachPart(e) {
                Vv(this, Fv, "f").forEach(((t,n)=>{
                    t.forEach((t=>{
                        e(t.x, t.y, t.z, n, t.rotation, t.checkpointOrder)
                    }
                    ))
                }
                ))
            }
            getId(e) {
                return (0,
                Mv.sha256)(Vv(this, zv, "m", Hv).call(this, e))
            }
            getBounds() {
                let e = 1 / 0
                  , t = 1 / 0
                  , n = -1 / 0
                  , i = -1 / 0;
                return this.forEachPart(((r,a,s)=>{
                    e = Math.min(r, e),
                    t = Math.min(s, t),
                    n = Math.max(r, n),
                    i = Math.max(s, i)
                }
                )),
                Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? {
                    min: new De(e,t),
                    max: new De(n,i)
                } : {
                    min: new De,
                    max: new De
                }
            }
            hasStartingPoint() {
                return Vv(this, Fv, "f").has(Qg.Start)
            }
            getStartTransform() {
                const e = Vv(this, zv, "m", Wv).call(this);
                if (null != e) {
                    const t = (new ct).setFromEuler(new Kt(0,Math.PI + e.rotation * Math.PI / 2,0))
                      , n = new ht(0,.385,1.35);
                    return n.applyQuaternion(t),
                    {
                        position: new ht(e.x * cw.partWidth + n.x,e.y * cw.partHeight + n.y,e.z * cw.partLength + n.z),
                        quaternion: t
                    }
                }
                return null
            }
            toSaveString(e) {
                const t = Vv(this, zv, "m", Hv).call(this, e)
                  , n = new Of.Deflate({
                    level: 9
                });
                return n.push(t, !0),
                Cv(n.result)
            }
            toExportString(e, t) {
                const n = Cv((new TextEncoder).encode(e))
                  , i = new Uint8Array(1);
                i[0] = n.length;
                let r = Cv(i);
                return 1 == r.length && (r += "A"),
                "v3" + r + n + this.toSaveString(t)
            }
            static fromSaveString(e, t) {
                const n = Ov(e, t);
                if (null != n)
                    return n;
                const i = Bv(e, t);
                if (null != i)
                    return i;
                const r = Dv(e, t);
                if (null != r)
                    return r;
                const a = Nv(e, t);
                return null != a ? a : null
            }
            static fromExportString(e, t) {
                const n = e.replace(/\s+/g, "")
                  , i = function(e, t) {
                    if (!e.startsWith("v3"))
                        return null;
                    const n = Av(e.substring(2, 4));
                    if (null == n)
                        return null;
                    if (1 != n.length)
                        return null;
                    const i = n[0]
                      , r = Av(e.substring(4, 4 + i));
                    if (null == r)
                        return null;
                    let a;
                    try {
                        a = new TextDecoder("utf-8").decode(r)
                    } catch (e) {
                        return null
                    }
                    const s = Ov(e.substring(4 + i), t);
                    return null == s ? null : {
                        trackName: a,
                        trackData: s
                    }
                }(n, t);
                if (null != i)
                    return i;
                const r = function(e, t) {
                    if (!e.startsWith("v2"))
                        return null;
                    const n = Av(e.substring(2, 4));
                    if (null == n)
                        return null;
                    if (1 != n.length)
                        return null;
                    const i = n[0]
                      , r = Math.ceil(i / 3 * 4)
                      , a = Av(e.substring(4, 4 + r));
                    if (null == a)
                        return null;
                    let s;
                    try {
                        s = new TextDecoder("utf-8").decode(a)
                    } catch (e) {
                        return null
                    }
                    const o = Bv(e.substring(4 + r), t);
                    return null == o ? null : {
                        trackName: s,
                        trackData: o
                    }
                }(n, t);
                if (null != r)
                    return r;
                const a = function(e, t) {
                    if (!e.startsWith("v1n"))
                        return null;
                    const n = zf(e.substring(3, 5));
                    if (null == n)
                        return null;
                    if (1 != n.length)
                        return null;
                    const i = n[0]
                      , r = e.substring(5, 5 + i);
                    let a;
                    try {
                        a = decodeURIComponent(r)
                    } catch (e) {
                        return console.error(e),
                        null
                    }
                    const s = Dv(e.substring(5 + i), t);
                    return null == s ? null : {
                        trackName: a,
                        trackData: s
                    }
                }(n, t);
                if (null != a)
                    return a;
                const s = Uv(e, t);
                return null != s ? s : null
            }
            createThumbnail(e) {
                const t = document.createElement("canvas");
                let n = 0
                  , i = 0
                  , r = 0
                  , a = 0;
                this.forEachPart(((e,t,s)=>{
                    n = Math.min(n, e),
                    i = Math.min(i, s),
                    r = Math.max(r, e),
                    a = Math.max(a, s)
                }
                ));
                const s = 10
                  , o = r - n + 1;
                o <= s && (r += Math.ceil((s - o) / 2),
                n -= Math.ceil((s - o) / 2));
                const l = a - i + 1;
                l <= s && (a += Math.ceil((s - l) / 2),
                i -= Math.ceil((s - l) / 2)),
                t.width = Math.min(1024, r - n + 1),
                t.height = Math.min(1024, a - i + 1);
                const c = t.getContext("2d");
                c.fillStyle = "#fff";
                const h = []
                  , d = []
                  , u = [];
                return this.forEachPart(((t,r,a,s,o)=>{
                    const l = e.getPart(s);
                    l.tiles.rotated(o).forEach(((e,r,o)=>{
                        c.fillRect(t + e - n, a + o - i, 1, 1),
                        s == Qg.Start ? d.push([t + e - n, a + o - i]) : null != l.detector && l.detector.type == Iv.Checkpoint ? h.push([t + e - n, a + o - i]) : null != l.detector && l.detector.type == Iv.Finish && u.push([t + e - n, a + o - i])
                    }
                    ))
                }
                )),
                c.fillStyle = "#e2c026",
                h.forEach((([e,t])=>{
                    c.fillRect(e, t, 1, 1)
                }
                )),
                c.fillStyle = "#338ce0",
                d.forEach((([e,t])=>{
                    c.fillRect(e, t, 1, 1)
                }
                )),
                c.fillStyle = "#d12929",
                u.forEach((([e,t])=>{
                    c.fillRect(e, t, 1, 1)
                }
                )),
                t
            }
        }
        ;
        var jv, Xv, qv, Yv, Zv, Kv, Jv, Qv, $v, ew, tw, nw, iw, rw, aw = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, sw = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class ow {
            constructor(e, t, n, i, r, a, s) {
                if (this.checkpointOrder = null,
                this.x = e,
                this.y = t,
                this.z = n,
                this.rotation = i,
                this.type = r,
                this.matrix = a,
                this.checkpointOrder = s,
                null != r.detector && r.detector.type == Iv.Checkpoint) {
                    if (null == s)
                        throw "Checkpoint has no checkpoint order"
                } else if (null != s)
                    throw "Non-checkpoint has checkpoint order"
            }
        }
        class lw {
            constructor(e, t, n) {
                jv.add(this),
                Xv.set(this, void 0),
                qv.set(this, void 0),
                Yv.set(this, void 0),
                Zv.set(this, []),
                Kv.set(this, new Map),
                Jv.set(this, new Map),
                Qv.set(this, {
                    min: new De(0,0),
                    max: new De(0,0)
                }),
                $v.set(this, null),
                ew.set(this, []),
                aw(this, Xv, e, "f"),
                aw(this, qv, t, "f"),
                aw(this, Yv, n, "f")
            }
            getID() {
                return sw(this, $v, "f")
            }
            clear() {
                aw(this, $v, null, "f"),
                sw(this, Zv, "f").length = 0,
                sw(this, Kv, "f").clear(),
                sw(this, Jv, "f").clear(),
                sw(this, jv, "m", tw).call(this)
            }
            hasPartAt(e, t, n) {
                return sw(this, Kv, "f").has(e + "|" + t + "|" + n)
            }
            getPartAt(e, t, n) {
                const i = sw(this, Kv, "f").get(e + "|" + t + "|" + n);
                return null == i ? null : {
                    id: i.type.id,
                    rotation: i.rotation
                }
            }
            setPart(e, t, n, i, r, a) {
                const s = sw(this, Yv, "f").getPart(i)
                  , o = new ow(e,t,n,r,s,(new Ft).makeRotationY(r * Math.PI / 2).setPosition(e * lw.partWidth, t * lw.partHeight, n * lw.partLength),a);
                sw(this, Zv, "f").push(o);
                s.tiles.rotated(r).forEach(((i,r,a)=>{
                    const s = e + i + "|" + (t + r) + "|" + (n + a);
                    if (this.hasPartAt(e + i, t + r, n + a))
                        throw "Track part collision";
                    sw(this, Kv, "f").set(s, o)
                }
                ));
                const l = sw(this, Jv, "f").get(i);
                null == l ? sw(this, Jv, "f").set(i, [o]) : l.push(o)
            }
            deletePart(e, t, n) {
                const i = sw(this, Kv, "f").get(e + "|" + t + "|" + n);
                if (null == i)
                    throw "Track part missing from parts by position map";
                for (let e = 0; e < sw(this, Zv, "f").length; ++e) {
                    if (sw(this, Zv, "f")[e] == i) {
                        sw(this, Zv, "f").splice(e, 1);
                        break
                    }
                    if (e == sw(this, Zv, "f").length - 1)
                        throw "Track part missing from parts list"
                }
                i.type.tiles.rotated(i.rotation).forEach(((e,t,n)=>{
                    const r = i.x + e + "|" + (i.y + t) + "|" + (i.z + n);
                    if (!sw(this, Kv, "f").has(r))
                        throw "Track part section missing";
                    sw(this, Kv, "f").delete(r)
                }
                ));
                const r = sw(this, Jv, "f").get(i.type.id);
                if (null == r)
                    throw "Track part type is missing from parts by type map";
                for (let e = 0; e < r.length; ++e) {
                    if (r[e] == i) {
                        r.splice(e, 1);
                        break
                    }
                    if (e == r.length - 1)
                        throw "Track part is missing from parts by type map"
                }
            }
            getBounds() {
                return sw(this, Qv, "f")
            }
            shortRaycast(e) {
                const t = new ht(Math.floor(e.ray.origin.x / lw.partWidth),Math.floor(e.ray.origin.y / lw.partHeight),Math.floor(e.ray.origin.z / lw.partLength))
                  , n = new Set;
                for (let e = -1; e <= 1; e++)
                    for (let i = -1; i <= 1; i++)
                        for (let r = -1; r <= 1; r++) {
                            const a = sw(this, jv, "m", nw).call(this, t.x + e, t.y + i, t.z + r);
                            null != a && n.add(a)
                        }
                let i = null;
                return n.forEach((t=>{
                    if (null == t.type.mesh)
                        throw "Track part is not loaded yet";
                    if (null == i) {
                        t.type.mesh.matrixWorld.copy(t.matrix);
                        const n = e.intersectObject(t.type.mesh, !0);
                        n.length > 0 && (i = n[0])
                    }
                }
                )),
                i
            }
            generateMeshes() {
                sw(this, jv, "m", tw).call(this);
                const e = sw(this, Xv, "f").getShadowDirection()
                  , t = new rt(e.x,e.y,e.z,0);
                sw(this, Yv, "f").getAllParts().forEach((e=>{
                    const n = [];
                    for (let t = 0; t < sw(this, Zv, "f").length; ++t)
                        sw(this, Zv, "f")[t].type == e && n.push(sw(this, Zv, "f")[t]);
                    if (n.length > 0) {
                        if (null == e.mesh)
                            throw "Mesh is not loaded";
                        const i = new Vs(e.mesh.geometry,e.mesh.material,n.length);
                        i.frustumCulled = !1,
                        i.receiveShadow = !0;
                        for (let e = 0; e < n.length; ++e)
                            i.setMatrixAt(e, n[e].matrix);
                        if (sw(this, Xv, "f").scene.add(i),
                        sw(this, ew, "f").push(i),
                        sw(this, qv, "f").getSettingBoolean(uc.TrackShadowEnabled)) {
                            const e = new Sv(i,1192238);
                            e.update(new Ci(new ht(0,1,0),0), t),
                            sw(this, Xv, "f").scene.add(e),
                            sw(this, ew, "f").push(e)
                        }
                    }
                }
                )),
                sw(this, jv, "m", iw).call(this)
            }
            getCheckpoints() {
                let e = [];
                return sw(this, Yv, "f").getPartTypesWithDetector(Iv.Checkpoint).forEach((t=>{
                    const n = sw(this, Jv, "f").get(t);
                    null != n && (e = e.concat(n))
                }
                )),
                e.map((e=>{
                    if (null == e.checkpointOrder)
                        throw "Checkpoint has no checkpoint order";
                    if (null == e.type.detector)
                        throw "Checkpoint has no detector";
                    return {
                        x: e.x,
                        y: e.y,
                        z: e.z,
                        rotation: e.rotation,
                        checkpointOrder: e.checkpointOrder,
                        detector: e.type.detector
                    }
                }
                ))
            }
            getCheckpointOrders() {
                let e = [];
                return sw(this, Yv, "f").getPartTypesWithDetector(Iv.Checkpoint).forEach((t=>{
                    const n = sw(this, Jv, "f").get(t);
                    null != n && (e = e.concat(n))
                }
                )),
                e.map((e=>{
                    if (null == e.checkpointOrder)
                        throw "Checkpoint has no checkpoint order";
                    if (null == e.type.detector)
                        throw "Checkpoint has no detector";
                    return e.checkpointOrder
                }
                ))
            }
            getTotalNumberOfCheckpointIndices() {
                let e = [];
                if (sw(this, Yv, "f").getPartTypesWithDetector(Iv.Checkpoint).forEach((t=>{
                    const n = sw(this, Jv, "f").get(t);
                    null != n && (e = e.concat(n))
                }
                )),
                null == e)
                    return 0;
                return e.map((e=>e.checkpointOrder)).filter(((e,t,n)=>n.indexOf(e) == t)).length
            }
            getStartTransform() {
                const e = sw(this, jv, "m", rw).call(this);
                if (null != e) {
                    const t = (new ct).setFromEuler(new Kt(0,Math.PI + e.rotation * Math.PI / 2,0))
                      , n = new ht(0,.385,1.35);
                    return n.applyQuaternion(t),
                    {
                        position: new ht(e.x * lw.partWidth + n.x,e.y * lw.partHeight + n.y,e.z * lw.partLength + n.z),
                        quaternion: t
                    }
                }
                return null
            }
            getTrackData() {
                const e = new Gv;
                return sw(this, Zv, "f").forEach((t=>{
                    e.addPart(t.x, t.y, t.z, t.type.id, t.rotation, t.checkpointOrder)
                }
                )),
                e
            }
            loadTrackData(e, t=!0) {
                return this.clear(),
                aw(this, $v, t ? e.getId(sw(this, Yv, "f")) : null, "f"),
                e.forEachPart(((e,t,n,i,r,a)=>{
                    this.setPart(e, t, n, i, r, a)
                }
                )),
                !0
            }
        }
        Xv = new WeakMap,
        qv = new WeakMap,
        Yv = new WeakMap,
        Zv = new WeakMap,
        Kv = new WeakMap,
        Jv = new WeakMap,
        Qv = new WeakMap,
        $v = new WeakMap,
        ew = new WeakMap,
        jv = new WeakSet,
        tw = function() {
            for (let e = 0; e < sw(this, ew, "f").length; ++e) {
                const t = sw(this, ew, "f")[e];
                sw(this, Xv, "f").scene.remove(t)
            }
            sw(this, ew, "f").length = 0
        }
        ,
        nw = function(e, t, n) {
            return sw(this, Kv, "f").get(e + "|" + t + "|" + n)
        }
        ,
        iw = function() {
            let e = 1 / 0
              , t = 1 / 0
              , n = -1 / 0
              , i = -1 / 0;
            sw(this, Zv, "f").forEach((r=>{
                e = Math.min(r.x, e),
                t = Math.min(r.z, t),
                n = Math.max(r.x, n),
                i = Math.max(r.z, i)
            }
            )),
            Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? aw(this, Qv, {
                min: new De(e,t),
                max: new De(n,i)
            }, "f") : aw(this, Qv, {
                min: new De,
                max: new De
            }, "f")
        }
        ,
        rw = function() {
            const e = sw(this, Jv, "f").get(Qg.Start);
            return null != e && e.length > 0 ? e[e.length - 1] : null
        }
        ,
        lw.partWidth = 20,
        lw.partHeight = 5,
        lw.partLength = 20;
        const cw = lw;
        var hw, dw, uw, pw, fw, mw = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, gw = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class vw {
            constructor(e) {
                dw.set(this, void 0),
                uw.set(this, []),
                pw.set(this, []),
                mw(this, dw, e, "f")
            }
            dispose() {
                gw(this, uw, "f").forEach((e=>{
                    Array.isArray(e.material) ? e.material.forEach((e=>e.dispose())) : e.material.dispose(),
                    e.geometry.dispose(),
                    gw(this, dw, "f").scene.remove(e)
                }
                )),
                gw(this, uw, "f").length = 0
            }
            refresh(e) {
                const t = e.getCheckpoints();
                let n = !1;
                if (t.length == gw(this, pw, "f").length)
                    for (let e = 0; e < t.length; e++) {
                        const i = t[e]
                          , r = gw(this, pw, "f")[e];
                        if (i.x != r.x || i.y != r.y || i.z != r.z || i.rotation != r.rotation || i.checkpointOrder != r.checkpointOrder) {
                            n = !0;
                            break
                        }
                    }
                else
                    n = !0;
                if (n) {
                    this.dispose(),
                    mw(this, pw, t, "f");
                    const e = new In({
                        color: 16777215
                    });
                    t.forEach((t=>{
                        if (null == gw(hw, hw, "f", fw))
                            throw "Font is not loaded yet";
                        const n = new ht(...t.detector.center);
                        let i;
                        if (0 == t.rotation)
                            i = new ht(n.x,n.y,n.z);
                        else if (1 == t.rotation)
                            i = new ht(n.z,n.y,-n.x);
                        else if (2 == t.rotation)
                            i = new ht(-n.x,n.y,-n.z);
                        else {
                            if (3 != t.rotation)
                                throw "Invalid rotation";
                            i = new ht(n.z,n.y,n.x)
                        }
                        i.add(new ht(t.x * cw.partWidth,t.y * cw.partHeight,t.z * cw.partLength)),
                        i.add(new ht(0,-1.3,0));
                        const r = gw(hw, hw, "f", fw).generateShapes((t.checkpointOrder + 1).toString(), 4)
                          , a = new il(r);
                        a.computeBoundingBox();
                        const s = -.5 * (a.boundingBox.max.x - a.boundingBox.min.x);
                        a.translate(s, 0, 0);
                        const o = new di(a,e);
                        o.position.copy(i),
                        o.rotation.y = Math.PI / 2 * t.rotation,
                        gw(this, dw, "f").scene.add(o),
                        gw(this, uw, "f").push(o);
                        const l = new di(a,e);
                        l.position.copy(i),
                        l.rotation.y = Math.PI / 2 * t.rotation + Math.PI,
                        gw(this, dw, "f").scene.add(l),
                        gw(this, uw, "f").push(l)
                    }
                    ))
                }
            }
            static initResources(e) {
                e.addResource();
                (new xv).load("forced_square.json", (t=>{
                    mw(this, hw, t, "f", fw),
                    e.loadedResource()
                }
                ))
            }
        }
        hw = vw,
        dw = new WeakMap,
        uw = new WeakMap,
        pw = new WeakMap,
        fw = {
            value: null
        };
        const ww = vw;
        var yw = n(990)
          , _w = {};
        _w.styleTagTransform = u(),
        _w.setAttributes = l(),
        _w.insert = s().bind(null, "head"),
        _w.domAPI = r(),
        _w.insertStyleElement = h();
        t()(yw.Z, _w);
        yw.Z && yw.Z.locals && yw.Z.locals;
        var xw, bw, Ew, Sw, Mw, Tw, kw, Cw, Aw, Pw, Rw = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Lw = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        bw = new WeakMap,
        Ew = new WeakMap,
        Sw = new WeakMap,
        Mw = new WeakMap,
        Tw = new WeakMap,
        kw = new WeakMap,
        Cw = new WeakMap,
        xw = new WeakSet,
        Aw = function() {
            Lw(this, Tw, "f").textContent = Lw(this, Ew, "f").get("Checkpoint order") + ": " + (this.checkpointOrder + 1)
        }
        ,
        Pw = function(e) {
            const t = e.getCheckpointOrders()
              , n = new Set;
            t.forEach((e=>{
                n.add(e)
            }
            ));
            for (let e = 0; e < 65535; e++)
                if (!n.has(e))
                    return e;
            return 65535
        }
        ;
        const Iw = class {
            constructor(e, t, n, i) {
                xw.add(this),
                bw.set(this, void 0),
                Ew.set(this, void 0),
                Sw.set(this, void 0),
                Mw.set(this, void 0),
                Tw.set(this, void 0),
                kw.set(this, 0),
                Cw.set(this, void 0),
                Rw(this, bw, e, "f"),
                Rw(this, Ew, t, "f"),
                Rw(this, Sw, i, "f"),
                Rw(this, Mw, document.createElement("div"), "f"),
                Lw(this, Mw, "f").className = "hidden",
                e.appendChild(Lw(this, Mw, "f")),
                Lw(this, Sw, "f").addChangeListener(Rw(this, Cw, (e=>{
                    e ? Lw(this, Mw, "f").classList.add("touch") : Lw(this, Mw, "f").classList.remove("touch")
                }
                ), "f"));
                const r = document.createElement("div");
                r.className = "buttons",
                Lw(this, Mw, "f").appendChild(r);
                const a = document.createElement("button");
                a.addEventListener("click", (()=>{
                    n.playUIClick(),
                    this.checkpointOrder++
                }
                )),
                r.appendChild(a);
                const s = document.createElement("img");
                s.src = "images/arrow_up.svg",
                a.appendChild(s);
                const o = document.createElement("button");
                o.addEventListener("click", (()=>{
                    n.playUIClick(),
                    this.checkpointOrder--
                }
                )),
                r.appendChild(o);
                const l = document.createElement("img");
                l.src = "images/arrow_down.svg",
                o.appendChild(l),
                Rw(this, Tw, document.createElement("p"), "f"),
                Lw(this, Mw, "f").appendChild(Lw(this, Tw, "f")),
                Lw(this, xw, "m", Aw).call(this)
            }
            dispose() {
                Lw(this, bw, "f").removeChild(Lw(this, Mw, "f")),
                Lw(this, Sw, "f").removeChangeListener(Lw(this, Cw, "f"))
            }
            hide() {
                Lw(this, Mw, "f").classList.add("hidden"),
                Lw(this, Mw, "f").classList.remove("editor-checkpoint-order")
            }
            show() {
                Lw(this, Mw, "f").classList.remove("hidden"),
                Lw(this, Mw, "f").classList.add("editor-checkpoint-order")
            }
            reset() {
                this.checkpointOrder = 0
            }
            get checkpointOrder() {
                return Lw(this, kw, "f")
            }
            set checkpointOrder(e) {
                Rw(this, kw, Math.max(0, Math.min(65535, e)), "f"),
                Lw(this, xw, "m", Aw).call(this)
            }
            setFromExistingCheckpoints(e) {
                this.checkpointOrder = Lw(this, xw, "m", Pw).call(this, e)
            }
        }
        ;
        var Nw = n(697)
          , Uw = {};
        Uw.styleTagTransform = u(),
        Uw.setAttributes = l(),
        Uw.insert = s().bind(null, "head"),
        Uw.domAPI = r(),
        Uw.insertStyleElement = h();
        t()(Nw.Z, Uw);
        Nw.Z && Nw.Z.locals && Nw.Z.locals;
        var Dw, Bw, Ow, zw, Fw, Ww, Hw = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Vw = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Dw = new WeakMap,
        Bw = new WeakMap,
        Ow = new WeakMap,
        zw = new WeakMap,
        Fw = new WeakMap,
        Ww = new WeakMap;
        const Gw = class {
            constructor(e, t, n, i, r) {
                Dw.set(this, void 0),
                Bw.set(this, void 0),
                Ow.set(this, void 0),
                zw.set(this, void 0),
                Fw.set(this, void 0),
                Ww.set(this, void 0),
                Hw(this, Dw, e, "f"),
                Hw(this, Bw, t, "f"),
                Hw(this, Ow, n, "f"),
                Hw(this, zw, document.createElement("div"), "f"),
                Vw(this, zw, "f").className = "editor-height-selector",
                e.appendChild(Vw(this, zw, "f")),
                Vw(this, Ow, "f").addChangeListener(Hw(this, Ww, (e=>{
                    e ? Vw(this, zw, "f").classList.add("touch") : Vw(this, zw, "f").classList.remove("touch")
                }
                ), "f")),
                Hw(this, Fw, document.createElement("p"), "f"),
                Vw(this, zw, "f").appendChild(Vw(this, Fw, "f"));
                const a = document.createElement("div");
                a.className = "buttons",
                Vw(this, zw, "f").appendChild(a);
                const s = document.createElement("button");
                s.addEventListener("click", i),
                a.appendChild(s);
                const o = document.createElement("img");
                o.src = "images/arrow_up.svg",
                s.appendChild(o);
                const l = document.createElement("button");
                l.addEventListener("click", r),
                a.appendChild(l);
                const c = document.createElement("img");
                c.src = "images/arrow_down.svg",
                l.appendChild(c)
            }
            refresh(e) {
                Vw(this, Fw, "f").textContent = Vw(this, Bw, "f").get("Height") + ": " + e
            }
            dispose() {
                Vw(this, Dw, "f").removeChild(Vw(this, zw, "f")),
                Vw(this, Ow, "f").removeChangeListener(Vw(this, Ww, "f"))
            }
        }
        ;
        var jw;
        !function(e) {
            e[e.VehicleAccelerate = 0] = "VehicleAccelerate",
            e[e.VehicleTurnRight = 1] = "VehicleTurnRight",
            e[e.VehicleBrake = 2] = "VehicleBrake",
            e[e.VehicleTurnLeft = 3] = "VehicleTurnLeft",
            e[e.VehicleReset = 4] = "VehicleReset",
            e[e.VehicleCockpitCamera = 5] = "VehicleCockpitCamera",
            e[e.ToggleUI = 6] = "ToggleUI",
            e[e.EditorRotate = 7] = "EditorRotate",
            e[e.EditorHeightModifier = 8] = "EditorHeightModifier",
            e[e.EditorDelete = 9] = "EditorDelete",
            e[e.EditorMoveForwards = 10] = "EditorMoveForwards",
            e[e.EditorMoveRight = 11] = "EditorMoveRight",
            e[e.EditorMoveBackwards = 12] = "EditorMoveBackwards",
            e[e.EditorMoveLeft = 13] = "EditorMoveLeft",
            e[e.EditorRotateLeft = 14] = "EditorRotateLeft",
            e[e.EditorRotateRight = 15] = "EditorRotateRight",
            e[e.EditorMoveDown = 16] = "EditorMoveDown",
            e[e.EditorMoveUp = 17] = "EditorMoveUp",
            e[e.EditorTest = 18] = "EditorTest",
            e[e.EditorPick = 19] = "EditorPick",
            e[e.ToggleFpsCounter = 20] = "ToggleFpsCounter",
            e[e.ToggleSpectatorCamera = 21] = "ToggleSpectatorCamera",
            e[e.SpectatorMoveForwards = 22] = "SpectatorMoveForwards",
            e[e.SpectatorMoveRight = 23] = "SpectatorMoveRight",
            e[e.SpectatorMoveBackwards = 24] = "SpectatorMoveBackwards",
            e[e.SpectatorMoveLeft = 25] = "SpectatorMoveLeft",
            e[e.SpectatorSpeedModifier = 26] = "SpectatorSpeedModifier"
        }(jw || (jw = {}));
        const Xw = jw;
        var qw = n(947)
          , Yw = {};
        Yw.styleTagTransform = u(),
        Yw.setAttributes = l(),
        Yw.insert = s().bind(null, "head"),
        Yw.domAPI = r(),
        Yw.insertStyleElement = h();
        t()(qw.Z, Yw);
        qw.Z && qw.Z.locals && qw.Z.locals;
        var Zw, Kw, Jw, Qw, $w, ey, ty, ny = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, iy = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Zw = new WeakMap,
        Kw = new WeakMap,
        Jw = new WeakMap,
        Qw = new WeakMap,
        $w = new WeakMap,
        ey = new WeakMap,
        ty = new WeakMap;
        const ry = class {
            constructor(e, t, n, i, r, a, s, o, l) {
                Zw.set(this, void 0),
                Kw.set(this, void 0),
                Jw.set(this, void 0),
                Qw.set(this, void 0),
                $w.set(this, void 0),
                ey.set(this, void 0),
                ty.set(this, void 0),
                ny(this, Zw, r, "f"),
                ny(this, Kw, document.getElementById("ui"), "f"),
                ny(this, Jw, document.createElement("div"), "f"),
                iy(this, Jw, "f").className = "track-export",
                iy(this, Kw, "f").appendChild(iy(this, Jw, "f"));
                const c = document.createElement("div");
                c.className = "background",
                iy(this, Jw, "f").appendChild(c);
                const h = document.createElement("div");
                h.className = "box",
                iy(this, Jw, "f").appendChild(h);
                const d = document.createElement("div");
                d.className = "bar",
                h.appendChild(d);
                const u = document.createElement("button");
                u.className = "button",
                u.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                u.append(document.createTextNode(r.get("Back"))),
                u.addEventListener("click", (()=>{
                    a.playUIClick(),
                    t()
                }
                )),
                d.appendChild(u),
                ny(this, $w, document.createElement("button"), "f"),
                iy(this, $w, "f").className = "hidden",
                iy(this, $w, "f").innerHTML = '<img class="button-icon" src="images/copy.svg"> ',
                iy(this, $w, "f").append(document.createTextNode(r.get("Copy"))),
                iy(this, $w, "f").addEventListener("click", (()=>{
                    a.playUIClick();
                    try {
                        navigator.clipboard.writeText(iy(this, Qw, "f").value)
                    } catch (e) {
                        console.error(e)
                    }
                }
                )),
                d.appendChild(iy(this, $w, "f")),
                ny(this, ey, document.createElement("button"), "f"),
                iy(this, ey, "f").className = "hidden",
                iy(this, ey, "f").innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                iy(this, ey, "f").append(document.createTextNode(r.get("Import"))),
                iy(this, ey, "f").addEventListener("click", (()=>{
                    a.playUIClick();
                    const e = ()=>{
                        const e = iy(this, Jw, "f").className;
                        iy(this, Jw, "f").className = "hidden",
                        l.show(r.get("Failed to import track"), r.get("Ok"), (()=>{
                            iy(this, Jw, "f").className = e
                        }
                        ))
                    }
                      , i = iy(this, Qw, "f").value
                      , c = Gv.fromExportString(i, s);
                    if (null == c)
                        e();
                    else {
                        const {trackName: i, trackData: a} = c
                          , h = a.getId(s)
                          , d = a.createThumbnail(s);
                        if (o.checkTrackExists(i)) {
                            const c = iy(this, Jw, "f").className;
                            iy(this, Jw, "f").className = "hidden",
                            l.showConfirm(r.get('The track "{0}" already exists. Do you wish to overwrite it?', [i]), r.get("Cancel"), r.get("Overwrite"), (()=>{
                                iy(this, Jw, "f").className = c
                            }
                            ), (()=>{
                                iy(this, Jw, "f").className = c,
                                o.saveTrack(i, a, s) ? null != n ? n(a, i, h, d) : t() : e()
                            }
                            ))
                        } else
                            o.saveTrack(i, a, s) ? null != n ? n(a, i, h, d) : t() : e()
                    }
                }
                )),
                d.appendChild(iy(this, ey, "f")),
                ny(this, Qw, document.createElement("textarea"), "f"),
                iy(this, Qw, "f").spellcheck = !1,
                h.appendChild(iy(this, Qw, "f")),
                i && (iy(this, Qw, "f").placeholder = iy(this, Zw, "f").get("Paste track data here...")),
                iy(this, Qw, "f").value = e,
                iy(this, Qw, "f").readOnly = !i,
                i ? (iy(this, $w, "f").className = "hidden",
                iy(this, ey, "f").className = "button right") : (iy(this, $w, "f").className = "button right",
                iy(this, ey, "f").className = "hidden"),
                window.addEventListener("keydown", ny(this, ty, (e=>{
                    "Escape" == e.code && (t(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                iy(this, Kw, "f").removeChild(iy(this, Jw, "f")),
                window.removeEventListener("keydown", iy(this, ty, "f"))
            }
        }
        ;
        var ay = n(307)
          , sy = {};
        sy.styleTagTransform = u(),
        sy.setAttributes = l(),
        sy.insert = s().bind(null, "head"),
        sy.domAPI = r(),
        sy.insertStyleElement = h();
        t()(ay.Z, sy);
        ay.Z && ay.Z.locals && ay.Z.locals;
        var oy = n(281)
          , ly = {};
        ly.styleTagTransform = u(),
        ly.setAttributes = l(),
        ly.insert = s().bind(null, "head"),
        ly.domAPI = r(),
        ly.insertStyleElement = h();
        t()(oy.Z, ly);
        oy.Z && oy.Z.locals && oy.Z.locals;
        var cy, hy, dy, uy, py, fy, my, gy, vy, wy = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, yy = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class _y {
            constructor(e, t, n, i=!1) {
                if (cy.set(this, void 0),
                hy.set(this, void 0),
                dy.set(this, void 0),
                uy.set(this, void 0),
                py.set(this, void 0),
                fy.set(this, void 0),
                my.set(this, null),
                gy.set(this, null),
                vy.set(this, null),
                this.record = null,
                wy(this, cy, t, "f"),
                wy(this, hy, document.getElementById("ui"), "f"),
                wy(this, dy, document.createElement("div"), "f"),
                t.getSettingBoolean(uc.TimerPosition) ? yy(this, dy, "f").className = "timer up" : yy(this, dy, "f").className = "timer",
                i)
                    wy(this, uy, null, "f");
                else {
                    const t = document.createElement("div");
                    t.className = "left",
                    yy(this, dy, "f").appendChild(t);
                    const i = document.createElement("h2");
                    i.textContent = null != n ? '"' + n + '"' : e.get("Record"),
                    t.appendChild(i);
                    const r = document.createElement("div");
                    t.appendChild(r),
                    wy(this, uy, document.createElement("p"), "f"),
                    yy(this, uy, "f").className = "small",
                    yy(this, uy, "f").textContent = "- - -",
                    r.appendChild(yy(this, uy, "f"))
                }
                const r = document.createElement("div");
                r.className = "center",
                yy(this, dy, "f").appendChild(r);
                const a = document.createElement("h2");
                a.textContent = e.get("Current"),
                r.appendChild(a);
                const s = document.createElement("div");
                if (r.appendChild(s),
                wy(this, py, document.createElement("p"), "f"),
                yy(this, py, "f").textContent = "- - -",
                s.appendChild(yy(this, py, "f")),
                i)
                    wy(this, fy, null, "f");
                else {
                    const t = document.createElement("div");
                    t.className = "right",
                    yy(this, dy, "f").appendChild(t);
                    const n = document.createElement("h2");
                    n.textContent = e.get("Difference"),
                    t.appendChild(n);
                    const i = document.createElement("div");
                    t.appendChild(i),
                    wy(this, fy, document.createElement("p"), "f"),
                    yy(this, fy, "f").className = "small",
                    yy(this, fy, "f").textContent = "- - -",
                    i.appendChild(yy(this, fy, "f"))
                }
                yy(this, hy, "f").appendChild(yy(this, dy, "f"))
            }
            dispose() {
                yy(this, hy, "f").removeChild(yy(this, dy, "f"))
            }
            setOverridePosition(e) {
                (null != e ? e : yy(this, cy, "f").getSettingBoolean(uc.TimerPosition)) ? yy(this, dy, "f").className = "timer up" : yy(this, dy, "f").className = "timer"
            }
            static formatTimeString(e, t=!1) {
                if (null == e)
                    return "---";
                {
                    const n = Math.abs(e.numberOfFrames)
                      , i = Math.floor(n / 6e4)
                      , r = Math.floor((n - 6e4 * i) / 1e3)
                      , a = n - 6e4 * i - 1e3 * r;
                    let s;
                    return s = t ? e.isNegative() ? "-" : "+" : "",
                    s + i.toString().padStart(2, "0") + ":" + r.toString().padStart(2, "0") + "." + a.toString().padStart(3, "0")
                }
            }
            update(e) {
                const t = e.getTime();
                let n;
                if (n = null != this.record ? t.difference(this.record) : null,
                null != yy(this, uy, "f")) {
                    const e = _y.formatTimeString(this.record, !1);
                    if (e != yy(this, my, "f")) {
                        yy(this, uy, "f").innerHTML = "";
                        for (let t = 0; t < e.length; ++t) {
                            const n = document.createElement("span");
                            n.textContent = e[t],
                            yy(this, uy, "f").appendChild(n)
                        }
                        wy(this, my, e, "f")
                    }
                    null == this.record ? "small center" != yy(this, uy, "f").className && (yy(this, uy, "f").className = "small center") : "small" != yy(this, uy, "f").className && (yy(this, uy, "f").className = "small")
                }
                const i = _y.formatTimeString(t, !1);
                if (i != yy(this, gy, "f")) {
                    yy(this, py, "f").innerHTML = "";
                    for (let e = 0; e < i.length; ++e) {
                        const t = document.createElement("span");
                        t.textContent = i[e],
                        yy(this, py, "f").appendChild(t)
                    }
                    wy(this, gy, i, "f")
                }
                if (null != yy(this, fy, "f")) {
                    const e = _y.formatTimeString(n, !0);
                    if (e != yy(this, vy, "f")) {
                        yy(this, fy, "f").innerHTML = "";
                        for (let t = 0; t < e.length; ++t) {
                            const i = document.createElement("span");
                            0 == t && Number.isFinite(n) && (i.className = "sign"),
                            i.textContent = e[t],
                            yy(this, fy, "f").appendChild(i)
                        }
                        wy(this, vy, e, "f")
                    }
                    null == n ? "small center" != yy(this, fy, "f").className && (yy(this, fy, "f").className = "small center") : n.isNegative() ? "small green" != yy(this, fy, "f").className && (yy(this, fy, "f").className = "small green") : "small red" != yy(this, fy, "f").className && (yy(this, fy, "f").className = "small red")
                }
            }
        }
        cy = new WeakMap,
        hy = new WeakMap,
        dy = new WeakMap,
        uy = new WeakMap,
        py = new WeakMap,
        fy = new WeakMap,
        my = new WeakMap,
        gy = new WeakMap,
        vy = new WeakMap;
        const xy = _y;
        var by, Ey, Sy, My, Ty, ky, Cy, Ay, Py, Ry, Ly, Iy, Ny, Uy, Dy, By, Oy, zy, Fy = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Wy = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Ey = new WeakMap,
        Sy = new WeakMap,
        My = new WeakMap,
        Ty = new WeakMap,
        ky = new WeakMap,
        Cy = new WeakMap,
        Ay = new WeakMap,
        Py = new WeakMap,
        Ry = new WeakMap,
        Ly = new WeakMap,
        Iy = new WeakMap,
        Ny = new WeakMap,
        Uy = new WeakMap,
        Dy = new WeakMap,
        By = new WeakMap,
        by = new WeakSet,
        Oy = function(e, t, n, i, r=null) {
            const a = document.createElement("div");
            a.className = "track",
            Wy(this, Ny, "f").appendChild(a);
            const s = document.createElement("button");
            s.className = "button",
            s.addEventListener("click", (()=>{
                Wy(this, My, "f").playUIClick(),
                Wy(this, Ly, "f").call(this, e, t, n, i)
            }
            )),
            a.appendChild(s);
            const o = document.createElement("div");
            o.className = "track-title",
            s.appendChild(o);
            const l = document.createElement("p");
            l.textContent = t,
            o.appendChild(l),
            s.appendChild(i);
            const c = Wy(this, Ty, "f").getRecordTime(Wy(this, Ay, "f").profileSlot, n)
              , h = document.createElement("div");
            if (h.className = "record",
            h.textContent = null != c ? xy.formatTimeString(c) : Wy(this, Sy, "f").get("No record"),
            s.appendChild(h),
            null != r) {
                const e = document.createElement("button");
                e.className = "delete-button",
                e.innerHTML = '<img src="images/erase.svg">',
                e.addEventListener("click", (()=>{
                    Wy(this, My, "f").playUIClick(),
                    r()
                }
                )),
                a.appendChild(e)
            }
        }
        ,
        zy = function() {
            Wy(this, Ny, "f").innerHTML = "",
            Wy(this, Cy, "f").refreshCustomTracks();
            const e = document.createElement("h2");
            if (e.textContent = Wy(this, Sy, "f").get("Standard tracks"),
            Wy(this, Ny, "f").appendChild(e),
            Wy(this, Cy, "f").forEachStandard(((e,t,n,i)=>{
                Wy(this, by, "m", Oy).call(this, n, t, e, i)
            }
            )),
            !Wy(this, Cy, "f").isCustomTracksEmpty()) {
                const e = document.createElement("h2");
                e.textContent = Wy(this, Sy, "f").get("Custom tracks"),
                Wy(this, Ny, "f").appendChild(e),
                Wy(this, Cy, "f").forEachCustom(((e,t,n,i)=>{
                    Wy(this, by, "m", Oy).call(this, n, t, e, i, (()=>{
                        this.hide(),
                        Wy(this, Py, "f").showConfirm(Wy(this, Sy, "f").get('Are you sure you want to delete "{0}"?', [t]), Wy(this, Sy, "f").get("Cancel"), Wy(this, Sy, "f").get("Delete"), (()=>{
                            this.show()
                        }
                        ), (()=>{
                            Wy(this, ky, "f").deleteTrack(t),
                            this.show()
                        }
                        ))
                    }
                    ))
                }
                ))
            }
        }
        ;
        const Hy = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d) {
                by.add(this),
                Ey.set(this, void 0),
                Sy.set(this, void 0),
                My.set(this, void 0),
                Ty.set(this, void 0),
                ky.set(this, void 0),
                Cy.set(this, void 0),
                Ay.set(this, void 0),
                Py.set(this, void 0),
                Ry.set(this, void 0),
                Ly.set(this, void 0),
                Iy.set(this, void 0),
                Ny.set(this, void 0),
                Uy.set(this, null),
                Dy.set(this, !1),
                By.set(this, void 0),
                Fy(this, Ey, e, "f"),
                Fy(this, Sy, t, "f"),
                Fy(this, My, n, "f"),
                Fy(this, Ty, i, "f"),
                Fy(this, ky, r, "f"),
                Fy(this, Cy, a, "f"),
                Fy(this, Ay, o, "f"),
                Fy(this, Py, l, "f"),
                Fy(this, Ry, c, "f"),
                Fy(this, Ly, d, "f"),
                Fy(this, Iy, document.createElement("div"), "f"),
                Wy(this, Iy, "f").className = "hidden",
                e.appendChild(Wy(this, Iy, "f"));
                const u = document.createElement("div");
                u.className = "bar",
                Wy(this, Iy, "f").appendChild(u),
                Fy(this, Ny, document.createElement("div"), "f"),
                Wy(this, Ny, "f").className = "tracks-container",
                Wy(this, Iy, "f").appendChild(Wy(this, Ny, "f"));
                const p = document.createElement("button");
                p.className = "button",
                c ? (p.innerHTML = '<img class="button-icon" src="images/erase.svg"> ',
                p.append(document.createTextNode(Wy(this, Sy, "f").get("Cancel")))) : (p.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                p.append(document.createTextNode(Wy(this, Sy, "f").get("Back")))),
                p.addEventListener("click", (()=>{
                    Wy(this, My, "f").playUIClick(),
                    h()
                }
                )),
                u.appendChild(p);
                const f = document.createElement("button");
                f.className = "button right",
                f.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                f.append(document.createTextNode(Wy(this, Sy, "f").get("Import"))),
                f.addEventListener("click", (()=>{
                    Wy(this, My, "f").playUIClick(),
                    this.hide(),
                    Fy(this, Uy, new ry("",(()=>{
                        var e;
                        this.show(),
                        null === (e = Wy(this, Uy, "f")) || void 0 === e || e.dispose(),
                        Fy(this, Uy, null, "f")
                    }
                    ),((e,t,n,i)=>{
                        var r;
                        null === (r = Wy(this, Uy, "f")) || void 0 === r || r.dispose(),
                        Fy(this, Uy, null, "f"),
                        Wy(this, Ly, "f").call(this, e, t, n, i)
                    }
                    ),!0,t,n,s,r,l), "f")
                }
                )),
                u.appendChild(f),
                window.addEventListener("keydown", Fy(this, By, (e=>{
                    Wy(this, Dy, "f") && "Escape" == e.code && (h(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                Wy(this, Ey, "f").removeChild(Wy(this, Iy, "f")),
                window.removeEventListener("keydown", Wy(this, By, "f"))
            }
            hide() {
                Wy(this, Iy, "f").className = "hidden",
                Fy(this, Dy, !1, "f")
            }
            show() {
                Wy(this, Ry, "f") ? Wy(this, Iy, "f").className = "track-selection editor-track-selection" : Wy(this, Iy, "f").className = "track-selection",
                Fy(this, Dy, !0, "f"),
                Wy(this, by, "m", zy).call(this)
            }
            get isOpen() {
                return Wy(this, Dy, "f")
            }
        }
        ;
        var Vy, Gy = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, jy = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class Xy {
            constructor(e) {
                Vy.set(this, void 0);
                const t = [];
                e.forEach((([e,n,i])=>{
                    t.push([e, n, i])
                }
                )),
                Gy(this, Vy, t, "f")
            }
            rotated(e) {
                const t = [];
                return jy(this, Vy, "f").forEach((([n,i,r])=>{
                    switch (e) {
                    case 0:
                        t.push([n, i, r]);
                        break;
                    case 1:
                        t.push([r, i, -n]);
                        break;
                    case 2:
                        t.push([-n, i, -r]);
                        break;
                    case 3:
                        t.push([-r, i, n]);
                        break;
                    default:
                        throw "Invalid rotation"
                    }
                }
                )),
                new Xy(t)
            }
            forEach(e) {
                jy(this, Vy, "f").forEach((([t,n,i])=>{
                    e(t, n, i)
                }
                ))
            }
        }
        Vy = new WeakMap;
        const qy = Xy;
        var Yy = n(353)
          , Zy = {};
        Zy.styleTagTransform = u(),
        Zy.setAttributes = l(),
        Zy.insert = s().bind(null, "head"),
        Zy.domAPI = r(),
        Zy.insertStyleElement = h();
        t()(Yy.Z, Zy);
        Yy.Z && Yy.Z.locals && Yy.Z.locals;
        var Ky, Jy, Qy, $y, e_, t_, n_ = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, i_ = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Jy = new WeakMap,
        Qy = new WeakMap,
        $y = new WeakMap,
        e_ = new WeakMap,
        Ky = new WeakSet,
        t_ = function() {
            !i_(this, e_, "f") && i_(this, $y, "f") ? i_(this, Qy, "f").className = "editor-touch-controls" : i_(this, Qy, "f").className = "hidden"
        }
        ;
        const r_ = class {
            constructor(e, t, n) {
                Ky.add(this),
                Jy.set(this, void 0),
                Qy.set(this, void 0),
                $y.set(this, !1),
                e_.set(this, !1),
                n_(this, Jy, e, "f"),
                n_(this, Qy, document.createElement("div"), "f"),
                i_(this, Qy, "f").className = "hidden",
                i_(this, Jy, "f").appendChild(i_(this, Qy, "f"));
                const i = document.createElement("button");
                i.className = "rotate",
                i.innerHTML = '<img src="images/rotate.svg">',
                i.addEventListener("touchstart", (()=>{
                    i.classList.add("active")
                }
                )),
                i.addEventListener("touchend", (()=>{
                    i.classList.remove("active")
                }
                )),
                i.addEventListener("click", (()=>{
                    t.playUIClick(),
                    n()
                }
                )),
                i_(this, Qy, "f").appendChild(i)
            }
            setEnabled(e) {
                n_(this, $y, e, "f"),
                i_(this, Ky, "m", t_).call(this)
            }
            hide() {
                n_(this, e_, !0, "f"),
                i_(this, Ky, "m", t_).call(this)
            }
            show() {
                n_(this, e_, !1, "f"),
                i_(this, Ky, "m", t_).call(this)
            }
            dispose() {
                i_(this, Jy, "f").removeChild(i_(this, Qy, "f"))
            }
        }
        ;
        var a_, s_, o_, l_, c_, h_, d_, u_, p_, f_, m_, g_, v_, w_, y_, __, x_, b_, E_, S_, M_, T_, k_, C_, A_, P_, R_, L_, I_, N_, U_, D_, B_, O_, z_, F_, W_, H_, V_, G_, j_, X_, q_, Y_, Z_, K_, J_, Q_, $_, ex, tx, nx, ix, rx, ax, sx, ox, lx, cx, hx, dx, ux, px, fx, mx, gx, vx, wx, yx, _x, xx, bx, Ex, Sx, Mx, Tx, kx, Cx, Ax, Px, Rx, Lx, Ix, Nx, Ux, Dx, Bx, Ox = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, zx = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        s_ = new WeakMap,
        o_ = new WeakMap,
        l_ = new WeakMap,
        c_ = new WeakMap,
        h_ = new WeakMap,
        d_ = new WeakMap,
        u_ = new WeakMap,
        p_ = new WeakMap,
        f_ = new WeakMap,
        m_ = new WeakMap,
        g_ = new WeakMap,
        v_ = new WeakMap,
        w_ = new WeakMap,
        y_ = new WeakMap,
        __ = new WeakMap,
        x_ = new WeakMap,
        b_ = new WeakMap,
        E_ = new WeakMap,
        S_ = new WeakMap,
        M_ = new WeakMap,
        T_ = new WeakMap,
        k_ = new WeakMap,
        C_ = new WeakMap,
        A_ = new WeakMap,
        P_ = new WeakMap,
        R_ = new WeakMap,
        L_ = new WeakMap,
        I_ = new WeakMap,
        N_ = new WeakMap,
        U_ = new WeakMap,
        D_ = new WeakMap,
        B_ = new WeakMap,
        O_ = new WeakMap,
        z_ = new WeakMap,
        F_ = new WeakMap,
        W_ = new WeakMap,
        H_ = new WeakMap,
        V_ = new WeakMap,
        G_ = new WeakMap,
        j_ = new WeakMap,
        X_ = new WeakMap,
        q_ = new WeakMap,
        Y_ = new WeakMap,
        Z_ = new WeakMap,
        K_ = new WeakMap,
        J_ = new WeakMap,
        Q_ = new WeakMap,
        $_ = new WeakMap,
        ex = new WeakMap,
        tx = new WeakMap,
        nx = new WeakMap,
        ix = new WeakMap,
        rx = new WeakMap,
        ax = new WeakMap,
        sx = new WeakMap,
        ox = new WeakMap,
        lx = new WeakMap,
        cx = new WeakMap,
        hx = new WeakMap,
        dx = new WeakMap,
        ux = new WeakMap,
        px = new WeakMap,
        fx = new WeakMap,
        mx = new WeakMap,
        gx = new WeakMap,
        vx = new WeakMap,
        Tx = new WeakMap,
        kx = new WeakMap,
        Cx = new WeakMap,
        a_ = new WeakSet,
        wx = function(e) {
            const t = document.getElementById("ui");
            Ox(this, x_, document.createElement("div"), "f"),
            zx(this, x_, "f").className = "hidden",
            t.appendChild(zx(this, x_, "f")),
            Ox(this, b_, document.createElement("div"), "f"),
            zx(this, b_, "f").className = "top",
            zx(this, x_, "f").appendChild(zx(this, b_, "f"));
            const n = document.createElement("div");
            n.className = "button-bar",
            zx(this, b_, "f").appendChild(n);
            const i = document.createElement("button");
            i.className = "button",
            i.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
            i.append(document.createTextNode(zx(this, l_, "f").get("Exit"))),
            i.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick(),
                zx(this, a_, "m", yx).call(this, e)
            }
            )),
            n.appendChild(i);
            const r = document.createElement("button");
            r.className = "button",
            r.innerHTML = '<img class="button-icon" src="images/test.svg"> ',
            r.append(zx(this, l_, "f").get("Test")),
            r.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick(),
                zx(this, a_, "m", _x).call(this)
            }
            )),
            n.appendChild(r);
            const a = document.createElement("button");
            a.className = "button",
            a.innerHTML = '<img class="button-icon" src="images/random.svg"> ',
            a.append(zx(this, l_, "f").get("Generate")),
            a.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick();
                const e = ()=>{
                    var e;
                    !function(e) {
                        let t;
                        e.clear();
                        do {
                            let n = 0
                              , i = 0
                              , r = 0
                              , a = Math.floor(4 * Math.random());
                            Math.random() < .5 && (i = Math.floor(20 * Math.random()));
                            const s = new Map;
                            function o() {
                                switch (a) {
                                case 0:
                                    --r;
                                    break;
                                case 1:
                                    --n;
                                    break;
                                case 2:
                                    ++r;
                                    break;
                                case 3:
                                    ++n
                                }
                            }
                            function l() {
                                switch (a) {
                                case 0:
                                    ++r;
                                    break;
                                case 1:
                                    ++n;
                                    break;
                                case 2:
                                    --r;
                                    break;
                                case 3:
                                    --n
                                }
                            }
                            function c() {
                                switch ((a + 1) % 4) {
                                case 0:
                                    --r;
                                    break;
                                case 1:
                                    --n;
                                    break;
                                case 2:
                                    ++r;
                                    break;
                                case 3:
                                    ++n
                                }
                            }
                            function h() {
                                switch (((a - 1) % 4 + 4) % 4) {
                                case 0:
                                    --r;
                                    break;
                                case 1:
                                    --n;
                                    break;
                                case 2:
                                    ++r;
                                    break;
                                case 3:
                                    ++n
                                }
                            }
                            function d(e, n, i, r=null) {
                                const a = e + "|" + n + "|" + i;
                                s.has(a) && (t = !0),
                                null != r && (r.x = e,
                                r.y = n,
                                r.z = i,
                                "direction"in r && (r.direction = (r.direction % 4 + 4) % 4)),
                                s.set(a, r)
                            }
                            function u(e, t, n) {
                                return !!s.has(e + "|" + t + "|" + n)
                            }
                            function p() {
                                let e = !1;
                                for (let t = 0; t < i; ++t)
                                    if (u(n, t, r)) {
                                        e = !0;
                                        break
                                    }
                                if (!e)
                                    for (let e = 0; e < i; ++e) {
                                        let t;
                                        t = 0 == e && e == i - 1 ? 22 : 0 == e ? 21 : e == i - 1 ? 19 : 20,
                                        d(n, e, r, {
                                            type: t,
                                            direction: 0
                                        })
                                    }
                            }
                            function f(e) {
                                e > 0 ? (--e,
                                Math.random() < .2 ? S(e) : Math.random() < .6 ? g(e) : Math.random() < .5 ? y(e, i < 2 || Math.random() < .5) : Math.random() < .5 ? v(e) : w(e)) : b()
                            }
                            function m(e) {
                                e > 0 ? (--e,
                                Math.random() < .1 ? M(e) : Math.random() < .6 ? T(e) : Math.random() < .5 ? A(e, i < 2 || Math.random() < .5) : Math.random() < .5 ? k(e) : C(e)) : M(e)
                            }
                            function g(e) {
                                d(n, i, r, {
                                    type: 0,
                                    direction: a
                                }),
                                p(),
                                o(),
                                f(e)
                            }
                            function v(e) {
                                d(n, i, r, {
                                    type: 1,
                                    direction: a - 1
                                }),
                                p(),
                                a = (a + 1) % 4,
                                o(),
                                e > 0 ? (--e,
                                Math.random() < .4 ? g(e) : Math.random() < .5 ? v(e) : w(e)) : b()
                            }
                            function w(e) {
                                d(n, i, r, {
                                    type: 1,
                                    direction: a
                                }),
                                p(),
                                a = ((a - 1) % 4 + 4) % 4,
                                o(),
                                e > 0 ? (--e,
                                Math.random() < .4 ? g(e) : Math.random() < .5 ? v(e) : w(e)) : b()
                            }
                            function y(e, t) {
                                let s;
                                s = t ? 2 : 3,
                                t || --i,
                                d(n, i + 1, r),
                                d(n, i, r, {
                                    type: s,
                                    direction: a
                                }),
                                o(),
                                t && ++i,
                                e > 0 ? (--e,
                                Math.random() < .4 || i <= 3 ? _(e, t) : x(e, t)) : _(e, t)
                            }
                            function _(e, t) {
                                let s;
                                t || --i,
                                d(n, i + 1, r),
                                s = t ? 3 : 2,
                                d(n, i, r, {
                                    type: s,
                                    direction: a + 2
                                }),
                                o(),
                                t && ++i,
                                e > 0 ? f(--e) : b()
                            }
                            function x(e, t) {
                                let s;
                                t || (i -= 2),
                                d(n, i + 1, r),
                                d(n, i + 2, r),
                                s = t ? a : a + 2,
                                d(n, i, r, {
                                    type: 4,
                                    direction: s
                                }),
                                o(),
                                t && (i += 2),
                                e > 0 ? (--e,
                                Math.random() < .4 || i <= 3 ? _(e, t) : x(e, t)) : _(e, t)
                            }
                            function b() {
                                d(n, i, r, {
                                    type: 6,
                                    direction: a
                                })
                            }
                            function E(e) {
                                d(n, i, r, {
                                    type: 5,
                                    direction: a
                                }),
                                p(),
                                o(),
                                f(e)
                            }
                            function S(e) {
                                Math.random() < .5 ? (d(n, i, r, {
                                    type: 8,
                                    direction: a
                                }),
                                p(),
                                h(),
                                d(n, i, r, {
                                    type: 12,
                                    direction: a + 2
                                }),
                                p(),
                                o()) : (d(n, i, r, {
                                    type: 9,
                                    direction: a
                                }),
                                p(),
                                c(),
                                d(n, i, r, {
                                    type: 12,
                                    direction: a + 1
                                }),
                                p(),
                                o(),
                                h()),
                                m(e)
                            }
                            function M(e) {
                                Math.random() < .5 ? (d(n, i, r, {
                                    type: 12,
                                    direction: a + 3
                                }),
                                p(),
                                c(),
                                d(n, i, r, {
                                    type: 9,
                                    direction: a + 2
                                }),
                                p(),
                                o()) : (d(n, i, r, {
                                    type: 8,
                                    direction: a + 2
                                }),
                                p(),
                                c(),
                                d(n, i, r, {
                                    type: 12,
                                    direction: a
                                }),
                                p(),
                                o(),
                                h()),
                                f(e)
                            }
                            function T(e) {
                                d(n, i, r, {
                                    type: 10,
                                    direction: a
                                }),
                                p(),
                                c(),
                                d(n, i, r, {
                                    type: 10,
                                    direction: a + 2
                                }),
                                p(),
                                h(),
                                o(),
                                m(e)
                            }
                            function k(e) {
                                d(n, i, r, {
                                    type: 10,
                                    direction: a
                                }),
                                p(),
                                o(),
                                d(n, i, r, {
                                    type: 12,
                                    direction: a + 3
                                }),
                                p(),
                                c(),
                                d(n, i, r, {
                                    type: 10,
                                    direction: a + 1
                                }),
                                p(),
                                l(),
                                d(n, i, r, {
                                    type: 11,
                                    direction: a + 3
                                }),
                                p(),
                                o(),
                                a = (a + 1) % 4,
                                o(),
                                m(e)
                            }
                            function C(e) {
                                d(n, i, r, {
                                    type: 11,
                                    direction: a
                                }),
                                p(),
                                c(),
                                d(n, i, r, {
                                    type: 10,
                                    direction: a + 2
                                }),
                                p(),
                                o(),
                                d(n, i, r, {
                                    type: 12,
                                    direction: a
                                }),
                                p(),
                                h(),
                                d(n, i, r, {
                                    type: 10,
                                    direction: a + 1
                                }),
                                p(),
                                l(),
                                a = ((a - 1) % 4 + 4) % 4,
                                o(),
                                m(e)
                            }
                            function A(e, t) {
                                let s, l;
                                t ? (s = 13,
                                l = 14) : (s = 15,
                                l = 16),
                                t || --i,
                                c(),
                                d(n, i + 1, r),
                                d(n, i, r, {
                                    type: s,
                                    direction: a
                                }),
                                h(),
                                d(n, i + 1, r),
                                d(n, i, r, {
                                    type: l,
                                    direction: a
                                }),
                                o(),
                                t && ++i,
                                e > 0 ? (--e,
                                Math.random() < .4 || i <= 3 ? P(e, t) : R(e, t)) : P(e, t)
                            }
                            function P(e, t) {
                                let s, l;
                                t || --i,
                                t ? (s = 16,
                                l = 15) : (s = 14,
                                l = 13),
                                c(),
                                d(n, i + 1, r),
                                d(n, i, r, {
                                    type: s,
                                    direction: a + 2
                                }),
                                h(),
                                d(n, i + 1, r),
                                d(n, i, r, {
                                    type: l,
                                    direction: a + 2
                                }),
                                o(),
                                t && ++i,
                                m(e)
                            }
                            function R(e, t) {
                                t || (i -= 2),
                                t ? (c(),
                                d(n, i + 1, r),
                                d(n, i + 2, r),
                                d(n, i, r, {
                                    type: 17,
                                    direction: a
                                }),
                                h(),
                                d(n, i + 1, r),
                                d(n, i + 2, r),
                                d(n, i, r, {
                                    type: 18,
                                    direction: a
                                })) : (c(),
                                d(n, i + 1, r),
                                d(n, i + 2, r),
                                d(n, i, r, {
                                    type: 18,
                                    direction: a + 2
                                }),
                                h(),
                                d(n, i + 1, r),
                                d(n, i + 2, r),
                                d(n, i, r, {
                                    type: 17,
                                    direction: a + 2
                                })),
                                o(),
                                t && (i += 2),
                                e > 0 ? (--e,
                                Math.random() < .4 || i <= 3 ? P(e, t) : R(e, t)) : P(e, t)
                            }
                            t = !1,
                            E(50),
                            t || s.forEach((t=>{
                                null != t && e.setPart(t.x, t.y, t.z, t.type, t.direction, null)
                            }
                            ))
                        } while (t)
                    }(zx(this, d_, "f")),
                    zx(this, d_, "f").generateMeshes(),
                    null === (e = zx(this, px, "f")) || void 0 === e || e.refresh(zx(this, d_, "f")),
                    zx(this, A_, "f").setFromExistingCheckpoints(zx(this, d_, "f")),
                    Ox(this, $_, !0, "f")
                }
                ;
                zx(this, $_, "f") ? e() : (zx(this, x_, "f").inert = !0,
                zx(this, v_, "f").showConfirm(zx(this, l_, "f").get("Are you sure you want to generate a new track?\n\nYour current track will be lost!"), zx(this, l_, "f").get("Cancel"), zx(this, l_, "f").get("Confirm"), (()=>{
                    zx(this, x_, "f").inert = !1
                }
                ), (()=>{
                    e(),
                    zx(this, x_, "f").inert = !1
                }
                )))
            }
            )),
            n.appendChild(a),
            Ox(this, P_, new Hy(t,zx(this, l_, "f"),zx(this, s_, "f"),zx(this, p_, "f"),zx(this, f_, "f"),zx(this, m_, "f"),zx(this, u_, "f"),zx(this, g_, "f"),zx(this, v_, "f"),!0,(()=>{
                zx(this, x_, "f").className = "editor",
                zx(this, P_, "f").hide()
            }
            ),((e,t)=>{
                var n;
                zx(this, d_, "f").loadTrackData(e, !1),
                zx(this, d_, "f").generateMeshes(),
                null === (n = zx(this, px, "f")) || void 0 === n || n.refresh(zx(this, d_, "f")),
                zx(this, A_, "f").setFromExistingCheckpoints(zx(this, d_, "f")),
                Ox(this, $_, !0, "f"),
                zx(this, E_, "f").value = t,
                this.resetView(),
                zx(this, x_, "f").className = "editor",
                zx(this, P_, "f").hide()
            }
            )), "f"),
            Ox(this, L_, new r_(zx(this, x_, "f"),zx(this, s_, "f"),(()=>{
                Ox(this, hx, (zx(this, hx, "f") + 1) % 4, "f")
            }
            )), "f"),
            zx(this, L_, "f").setEnabled(zx(this, w_, "f").touchEnabled);
            const s = document.createElement("button");
            s.className = "button",
            s.innerHTML = '<img class="button-icon" src="images/load.svg"> ',
            s.append(document.createTextNode(zx(this, l_, "f").get("Load"))),
            s.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick(),
                zx(this, $_, "f") ? (zx(this, P_, "f").show(),
                zx(this, x_, "f").className = "hidden") : (zx(this, x_, "f").inert = !0,
                zx(this, v_, "f").showConfirm(zx(this, l_, "f").get("Are you sure you want to load a new track?\n\nYour current track will be lost!"), zx(this, l_, "f").get("Cancel"), zx(this, l_, "f").get("Confirm"), (()=>{
                    zx(this, x_, "f").inert = !1
                }
                ), (()=>{
                    zx(this, P_, "f").show(),
                    zx(this, x_, "f").className = "hidden",
                    zx(this, x_, "f").inert = !1
                }
                )))
            }
            )),
            n.appendChild(s);
            const o = document.createElement("button");
            o.className = "button",
            o.innerHTML = '<img class="button-icon" src="images/save.svg"> ',
            o.append(document.createTextNode(zx(this, l_, "f").get("Save"))),
            o.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick();
                const e = this.getTrackName();
                if (null == e)
                    zx(this, a_, "m", bx).call(this, zx(this, l_, "f").get("Failed to save - Track name is needed!"), !1);
                else {
                    const t = ()=>{
                        zx(this, f_, "f").saveTrack(e, zx(this, d_, "f").getTrackData(), zx(this, u_, "f")) ? (zx(this, a_, "m", bx).call(this, zx(this, l_, "f").get("Track saved!"), !0),
                        Ox(this, $_, !0, "f")) : zx(this, a_, "m", bx).call(this, zx(this, l_, "f").get("Failed to save!"), !1)
                    }
                      , n = zx(this, f_, "f").checkTrackExists(e);
                    null == n ? zx(this, a_, "m", bx).call(this, zx(this, l_, "f").get("Failed to save!"), !1) : 0 == n ? t() : (zx(this, x_, "f").inert = !0,
                    zx(this, v_, "f").showConfirm(zx(this, l_, "f").get('Are you sure you want to overwrite "{0}"?', [e]), zx(this, l_, "f").get("Cancel"), zx(this, l_, "f").get("Confirm"), (()=>{
                        zx(this, x_, "f").inert = !1
                    }
                    ), (()=>{
                        t(),
                        zx(this, x_, "f").inert = !1
                    }
                    )))
                }
            }
            )),
            n.appendChild(o);
            const l = document.createElement("button");
            l.className = "button",
            l.innerHTML = '<img class="button-icon" src="images/export.svg"> ',
            l.append(document.createTextNode(zx(this, l_, "f").get("Export"))),
            l.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick();
                const e = this.getTrackName();
                if (null == e)
                    zx(this, a_, "m", bx).call(this, zx(this, l_, "f").get("Failed to export - Track name is needed!"), !1);
                else {
                    const t = zx(this, d_, "f").getTrackData().toExportString(e, zx(this, u_, "f"));
                    zx(this, x_, "f").className = "hidden",
                    Ox(this, R_, new ry(t,(()=>{
                        var e;
                        null === (e = zx(this, R_, "f")) || void 0 === e || e.dispose(),
                        Ox(this, R_, null, "f"),
                        zx(this, x_, "f").className = "editor"
                    }
                    ),null,!1,zx(this, l_, "f"),zx(this, s_, "f"),zx(this, u_, "f"),zx(this, f_, "f"),zx(this, v_, "f")), "f")
                }
            }
            )),
            n.appendChild(l);
            const c = document.createElement("div");
            c.className = "trackname-input",
            c.textContent = zx(this, l_, "f").get("Track name") + ": ",
            zx(this, b_, "f").appendChild(c),
            Ox(this, E_, document.createElement("input"), "f"),
            zx(this, E_, "f").type = "text",
            zx(this, E_, "f").maxLength = 64,
            zx(this, E_, "f").spellcheck = !1,
            c.appendChild(zx(this, E_, "f")),
            Ox(this, S_, document.createElement("div"), "f"),
            zx(this, S_, "f").className = "message-box",
            zx(this, x_, "f").appendChild(zx(this, S_, "f"));
            const h = document.createElement("side");
            h.className = "side",
            zx(this, x_, "f").appendChild(h),
            Ox(this, A_, new Iw(h,zx(this, l_, "f"),zx(this, s_, "f"),zx(this, w_, "f")), "f"),
            Ox(this, T_, document.createElement("div"), "f"),
            zx(this, T_, "f").className = "side-panel",
            h.appendChild(zx(this, T_, "f")),
            Ox(this, k_, document.createElement("div"), "f"),
            zx(this, k_, "f").className = "category-panel",
            zx(this, T_, "f").appendChild(zx(this, k_, "f"));
            const d = new pi(cw.partWidth,cw.partHeight,cw.partLength);
            d.translate(0, 2.5, 0);
            const u = new di(d,zx(this, ix, "f"))
              , p = document.createElement("button");
            p.addEventListener("click", (()=>{
                zx(this, s_, "f").playUIClick(),
                zx(this, a_, "m", Sx).call(this, null)
            }
            )),
            zx(this, k_, "f").appendChild(p);
            const f = document.createElement("img");
            f.src = "images/erase.svg",
            p.appendChild(f),
            zx(this, nx, "f").add(u),
            zx(this, fx, "f").push({
                id: null,
                mesh: u,
                button: p,
                tiles: new qy([[0, 0, 0]]),
                isCheckpoint: !1,
                category: null
            }),
            Ox(this, C_, new Gw(zx(this, x_, "f"),zx(this, l_, "f"),zx(this, w_, "f"),(()=>{
                zx(this, s_, "f").playUIClick(),
                Ox(this, a_, zx(this, a_, "a", Px) + 1, "a", Rx)
            }
            ),(()=>{
                zx(this, s_, "f").playUIClick(),
                Ox(this, a_, Math.max(0, zx(this, a_, "a", Px) - 1), "a", Rx)
            }
            )), "f"),
            zx(this, C_, "f").refresh(zx(this, a_, "a", Px))
        }
        ,
        yx = function(e) {
            const t = ()=>{
                zx(this, h_, "f").trigger((()=>{
                    Ox(this, $_, !0, "f"),
                    zx(this, E_, "f").value = "",
                    e(),
                    zx(this, x_, "f").inert = !1
                }
                ))
            }
            ;
            zx(this, $_, "f") ? t() : (zx(this, x_, "f").inert = !0,
            zx(this, v_, "f").showConfirm(zx(this, l_, "f").get("Are you sure you want to exit the editor?") + "\n\n" + zx(this, l_, "f").get("All unsaved data will be lost!"), zx(this, l_, "f").get("Cancel"), zx(this, l_, "f").get("Confirm"), (()=>{
                zx(this, x_, "f").inert = !1
            }
            ), (()=>{
                t()
            }
            )))
        }
        ,
        _x = function() {
            if (null != zx(this, d_, "f").getStartTransform()) {
                if (null == zx(this, y_, "f"))
                    throw "Test callback is null";
                zx(this, y_, "f").call(this)
            } else
                zx(this, a_, "m", bx).call(this, zx(this, l_, "f").get("Starting point is missing!"), !1)
        }
        ,
        xx = function() {
            if (null != zx(this, cx, "f")) {
                const e = zx(this, d_, "f").getPartAt(zx(this, cx, "f").x, zx(this, cx, "f").y, zx(this, cx, "f").z);
                if (null != e) {
                    const t = zx(this, fx, "f").findIndex((t=>t.id == e.id));
                    t >= 0 && (zx(this, a_, "m", Mx).call(this, t),
                    Ox(this, hx, e.rotation, "f"))
                }
            }
        }
        ,
        bx = function(e, t) {
            null != zx(this, M_, "f") && (clearTimeout(zx(this, M_, "f")),
            Ox(this, M_, null, "f")),
            t ? zx(this, S_, "f").classList.add("green") : zx(this, S_, "f").classList.remove("green"),
            zx(this, S_, "f").classList.remove("show"),
            zx(this, S_, "f").classList.remove("hide"),
            Ox(this, M_, window.setTimeout((()=>{
                zx(this, S_, "f").textContent = e,
                zx(this, S_, "f").classList.add("show"),
                Ox(this, M_, window.setTimeout((()=>{
                    zx(this, S_, "f").classList.remove("show"),
                    zx(this, S_, "f").classList.add("hide")
                }
                ), 3e3), "f")
            }
            ), 0), "f")
        }
        ,
        Ex = function() {
            var e;
            const t = zx(this, u_, "f").getAllParts();
            for (let n = 0; n < t.length; ++n) {
                const i = t[n];
                if (null == i.mesh)
                    throw "Mesh is not loaded";
                const r = i.mesh.clone()
                  , a = zx(this, a_, "m", Ax).call(this, r);
                let s = null === (e = zx(this, gx, "f").find((e=>e.category == i.category))) || void 0 === e ? void 0 : e.partPanel;
                if (null == s) {
                    s = document.createElement("div"),
                    s.className = "part-panel hidden",
                    zx(this, T_, "f").prepend(s);
                    const e = document.createElement("button");
                    e.addEventListener("click", (()=>{
                        zx(this, a_, "m", Sx).call(this, i.category),
                        zx(this, s_, "f").playUIClick()
                    }
                    )),
                    zx(this, k_, "f").appendChild(e);
                    const t = document.createElement("img");
                    t.src = a,
                    e.appendChild(t),
                    zx(this, gx, "f").push({
                        category: i.category,
                        button: e,
                        partPanel: s,
                        selectedIndex: null
                    })
                }
                const o = document.createElement("button");
                o.addEventListener("click", (()=>{
                    zx(this, s_, "f").playUIClick(),
                    zx(this, a_, "m", Mx).call(this, 1 + n)
                }
                )),
                s.appendChild(o);
                const l = document.createElement("img");
                l.src = a,
                o.appendChild(l),
                r.material = zx(this, ix, "f"),
                zx(this, nx, "f").add(r),
                zx(this, fx, "f").push({
                    id: i.id,
                    mesh: r,
                    button: o,
                    tiles: i.tiles,
                    isCheckpoint: null != i.detector && i.detector.type == Iv.Checkpoint,
                    category: i.category
                })
            }
            zx(this, a_, "m", Mx).call(this, 1)
        }
        ,
        Sx = function(e) {
            var t;
            if (zx(this, vx, "f") != e)
                if (Ox(this, vx, e, "f"),
                zx(this, gx, "f").forEach((t=>{
                    t.category == e ? (t.button.classList.add("selected"),
                    t.partPanel.classList.remove("hidden")) : (t.button.classList.remove("selected"),
                    t.partPanel.classList.add("hidden"))
                }
                )),
                null == e)
                    zx(this, a_, "m", Mx).call(this, 0);
                else {
                    let n = null === (t = zx(this, gx, "f").find((t=>t.category == e))) || void 0 === t ? void 0 : t.selectedIndex;
                    if (null == n && (n = zx(this, fx, "f").findIndex((t=>t.category == e)),
                    n < 0))
                        throw "Empty category";
                    zx(this, a_, "m", Mx).call(this, n)
                }
        }
        ,
        Mx = function(e) {
            zx(this, fx, "f").forEach((({button: t},n)=>{
                t.className = n == e ? "selected" : ""
            }
            )),
            Ox(this, mx, e, "f");
            const t = zx(this, gx, "f").find((e=>e.category == zx(this, vx, "f")));
            null != t && (t.selectedIndex = e);
            const n = zx(this, fx, "f")[e];
            null != n && n.isCheckpoint ? zx(this, A_, "f").show() : zx(this, A_, "f").hide()
        }
        ,
        Ax = function(e) {
            if (null == zx(this, Tx, "f") || null == zx(this, kx, "f") || null == zx(this, Cx, "f")) {
                const e = document.createElement("canvas");
                e.width = 128,
                e.height = 128,
                Ox(this, Tx, new fs({
                    canvas: e,
                    alpha: !0,
                    preserveDrawingBuffer: !0,
                    antialias: !0
                }), "f"),
                zx(this, Tx, "f").outputColorSpace = ce,
                Ox(this, Cx, new gs, "f"),
                Ox(this, kx, new ji(-1,1,1,-1,.1,1e4), "f"),
                zx(this, kx, "f").position.set(1e3, 1e3, 1e3),
                zx(this, kx, "f").lookAt(0, 0, 0),
                zx(this, Cx, "f").add(zx(this, kx, "f"));
                const t = new Kl(16777215,4.7);
                t.position.set(8, 10, 10),
                zx(this, Cx, "f").add(t)
            }
            e.geometry.computeBoundingSphere();
            const t = (new Rt).copy(e.geometry.boundingSphere);
            return zx(this, kx, "f").zoom = 1 / t.radius * .9,
            zx(this, kx, "f").position.copy(t.center),
            zx(this, kx, "f").position.addScalar(1e3),
            zx(this, kx, "f").updateProjectionMatrix(),
            zx(this, Tx, "f").clear(),
            zx(this, Cx, "f").add(e),
            zx(this, Tx, "f").render(zx(this, Cx, "f"), zx(this, kx, "f")),
            zx(this, Cx, "f").remove(e),
            zx(this, Tx, "f").domElement.toDataURL()
        }
        ,
        Px = function() {
            return Math.floor(zx(this, tx, "f").position.y / 5)
        }
        ,
        Rx = function(e) {
            const t = zx(this, a_, "a", Px);
            zx(this, tx, "f").position.y = 5 * e,
            zx(this, G_, "f").position.y += 5 * (e - t),
            zx(this, j_, "f").target.y = 5 * e,
            zx(this, C_, "f").refresh(e),
            zx(this, tx, "f").updateWorldMatrix(!0, !0),
            zx(this, j_, "f").update()
        }
        ,
        Lx = function() {
            const e = performance.now();
            if (e - zx(this, o_, "f") > 35) {
                const t = zx(this, s_, "f").getBuffer("editor_edit");
                if (null != t && null != zx(this, s_, "f").context && null != zx(this, s_, "f").destinationSfx) {
                    const e = zx(this, s_, "f").context.createBufferSource();
                    e.buffer = t,
                    e.playbackRate.value = .7;
                    const n = zx(this, s_, "f").context.createGain();
                    n.gain.value = .05,
                    e.connect(n),
                    n.connect(zx(this, s_, "f").destinationSfx),
                    e.start(0)
                }
                Ox(this, o_, e, "f")
            }
        }
        ,
        Ix = function() {
            if (zx(this, w_, "f").touchEnabled)
                return new ht(Math.round(zx(this, j_, "f").target.x / cw.partWidth),Math.round(zx(this, j_, "f").target.y / cw.partHeight),Math.round(zx(this, j_, "f").target.z / cw.partLength));
            let e;
            if (null != zx(this, sx, "f") ? (zx(this, ex, "f").setFromCamera(zx(this, sx, "f"), zx(this, c_, "f").camera),
            e = zx(this, ex, "f").intersectObjects([zx(this, tx, "f")])) : e = [],
            e.length > 0) {
                const t = e[0]
                  , n = new ht(Math.round(t.point.x / cw.partWidth),Math.floor(zx(this, tx, "f").position.y / cw.partHeight),Math.round(t.point.z / cw.partLength));
                return t.point.distanceToSquared(zx(this, j_, "f").target) <= zx(this, ux, "f") * zx(this, ux, "f") ? n : null
            }
            return null
        }
        ,
        Nx = function(e, t) {
            const n = [];
            return t.rotated(zx(this, hx, "f")).forEach(((t,i,r)=>{
                const a = e.x + t
                  , s = e.y + i
                  , o = e.z + r;
                zx(this, d_, "f").hasPartAt(a, s, o) && n.push({
                    x: a,
                    y: s,
                    z: o
                })
            }
            )),
            n
        }
        ,
        Ux = function(e) {
            var t;
            let n = !1;
            e.forEach((({x: e, y: t, z: i})=>{
                zx(this, d_, "f").hasPartAt(e, t, i) && (zx(this, d_, "f").deletePart(e, t, i),
                n = !0)
            }
            )),
            n && (zx(this, a_, "m", Lx).call(this),
            zx(this, d_, "f").generateMeshes(),
            null === (t = zx(this, px, "f")) || void 0 === t || t.refresh(zx(this, d_, "f")),
            zx(this, A_, "f").setFromExistingCheckpoints(zx(this, d_, "f")),
            Ox(this, $_, !1, "f"))
        }
        ,
        Dx = function(e) {
            const t = 4 * zx(this, j_, "f").getDistance();
            if (zx(this, __, "f") && zx(this, a_, "m", Bx).call(this)) {
                const n = new ht;
                if (zx(this, q_, "f") && (n.z = -1),
                zx(this, Y_, "f") && (n.x = 1),
                zx(this, Z_, "f") && (n.z = 1),
                zx(this, K_, "f") && (n.x = -1),
                0 != n.x || 0 != n.z) {
                    const i = n.applyQuaternion(zx(this, G_, "f").quaternion)
                      , r = new De(i.x,i.z).normalize()
                      , a = new ht(r.x,0,r.y).multiplyScalar(t * e);
                    zx(this, G_, "f").position.add(a),
                    zx(this, j_, "f").target.add(a)
                }
                let i = 0;
                if (zx(this, J_, "f") && (i += 1.5 * Math.PI * e),
                zx(this, Q_, "f") && (i -= 1.5 * Math.PI * e),
                0 != i) {
                    const e = new De(zx(this, G_, "f").position.x,zx(this, G_, "f").position.z).distanceTo(new De(zx(this, j_, "f").target.x,zx(this, j_, "f").target.z))
                      , t = Math.atan2(zx(this, G_, "f").position.z - zx(this, j_, "f").target.z, zx(this, G_, "f").position.x - zx(this, j_, "f").target.x) + i;
                    zx(this, G_, "f").position.x = zx(this, j_, "f").target.x + Math.cos(t) * e,
                    zx(this, G_, "f").position.z = zx(this, j_, "f").target.z + Math.sin(t) * e,
                    zx(this, j_, "f").update()
                }
            }
        }
        ,
        Bx = function() {
            return !!zx(this, __, "f") && (document.activeElement != zx(this, E_, "f") && (!zx(this, v_, "f").isOpen && null == zx(this, R_, "f") && !zx(this, P_, "f").isOpen))
        }
        ;
        const Fx = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p) {
                a_.add(this),
                s_.set(this, void 0),
                o_.set(this, performance.now()),
                l_.set(this, void 0),
                c_.set(this, void 0),
                h_.set(this, void 0),
                d_.set(this, void 0),
                u_.set(this, void 0),
                p_.set(this, void 0),
                f_.set(this, void 0),
                m_.set(this, void 0),
                g_.set(this, void 0),
                v_.set(this, void 0),
                w_.set(this, void 0),
                y_.set(this, null),
                __.set(this, !1),
                x_.set(this, void 0),
                b_.set(this, void 0),
                E_.set(this, void 0),
                S_.set(this, void 0),
                M_.set(this, null),
                T_.set(this, void 0),
                k_.set(this, void 0),
                C_.set(this, void 0),
                A_.set(this, void 0),
                P_.set(this, void 0),
                R_.set(this, null),
                L_.set(this, void 0),
                I_.set(this, void 0),
                N_.set(this, void 0),
                U_.set(this, void 0),
                D_.set(this, void 0),
                B_.set(this, void 0),
                O_.set(this, void 0),
                z_.set(this, void 0),
                F_.set(this, void 0),
                W_.set(this, void 0),
                H_.set(this, void 0),
                V_.set(this, void 0),
                G_.set(this, void 0),
                j_.set(this, void 0),
                X_.set(this, !1),
                q_.set(this, !1),
                Y_.set(this, !1),
                Z_.set(this, !1),
                K_.set(this, !1),
                J_.set(this, !1),
                Q_.set(this, !1),
                $_.set(this, !0),
                ex.set(this, void 0),
                tx.set(this, void 0),
                nx.set(this, void 0),
                ix.set(this, void 0),
                rx.set(this, !1),
                ax.set(this, !1),
                sx.set(this, null),
                ox.set(this, null),
                lx.set(this, !1),
                cx.set(this, null),
                hx.set(this, 0),
                dx.set(this, null),
                ux.set(this, 1e3),
                px.set(this, null),
                fx.set(this, []),
                mx.set(this, 1),
                gx.set(this, []),
                vx.set(this, null),
                Tx.set(this, null),
                kx.set(this, null),
                Cx.set(this, null),
                Ox(this, l_, e, "f"),
                Ox(this, s_, t, "f"),
                Ox(this, c_, n, "f"),
                Ox(this, h_, i, "f"),
                Ox(this, d_, r, "f"),
                Ox(this, u_, a, "f"),
                Ox(this, g_, s, "f"),
                Ox(this, p_, o, "f"),
                Ox(this, f_, l, "f"),
                Ox(this, m_, c, "f"),
                Ox(this, v_, h, "f"),
                Ox(this, w_, d, "f"),
                Ox(this, G_, new _i(70,1,.1,1e4), "f"),
                zx(this, G_, "f").position.set(40, 40, -40),
                n.scene.add(zx(this, G_, "f")),
                Ox(this, j_, new _v(zx(this, G_, "f"),n.canvas), "f"),
                zx(this, j_, "f").mouseButtons = {
                    MIDDLE: g,
                    RIGHT: w
                },
                zx(this, j_, "f").minDistance = 4,
                zx(this, j_, "f").maxDistance = 600,
                Ox(this, ex, new sc, "f"),
                Ox(this, ix, new ol({
                    transparent: !0,
                    opacity: .3,
                    polygonOffset: !0,
                    polygonOffsetFactor: -.3,
                    depthWrite: !1
                }), "f"),
                Ox(this, nx, new ls, "f"),
                zx(this, nx, "f").visible = !1,
                n.scene.add(zx(this, nx, "f")),
                Ox(this, tx, new di(new Ni(1e6,1e6),new In({
                    side: 2
                })), "f"),
                zx(this, tx, "f").rotation.x = -Math.PI / 2,
                zx(this, tx, "f").updateWorldMatrix(!0, !0),
                n.canvas.addEventListener("mousemove", Ox(this, I_, (e=>{
                    const t = e.clientX / window.innerWidth * 2 - 1
                      , n = -e.clientY / window.innerHeight * 2 + 1;
                    null == zx(this, sx, "f") ? Ox(this, sx, new De(t,n), "f") : zx(this, sx, "f").set(t, n)
                }
                ), "f")),
                n.canvas.addEventListener("mousedown", Ox(this, N_, (e=>{
                    0 == e.button && Ox(this, ax, !0, "f"),
                    1 == e.button && e.preventDefault()
                }
                ), "f")),
                window.addEventListener("mouseup", Ox(this, U_, (e=>{
                    0 == e.button && (Ox(this, ax, !1, "f"),
                    Ox(this, dx, null, "f"))
                }
                ), "f")),
                n.canvas.addEventListener("mouseout", Ox(this, D_, (()=>{
                    Ox(this, sx, null, "f")
                }
                ), "f")),
                n.canvas.addEventListener("touchstart", Ox(this, B_, (()=>{
                    zx(this, w_, "f").touchEnabled && Ox(this, ox, Date.now(), "f")
                }
                ), "f")),
                n.canvas.addEventListener("click", Ox(this, O_, (()=>{
                    zx(this, w_, "f").touchEnabled && null != zx(this, ox, "f") && Date.now() - zx(this, ox, "f") < 200 && (Ox(this, ox, null, "f"),
                    Ox(this, lx, !0, "f"))
                }
                ), "f")),
                window.addEventListener("keydown", Ox(this, z_, (e=>{
                    zx(this, a_, "m", Bx).call(this) && (zx(this, v_, "f").isOpen || zx(this, P_, "f").isOpen || null != zx(this, R_, "f") || "Escape" == e.code && (zx(this, a_, "m", yx).call(this, p),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorRotate) && (Ox(this, hx, (zx(this, hx, "f") + 1) % 4, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorHeightModifier) && (Ox(this, X_, !0, "f"),
                    zx(this, j_, "f").enableZoom = !1,
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorDelete) && (Ox(this, rx, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorMoveForwards) && (Ox(this, q_, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorMoveRight) && (Ox(this, Y_, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorMoveBackwards) && (Ox(this, Z_, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorMoveLeft) && (Ox(this, K_, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorRotateLeft) && (Ox(this, J_, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorRotateRight) && (Ox(this, Q_, !0, "f"),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorMoveDown) && (Ox(this, a_, Math.max(0, zx(this, a_, "a", Px) - 1), "a", Rx),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorMoveUp) && (Ox(this, a_, zx(this, a_, "a", Px) + 1, "a", Rx),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorTest) && (zx(this, a_, "m", _x).call(this),
                    e.preventDefault()),
                    u.checkKeyBinding(e, Xw.EditorPick) && (zx(this, a_, "m", xx).call(this),
                    e.preventDefault()))
                }
                ), "f")),
                window.addEventListener("keyup", Ox(this, F_, (e=>{
                    u.checkKeyBinding(e, Xw.EditorHeightModifier) && (Ox(this, X_, !1, "f"),
                    zx(this, j_, "f").enableZoom = !0),
                    u.checkKeyBinding(e, Xw.EditorDelete) && Ox(this, rx, !1, "f"),
                    u.checkKeyBinding(e, Xw.EditorMoveForwards) && Ox(this, q_, !1, "f"),
                    u.checkKeyBinding(e, Xw.EditorMoveRight) && Ox(this, Y_, !1, "f"),
                    u.checkKeyBinding(e, Xw.EditorMoveBackwards) && Ox(this, Z_, !1, "f"),
                    u.checkKeyBinding(e, Xw.EditorMoveLeft) && Ox(this, K_, !1, "f"),
                    u.checkKeyBinding(e, Xw.EditorRotateLeft) && Ox(this, J_, !1, "f"),
                    u.checkKeyBinding(e, Xw.EditorRotateRight) && Ox(this, Q_, !1, "f")
                }
                ), "f")),
                window.addEventListener("wheel", Ox(this, W_, (e=>{
                    zx(this, X_, "f") && zx(this, __, "f") && (e.deltaY > 0 ? Ox(this, a_, zx(this, a_, "a", Px) + 1, "a", Rx) : e.deltaY < 0 && Ox(this, a_, Math.max(0, zx(this, a_, "a", Px) - 1), "a", Rx))
                }
                ), "f")),
                window.addEventListener("beforeunload", Ox(this, H_, (e=>!zx(this, $_, "f") && (e.preventDefault(),
                e.returnValue = !0,
                !0)), "f")),
                zx(this, a_, "m", wx).call(this, p),
                d.addChangeListener(Ox(this, V_, (e=>{
                    zx(this, L_, "f").setEnabled(e)
                }
                ), "f"))
            }
            dispose() {
                var e, t;
                Ox(this, __, !1, "f"),
                null === (e = zx(this, px, "f")) || void 0 === e || e.dispose(),
                zx(this, C_, "f").dispose(),
                zx(this, A_, "f").dispose(),
                null === (t = zx(this, R_, "f")) || void 0 === t || t.dispose(),
                Ox(this, R_, null, "f"),
                zx(this, P_, "f").dispose(),
                zx(this, L_, "f").dispose();
                document.getElementById("ui").removeChild(zx(this, x_, "f")),
                zx(this, c_, "f").scene.remove(zx(this, G_, "f")),
                zx(this, j_, "f").dispose(),
                zx(this, ix, "f").dispose(),
                zx(this, nx, "f").children.forEach((e=>{
                    const t = e;
                    t.geometry.dispose(),
                    Array.isArray(t.material) ? t.material.forEach((e=>e.dispose())) : t.material.dispose()
                }
                )),
                zx(this, c_, "f").scene.remove(zx(this, nx, "f")),
                zx(this, tx, "f").geometry.dispose(),
                Array.isArray(zx(this, tx, "f").material) ? zx(this, tx, "f").material.forEach((e=>e.dispose())) : zx(this, tx, "f").material.dispose(),
                zx(this, c_, "f").canvas.removeEventListener("mousemove", zx(this, I_, "f")),
                zx(this, c_, "f").canvas.removeEventListener("mousedown", zx(this, N_, "f")),
                window.removeEventListener("mouseup", zx(this, U_, "f")),
                zx(this, c_, "f").canvas.removeEventListener("mouseout", zx(this, D_, "f")),
                zx(this, c_, "f").canvas.removeEventListener("touchstart", zx(this, B_, "f")),
                zx(this, c_, "f").canvas.removeEventListener("click", zx(this, O_, "f")),
                window.removeEventListener("keydown", zx(this, z_, "f")),
                window.removeEventListener("keyup", zx(this, F_, "f")),
                window.removeEventListener("wheel", zx(this, W_, "f")),
                window.removeEventListener("beforeunload", zx(this, H_, "f")),
                zx(this, w_, "f").removeChangeListener(zx(this, V_, "f"))
            }
            getTrackName() {
                return "" == zx(this, E_, "f").value.trim() ? null : zx(this, E_, "f").value
            }
            setTestCallback(e) {
                Ox(this, y_, e, "f")
            }
            reset() {
                Ox(this, hx, 0, "f"),
                zx(this, a_, "m", Mx).call(this, 1),
                zx(this, A_, "f").reset(),
                this.resetView()
            }
            enable() {
                var e;
                Ox(this, __, !0, "f"),
                zx(this, j_, "f").enabled = !0,
                1 == zx(this, fx, "f").length && zx(this, a_, "m", Ex).call(this),
                null === (e = zx(this, px, "f")) || void 0 === e || e.dispose(),
                Ox(this, px, new ww(zx(this, c_, "f")), "f"),
                zx(this, px, "f").refresh(zx(this, d_, "f")),
                zx(this, L_, "f").show(),
                zx(this, x_, "f").className = "editor"
            }
            disable() {
                var e, t;
                Ox(this, __, !1, "f"),
                zx(this, j_, "f").enabled = !1,
                zx(this, nx, "f").visible = !1,
                null === (e = zx(this, px, "f")) || void 0 === e || e.dispose(),
                zx(this, x_, "f").className = "hidden",
                null === (t = zx(this, R_, "f")) || void 0 === t || t.dispose(),
                Ox(this, R_, null, "f"),
                zx(this, P_, "f").hide(),
                zx(this, L_, "f").hide()
            }
            isEnabled() {
                return zx(this, __, "f")
            }
            resetView() {
                Ox(this, a_, 0, "a", Rx),
                zx(this, G_, "f").position.set(40, 40, -40),
                zx(this, j_, "f").target.set(0, 0, 0),
                zx(this, j_, "f").update()
            }
            get camera() {
                return zx(this, G_, "f")
            }
            update(e) {
                var t;
                if (zx(this, __, "f")) {
                    zx(this, G_, "f").position.y < .5 && (zx(this, G_, "f").position.y = .5,
                    zx(this, j_, "f").update()),
                    Ox(this, cx, zx(this, a_, "m", Ix).call(this), "f"),
                    null != zx(this, cx, "f") ? zx(this, nx, "f").position.set(zx(this, cx, "f").x * cw.partWidth, zx(this, cx, "f").y * cw.partHeight, zx(this, cx, "f").z * cw.partLength) : zx(this, nx, "f").position.set(-1e6, -1e6, -1e6),
                    zx(this, nx, "f").rotation.y = zx(this, hx, "f") * Math.PI / 2;
                    for (let e = 0; e < zx(this, fx, "f").length; ++e) {
                        const t = zx(this, fx, "f")[e];
                        e == zx(this, mx, "f") ? t.mesh.visible = !0 : t.mesh.visible = !1
                    }
                    const e = zx(this, cx, "f");
                    if (null != e) {
                        const n = zx(this, fx, "f")[zx(this, mx, "f")]
                          , i = zx(this, a_, "m", Nx).call(this, e, n.tiles);
                        if (null == n.id || zx(this, rx, "f") ? i.length > 0 ? zx(this, ix, "f").color.set(12255232) : zx(this, ix, "f").color.set(12263970) : i.length > 0 ? zx(this, ix, "f").color.set(12303104) : zx(this, ix, "f").color.set(187),
                        zx(this, rx, "f"))
                            zx(this, a_, "m", Ux).call(this, i);
                        else if (zx(this, ax, "f") || zx(this, lx, "f")) {
                            if (null == n.id)
                                zx(this, a_, "m", Ux).call(this, i);
                            else if (null == zx(this, dx, "f") || zx(this, dx, "f").x != e.x || zx(this, dx, "f").y != e.y || zx(this, dx, "f").z != e.z || zx(this, dx, "f").id != n.id || zx(this, dx, "f").rotation != zx(this, hx, "f")) {
                                i.forEach((({x: e, y: t, z: n})=>{
                                    zx(this, d_, "f").hasPartAt(e, t, n) && zx(this, d_, "f").deletePart(e, t, n)
                                }
                                ));
                                let r = null;
                                n.isCheckpoint && (r = zx(this, A_, "f").checkpointOrder),
                                zx(this, d_, "f").setPart(e.x, e.y, e.z, n.id, zx(this, hx, "f"), r),
                                zx(this, a_, "m", Lx).call(this),
                                Ox(this, dx, {
                                    x: e.x,
                                    y: e.y,
                                    z: e.z,
                                    id: n.id,
                                    rotation: zx(this, hx, "f")
                                }, "f"),
                                zx(this, d_, "f").generateMeshes(),
                                null === (t = zx(this, px, "f")) || void 0 === t || t.refresh(zx(this, d_, "f")),
                                zx(this, A_, "f").setFromExistingCheckpoints(zx(this, d_, "f")),
                                Ox(this, $_, !1, "f")
                            }
                            Ox(this, lx, !1, "f")
                        }
                        zx(this, nx, "f").visible = !0
                    } else
                        zx(this, nx, "f").visible = !1
                }
                zx(this, a_, "m", Dx).call(this, e)
            }
        }
        ;
        var Wx, Hx, Vx, Gx, jx, Xx = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, qx = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Wx = new WeakMap,
        Hx = new WeakMap,
        Vx = new WeakMap,
        Gx = new WeakMap,
        jx = new WeakMap;
        const Yx = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f) {
                Wx.set(this, void 0),
                Hx.set(this, void 0),
                Vx.set(this, void 0),
                Gx.set(this, void 0),
                jx.set(this, void 0),
                Xx(this, Wx, e, "f"),
                Xx(this, Hx, i, "f"),
                Xx(this, Vx, r, "f"),
                Xx(this, Gx, a, "f"),
                Xx(this, jx, new Fx(n,i,r,s,e,t,o,l,c,h,d,u,a,p), "f"),
                qx(this, jx, "f").reset(),
                qx(this, jx, "f").enable(),
                qx(this, Wx, "f").clear(),
                qx(this, Wx, "f").setPart(0, 0, 0, Qg.Start, 0, null),
                qx(this, Wx, "f").generateMeshes(),
                r.setCamera(qx(this, jx, "f").camera),
                qx(this, jx, "f").setTestCallback((()=>{
                    var e;
                    qx(this, jx, "f").disable();
                    const t = null !== (e = qx(this, jx, "f").getTrackName()) && void 0 !== e ? e : "Unnamed track";
                    f(t, qx(this, Wx, "f").getTrackData(), (()=>{
                        qx(this, jx, "f").enable(),
                        r.setCamera(qx(this, jx, "f").camera)
                    }
                    ))
                }
                ))
            }
            dispose() {
                qx(this, jx, "f").dispose(),
                qx(this, jx, "f").resetView(),
                qx(this, Wx, "f").clear()
            }
            update(e) {
                qx(this, jx, "f").update(e),
                qx(this, Vx, "f").update(),
                qx(this, Hx, "f").update(e, !1, qx(this, Vx, "f"), qx(this, Gx, "f"))
            }
        }
        ;
        var Zx = n(338)
          , Kx = {};
        Kx.styleTagTransform = u(),
        Kx.setAttributes = l(),
        Kx.insert = s().bind(null, "head"),
        Kx.domAPI = r(),
        Kx.insertStyleElement = h();
        t()(Zx.Z, Kx);
        Zx.Z && Zx.Z.locals && Zx.Z.locals;
        var Jx, Qx, $x, eb, tb, nb, ib = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, rb = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Jx = new WeakMap,
        Qx = new WeakMap,
        $x = new WeakMap,
        eb = new WeakMap,
        tb = new WeakMap,
        nb = new WeakMap;
        const ab = class {
            constructor(e, t) {
                Jx.set(this, void 0),
                Qx.set(this, void 0),
                $x.set(this, void 0),
                eb.set(this, void 0),
                tb.set(this, void 0),
                nb.set(this, null),
                ib(this, Jx, t, "f"),
                ib(this, Qx, e, "f"),
                ib(this, $x, document.getElementById("ui"), "f"),
                ib(this, eb, document.createElement("div"), "f"),
                rb(this, Qx, "f") > 0 ? t.getSettingBoolean(uc.CheckpointsPosition) ? rb(this, eb, "f").className = "checkpoint up" : rb(this, eb, "f").className = "checkpoint" : rb(this, eb, "f").className = "hidden",
                rb(this, $x, "f").appendChild(rb(this, eb, "f"));
                const n = document.createElement("div");
                rb(this, eb, "f").appendChild(n);
                const i = document.createElement("img");
                i.src = "images/checkpoint.svg",
                n.appendChild(i),
                ib(this, tb, document.createElement("span"), "f"),
                n.appendChild(rb(this, tb, "f"))
            }
            dispose() {
                rb(this, $x, "f").removeChild(rb(this, eb, "f"))
            }
            setOverridePosition(e) {
                rb(this, Qx, "f") > 0 ? (null != e ? e : rb(this, Jx, "f").getSettingBoolean(uc.CheckpointsPosition)) ? rb(this, eb, "f").className = "checkpoint up" : rb(this, eb, "f").className = "checkpoint" : rb(this, eb, "f").className = "hidden"
            }
            update(e) {
                const t = e.getNextCheckpointIndex() + "/" + rb(this, Qx, "f");
                t != rb(this, nb, "f") && (rb(this, tb, "f").textContent = t,
                ib(this, nb, t, "f"))
            }
        }
        ;
        var sb = n(197)
          , ob = {};
        ob.styleTagTransform = u(),
        ob.setAttributes = l(),
        ob.insert = s().bind(null, "head"),
        ob.domAPI = r(),
        ob.insertStyleElement = h();
        t()(sb.Z, ob);
        sb.Z && sb.Z.locals && sb.Z.locals;
        var lb, cb, hb, db, ub, pb, fb, mb, gb, vb, wb = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, yb = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        cb = new WeakMap,
        hb = new WeakMap,
        db = new WeakMap,
        ub = new WeakMap,
        pb = new WeakMap,
        fb = new WeakMap,
        lb = new WeakSet,
        mb = function(e) {
            yb(this, pb, "f").textContent = e,
            yb(this, pb, "f").className = "hint show"
        }
        ,
        gb = function() {
            wb(this, fb, 2.5, "f"),
            yb(this, pb, "f").className = "hint hide"
        }
        ,
        vb = function() {
            wb(this, fb, 2.5, "f"),
            yb(this, pb, "f").className = "hint"
        }
        ;
        const _b = class {
            constructor(e, t, n) {
                lb.add(this),
                cb.set(this, void 0),
                hb.set(this, void 0),
                db.set(this, void 0),
                ub.set(this, void 0),
                pb.set(this, void 0),
                fb.set(this, 2.5),
                wb(this, cb, e, "f"),
                wb(this, hb, t, "f"),
                wb(this, db, n, "f"),
                wb(this, ub, document.getElementById("ui"), "f"),
                wb(this, pb, document.createElement("div"), "f"),
                yb(this, pb, "f").className = "hint",
                yb(this, ub, "f").appendChild(yb(this, pb, "f"))
            }
            dispose() {
                yb(this, ub, "f").removeChild(yb(this, pb, "f"))
            }
            update(e, t) {
                if (e.hasStarted() && !yb(this, hb, "f").touchEnabled && yb(this, db, "f").getSettingBoolean(uc.ResetHintEnabled))
                    if (e.getSpeedKmh() < 50 || e.hasFinished()) {
                        if (0 != yb(this, fb, "f") && (wb(this, fb, yb(this, fb, "f") - t, "f"),
                        yb(this, fb, "f") <= 0)) {
                            const e = yb(this, db, "f").getKeyBindings(Xw.VehicleReset);
                            null != e[0] && null != e[1] ? yb(this, lb, "m", mb).call(this, yb(this, cb, "f").get("Press [{0}] or [{1}] to restart", [e[0], e[1]])) : null != e[0] ? yb(this, lb, "m", mb).call(this, yb(this, cb, "f").get("Press [{0}] to restart", [e[0]])) : null != e[1] && yb(this, lb, "m", mb).call(this, yb(this, cb, "f").get("Press [{0}] to restart", [e[1]])),
                            wb(this, fb, 0, "f")
                        }
                    } else
                        yb(this, lb, "m", gb).call(this);
                else
                    yb(this, lb, "m", vb).call(this)
            }
        }
        ;
        var xb = n(680)
          , bb = {};
        bb.styleTagTransform = u(),
        bb.setAttributes = l(),
        bb.insert = s().bind(null, "head"),
        bb.domAPI = r(),
        bb.insertStyleElement = h();
        t()(xb.Z, bb);
        xb.Z && xb.Z.locals && xb.Z.locals;
        var Eb, Sb, Mb, Tb, kb, Cb, Ab, Pb = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Rb = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Eb = new WeakMap,
        Sb = new WeakMap,
        Mb = new WeakMap,
        Tb = new WeakMap,
        kb = new WeakMap,
        Cb = new WeakMap,
        Ab = new WeakMap;
        const Lb = class {
            constructor(e) {
                Eb.set(this, void 0),
                Sb.set(this, void 0),
                Mb.set(this, void 0),
                Tb.set(this, void 0),
                kb.set(this, void 0),
                Cb.set(this, null),
                Ab.set(this, void 0),
                Pb(this, Eb, e, "f"),
                Pb(this, Ab, e.getSettingBoolean(uc.ImperialUnitsEnabled), "f"),
                Pb(this, Sb, document.getElementById("ui"), "f"),
                Pb(this, Mb, document.createElement("div"), "f"),
                e.getSettingBoolean(uc.SpeedometerPosition) ? Rb(this, Mb, "f").className = "speedometer up" : Rb(this, Mb, "f").className = "speedometer",
                Rb(this, Sb, "f").appendChild(Rb(this, Mb, "f"));
                const t = document.createElement("div");
                Rb(this, Mb, "f").appendChild(t),
                Pb(this, Tb, document.createElement("span"), "f"),
                Rb(this, Tb, "f").textContent = "0",
                t.appendChild(Rb(this, Tb, "f")),
                Pb(this, kb, document.createElement("span"), "f"),
                Rb(this, Ab, "f") ? Rb(this, kb, "f").textContent = "mph" : Rb(this, kb, "f").textContent = "km/h",
                t.appendChild(Rb(this, kb, "f"))
            }
            dispose() {
                Rb(this, Sb, "f").removeChild(Rb(this, Mb, "f"))
            }
            setOverridePosition(e) {
                (null != e ? e : Rb(this, Eb, "f").getSettingBoolean(uc.SpeedometerPosition)) ? Rb(this, Mb, "f").className = "speedometer up" : Rb(this, Mb, "f").className = "speedometer"
            }
            update(e) {
                const t = Math.abs(e.getSpeedKmh());
                let n;
                n = Rb(this, Ab, "f") ? t / 1.609344 : t;
                const i = Math.trunc(n).toString();
                if (i != Rb(this, Cb, "f")) {
                    Rb(this, Tb, "f").innerHTML = "";
                    for (let e = 0; e < i.length; ++e) {
                        const t = document.createElement("span");
                        t.textContent = i[e],
                        Rb(this, Tb, "f").appendChild(t)
                    }
                    Pb(this, Cb, i, "f")
                }
            }
        }
        ;
        var Ib = n(894)
          , Nb = {};
        Nb.styleTagTransform = u(),
        Nb.setAttributes = l(),
        Nb.insert = s().bind(null, "head"),
        Nb.domAPI = r(),
        Nb.insertStyleElement = h();
        t()(Ib.Z, Nb);
        Ib.Z && Ib.Z.locals && Ib.Z.locals;
        var Ub, Db, Bb, Ob, zb, Fb, Wb, Hb, Vb, Gb, jb = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Xb = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Ub = new WeakMap,
        Db = new WeakMap,
        Bb = new WeakMap,
        Ob = new WeakMap,
        zb = new WeakMap,
        Fb = new WeakMap,
        Wb = new WeakMap,
        Hb = new WeakMap,
        Vb = new WeakMap,
        Gb = new WeakMap;
        const qb = class {
            constructor(e, t, n, i, r) {
                if (Ub.set(this, void 0),
                Db.set(this, void 0),
                Bb.set(this, void 0),
                Ob.set(this, void 0),
                zb.set(this, void 0),
                Fb.set(this, void 0),
                Wb.set(this, void 0),
                Hb.set(this, void 0),
                Vb.set(this, void 0),
                Gb.set(this, void 0),
                jb(this, Ub, document.getElementById("ui"), "f"),
                jb(this, Db, document.createElement("div"), "f"),
                Xb(this, Db, "f").className = "time-announcer",
                jb(this, Bb, document.createElement("div"), "f"),
                Xb(this, Bb, "f").className = "hidden",
                Xb(this, Bb, "f").textContent = e.get("New record"),
                Xb(this, Db, "f").appendChild(Xb(this, Bb, "f")),
                jb(this, Ob, document.createElement("div"), "f"),
                Xb(this, Ob, "f").className = "track-name",
                Xb(this, Ob, "f").textContent = t,
                Xb(this, Db, "f").appendChild(Xb(this, Ob, "f")),
                jb(this, zb, document.createElement("div"), "f"),
                Xb(this, zb, "f").className = "current",
                Xb(this, Db, "f").appendChild(Xb(this, zb, "f")),
                jb(this, Fb, document.createElement("div"), "f"),
                Xb(this, Db, "f").appendChild(Xb(this, Fb, "f")),
                jb(this, Wb, document.createElement("p"), "f"),
                Xb(this, Fb, "f").appendChild(Xb(this, Wb, "f")),
                jb(this, Hb, document.createElement("div"), "f"),
                Xb(this, Db, "f").appendChild(Xb(this, Hb, "f")),
                jb(this, Vb, document.createElement("p"), "f"),
                Xb(this, Vb, "f").className = "title",
                Xb(this, Hb, "f").appendChild(Xb(this, Vb, "f")),
                jb(this, Gb, document.createElement("p"), "f"),
                Xb(this, Hb, "f").appendChild(Xb(this, Gb, "f")),
                Xb(this, Ub, "f").appendChild(Xb(this, Db, "f")),
                Xb(this, zb, "f").textContent = xy.formatTimeString(n),
                null == i)
                    Xb(this, Bb, "f").className = "record",
                    Xb(this, Fb, "f").className = "hidden";
                else {
                    const e = n.difference(i);
                    Xb(this, Wb, "f").textContent = xy.formatTimeString(e, !0),
                    e.isNegative() ? (Xb(this, Bb, "f").className = "record",
                    Xb(this, Fb, "f").className = "difference") : (Xb(this, Bb, "f").className = "hidden",
                    Xb(this, Fb, "f").className = "difference red")
                }
                if (null == r)
                    Xb(this, Hb, "f").className = "hidden";
                else {
                    const e = n.difference(r.record);
                    Xb(this, Vb, "f").textContent = r.name,
                    Xb(this, Gb, "f").textContent = xy.formatTimeString(e, !0),
                    e.isNegative() ? Xb(this, Hb, "f").className = "difference" : Xb(this, Hb, "f").className = "difference red"
                }
            }
            dispose() {
                Xb(this, Ub, "f").removeChild(Xb(this, Db, "f"))
            }
        }
          , Yb = new Kt(0,0,0,"YXZ")
          , Zb = new ht
          , Kb = {
            type: "change"
        }
          , Jb = {
            type: "lock"
        }
          , Qb = {
            type: "unlock"
        }
          , $b = Math.PI / 2;
        class eE extends be {
            constructor(e, t) {
                super(),
                this.camera = e,
                this.domElement = t,
                this.isLocked = !1,
                this.minPolarAngle = 0,
                this.maxPolarAngle = Math.PI,
                this.pointerSpeed = 1,
                this._onMouseMove = tE.bind(this),
                this._onPointerlockChange = nE.bind(this),
                this._onPointerlockError = iE.bind(this),
                this.connect()
            }
            connect() {
                this.domElement.ownerDocument.addEventListener("mousemove", this._onMouseMove),
                this.domElement.ownerDocument.addEventListener("pointerlockchange", this._onPointerlockChange),
                this.domElement.ownerDocument.addEventListener("pointerlockerror", this._onPointerlockError)
            }
            disconnect() {
                this.domElement.ownerDocument.removeEventListener("mousemove", this._onMouseMove),
                this.domElement.ownerDocument.removeEventListener("pointerlockchange", this._onPointerlockChange),
                this.domElement.ownerDocument.removeEventListener("pointerlockerror", this._onPointerlockError)
            }
            dispose() {
                this.disconnect()
            }
            getObject() {
                return this.camera
            }
            getDirection(e) {
                return e.set(0, 0, -1).applyQuaternion(this.camera.quaternion)
            }
            moveForward(e) {
                const t = this.camera;
                Zb.setFromMatrixColumn(t.matrix, 0),
                Zb.crossVectors(t.up, Zb),
                t.position.addScaledVector(Zb, e)
            }
            moveRight(e) {
                const t = this.camera;
                Zb.setFromMatrixColumn(t.matrix, 0),
                t.position.addScaledVector(Zb, e)
            }
            lock() {
                this.domElement.requestPointerLock()
            }
            unlock() {
                this.domElement.ownerDocument.exitPointerLock()
            }
        }
        function tE(e) {
            if (!1 === this.isLocked)
                return;
            const t = e.movementX || e.mozMovementX || e.webkitMovementX || 0
              , n = e.movementY || e.mozMovementY || e.webkitMovementY || 0
              , i = this.camera;
            Yb.setFromQuaternion(i.quaternion),
            Yb.y -= .002 * t * this.pointerSpeed,
            Yb.x -= .002 * n * this.pointerSpeed,
            Yb.x = Math.max($b - this.maxPolarAngle, Math.min($b - this.minPolarAngle, Yb.x)),
            i.quaternion.setFromEuler(Yb),
            this.dispatchEvent(Kb)
        }
        function nE() {
            this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(Jb),
            this.isLocked = !0) : (this.dispatchEvent(Qb),
            this.isLocked = !1)
        }
        function iE() {
            console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")
        }
        var rE, aE, sE, oE, lE, cE, hE, dE, uE, pE, fE, mE = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, gE = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        rE = new WeakMap,
        aE = new WeakMap,
        sE = new WeakMap,
        oE = new WeakMap,
        lE = new WeakMap,
        cE = new WeakMap,
        hE = new WeakMap,
        dE = new WeakMap,
        uE = new WeakMap,
        pE = new WeakMap,
        fE = new WeakMap;
        const vE = class {
            constructor(e) {
                rE.set(this, void 0),
                aE.set(this, void 0),
                sE.set(this, !1),
                oE.set(this, []),
                lE.set(this, void 0),
                cE.set(this, void 0),
                hE.set(this, !1),
                dE.set(this, !1),
                uE.set(this, !1),
                pE.set(this, !1),
                fE.set(this, !1),
                mE(this, rE, new _i(70,1,.1,1e4), "f"),
                gE(this, rE, "f").position.set(0, 20, 0),
                mE(this, aE, new eE(gE(this, rE, "f"),document.documentElement), "f"),
                gE(this, aE, "f").addEventListener("lock", (()=>{
                    mE(this, sE, !0, "f"),
                    gE(this, oE, "f").forEach((e=>{
                        e(!0)
                    }
                    ))
                }
                )),
                gE(this, aE, "f").addEventListener("unlock", (()=>{
                    mE(this, sE, !1, "f"),
                    gE(this, oE, "f").forEach((e=>{
                        e(!1)
                    }
                    ))
                }
                )),
                window.addEventListener("keydown", mE(this, lE, (t=>{
                    e.checkKeyBinding(t, Xw.SpectatorMoveForwards) ? (mE(this, hE, !0, "f"),
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.SpectatorMoveRight) ? (mE(this, dE, !0, "f"),
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.SpectatorMoveBackwards) ? (mE(this, uE, !0, "f"),
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.SpectatorMoveLeft) ? (mE(this, pE, !0, "f"),
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.SpectatorSpeedModifier) && (mE(this, fE, !0, "f"),
                    t.preventDefault())
                }
                ), "f")),
                window.addEventListener("keyup", mE(this, cE, (t=>{
                    e.checkKeyBinding(t, Xw.SpectatorMoveForwards) ? mE(this, hE, !1, "f") : e.checkKeyBinding(t, Xw.SpectatorMoveRight) ? mE(this, dE, !1, "f") : e.checkKeyBinding(t, Xw.SpectatorMoveBackwards) ? mE(this, uE, !1, "f") : e.checkKeyBinding(t, Xw.SpectatorMoveLeft) ? mE(this, pE, !1, "f") : e.checkKeyBinding(t, Xw.SpectatorSpeedModifier) && mE(this, fE, !1, "f")
                }
                ), "f"))
            }
            dispose() {
                gE(this, aE, "f").dispose(),
                window.removeEventListener("keydown", gE(this, lE, "f")),
                window.removeEventListener("keyup", gE(this, cE, "f"))
            }
            addToggleListener(e) {
                gE(this, oE, "f").push(e)
            }
            enable() {
                gE(this, aE, "f").lock()
            }
            disable() {
                gE(this, aE, "f").unlock()
            }
            toggle() {
                gE(this, sE, "f") ? this.disable() : this.enable()
            }
            update(e) {
                if (gE(this, sE, "f")) {
                    let t;
                    if (t = gE(this, fE, "f") ? 400 * e : 50 * e,
                    gE(this, hE, "f")) {
                        const e = new ht(0,0,-1).applyQuaternion(gE(this, rE, "f").quaternion);
                        gE(this, rE, "f").position.add(e.multiplyScalar(t))
                    }
                    if (gE(this, dE, "f")) {
                        const e = new ht(1,0,0).applyQuaternion(gE(this, rE, "f").quaternion);
                        gE(this, rE, "f").position.add(e.multiplyScalar(t))
                    }
                    if (gE(this, uE, "f")) {
                        const e = new ht(0,0,1).applyQuaternion(gE(this, rE, "f").quaternion);
                        gE(this, rE, "f").position.add(e.multiplyScalar(t))
                    }
                    if (gE(this, pE, "f")) {
                        const e = new ht(-1,0,0).applyQuaternion(gE(this, rE, "f").quaternion);
                        gE(this, rE, "f").position.add(e.multiplyScalar(t))
                    }
                }
            }
            get camera() {
                return gE(this, rE, "f")
            }
            get enabled() {
                return gE(this, sE, "f")
            }
        }
        ;
        var wE = n(232)
          , yE = {};
        yE.styleTagTransform = u(),
        yE.setAttributes = l(),
        yE.insert = s().bind(null, "head"),
        yE.domAPI = r(),
        yE.insertStyleElement = h();
        t()(wE.Z, yE);
        wE.Z && wE.Z.locals && wE.Z.locals;
        var _E, xE, bE, EE = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, SE = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        _E = new WeakMap,
        xE = new WeakMap,
        bE = new WeakMap;
        const ME = class {
            constructor(e, t, n, i) {
                _E.set(this, void 0),
                xE.set(this, void 0),
                bE.set(this, void 0),
                EE(this, _E, document.getElementById("ui"), "f"),
                EE(this, xE, document.createElement("div"), "f"),
                SE(this, xE, "f").className = "hidden",
                SE(this, _E, "f").appendChild(SE(this, xE, "f"));
                const r = document.createElement("button");
                r.className = "quit",
                r.innerHTML = '<img src="images/quit.svg">',
                r.addEventListener("touchstart", (()=>{
                    r.classList.add("active"),
                    r.click()
                }
                )),
                r.addEventListener("touchend", (()=>{
                    r.classList.remove("active")
                }
                )),
                r.addEventListener("click", (()=>{
                    t.playUIClick(),
                    i()
                }
                )),
                SE(this, xE, "f").appendChild(r);
                const a = document.createElement("button");
                a.className = "reset",
                a.innerHTML = '<img src="images/reset.svg">',
                a.addEventListener("touchstart", (()=>{
                    a.classList.add("active"),
                    a.click()
                }
                )),
                a.addEventListener("touchend", (()=>{
                    a.classList.remove("active")
                }
                )),
                a.addEventListener("click", (()=>{
                    t.playUIClick(),
                    n()
                }
                )),
                SE(this, xE, "f").appendChild(a);
                const s = document.createElement("div");
                s.className = "left-container",
                SE(this, xE, "f").appendChild(s);
                const o = document.createElement("div");
                o.innerHTML = '<img src="images/arrow_up.svg">',
                s.appendChild(o);
                const l = document.createElement("div");
                l.innerHTML = '<img src="images/arrow_down.svg">',
                s.appendChild(l);
                const c = document.createElement("div");
                c.className = "right-container",
                SE(this, xE, "f").appendChild(c);
                const h = document.createElement("div");
                h.innerHTML = '<img src="images/arrow_left.svg">',
                c.appendChild(h);
                const d = document.createElement("div");
                d.innerHTML = '<img src="images/arrow_right.svg">',
                c.appendChild(d),
                EE(this, bE, (t=>{
                    let n = !1
                      , i = !1
                      , r = !1
                      , a = !1;
                    for (let e = 0; e < t.touches.length; e++) {
                        const s = t.touches.item(e);
                        if (null != s) {
                            switch (document.elementFromPoint(s.clientX, s.clientY)) {
                            case o:
                                n = !0;
                                break;
                            case d:
                                i = !0;
                                break;
                            case l:
                                r = !0;
                                break;
                            case h:
                                a = !0
                            }
                        }
                    }
                    e.up = n,
                    e.right = i,
                    e.down = r,
                    e.left = a,
                    o.className = n ? "active" : "",
                    d.className = i ? "active" : "",
                    l.className = r ? "active" : "",
                    h.className = a ? "active" : "",
                    t.preventDefault()
                }
                ), "f"),
                window.addEventListener("touchstart", SE(this, bE, "f"), {
                    passive: !1
                }),
                window.addEventListener("touchmove", SE(this, bE, "f"), {
                    passive: !1
                }),
                window.addEventListener("touchend", SE(this, bE, "f"), {
                    passive: !1
                })
            }
            setEnabled(e) {
                SE(this, xE, "f").className = e ? "touch-controls" : "hidden"
            }
            dispose() {
                SE(this, _E, "f").removeChild(SE(this, xE, "f")),
                window.removeEventListener("touchstart", SE(this, bE, "f")),
                window.removeEventListener("touchmove", SE(this, bE, "f")),
                window.removeEventListener("touchend", SE(this, bE, "f"))
            }
        }
        ;
        var TE, kE, CE, AE, PE, RE, LE, IE = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, NE = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        TE = new WeakMap,
        kE = new WeakMap,
        CE = new WeakMap,
        AE = new WeakMap,
        PE = new WeakMap,
        RE = new WeakMap,
        LE = new WeakMap;
        const UE = class {
            constructor(e) {
                TE.set(this, !1),
                kE.set(this, !1),
                CE.set(this, !1),
                AE.set(this, !1),
                PE.set(this, void 0),
                RE.set(this, void 0),
                LE.set(this, []),
                window.addEventListener("keydown", IE(this, PE, (t=>{
                    e.checkKeyBinding(t, Xw.VehicleAccelerate) ? (this.up = !0,
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.VehicleTurnRight) ? (this.right = !0,
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.VehicleBrake) ? (this.down = !0,
                    t.preventDefault()) : e.checkKeyBinding(t, Xw.VehicleTurnLeft) && (this.left = !0,
                    t.preventDefault())
                }
                ), "f")),
                window.addEventListener("keyup", IE(this, RE, (t=>{
                    e.checkKeyBinding(t, Xw.VehicleAccelerate) ? this.up = !1 : e.checkKeyBinding(t, Xw.VehicleTurnRight) ? this.right = !1 : e.checkKeyBinding(t, Xw.VehicleBrake) ? this.down = !1 : e.checkKeyBinding(t, Xw.VehicleTurnLeft) && (this.left = !1)
                }
                ), "f"))
            }
            get up() {
                return NE(this, TE, "f")
            }
            get right() {
                return NE(this, kE, "f")
            }
            get down() {
                return NE(this, CE, "f")
            }
            get left() {
                return NE(this, AE, "f")
            }
            set up(e) {
                NE(this, TE, "f") != e && (IE(this, TE, e, "f"),
                NE(this, LE, "f").forEach((e=>{
                    e(this)
                }
                )))
            }
            set right(e) {
                NE(this, kE, "f") != e && (IE(this, kE, e, "f"),
                NE(this, LE, "f").forEach((e=>{
                    e(this)
                }
                )))
            }
            set down(e) {
                NE(this, CE, "f") != e && (IE(this, CE, e, "f"),
                NE(this, LE, "f").forEach((e=>{
                    e(this)
                }
                )))
            }
            set left(e) {
                NE(this, AE, "f") != e && (IE(this, AE, e, "f"),
                NE(this, LE, "f").forEach((e=>{
                    e(this)
                }
                )))
            }
            addChangeCallback(e) {
                NE(this, LE, "f").push(e)
            }
            removeChangeCallback(e) {
                const t = NE(this, LE, "f").indexOf(e);
                t >= 0 && NE(this, LE, "f").splice(t, 1)
            }
            dispose() {
                window.removeEventListener("keydown", NE(this, PE, "f")),
                window.removeEventListener("keyup", NE(this, RE, "f"))
            }
            getControls() {
                return {
                    up: this.up,
                    right: this.right,
                    down: this.down,
                    left: this.left
                }
            }
        }
        ;
        var DE, BE = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        DE = new WeakMap;
        const OE = class {
            constructor() {
                DE.set(this, [])
            }
            push(e) {
                BE(this, DE, "f").push(e)
            }
            getFrame(e) {
                var t;
                return null !== (t = BE(this, DE, "f").find((t=>t.totalFrames == e))) && void 0 !== t ? t : null
            }
            getLastFrame() {
                return 0 == BE(this, DE, "f").length ? new vd(0) : new vd(BE(this, DE, "f")[BE(this, DE, "f").length - 1].totalFrames)
            }
        }
        ;
        var zE = n(57)
          , FE = {};
        FE.styleTagTransform = u(),
        FE.setAttributes = l(),
        FE.insert = s().bind(null, "head"),
        FE.domAPI = r(),
        FE.insertStyleElement = h();
        t()(zE.Z, FE);
        zE.Z && zE.Z.locals && zE.Z.locals;
        var WE, HE, VE, GE = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, jE = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        WE = new WeakMap,
        HE = new WeakMap,
        VE = new WeakMap;
        const XE = class {
            constructor(e, t, n, i) {
                WE.set(this, void 0),
                HE.set(this, void 0),
                VE.set(this, !0),
                GE(this, WE, document.getElementById("ui"), "f"),
                GE(this, HE, document.createElement("div"), "f"),
                n.getSettingBoolean(uc.CheckpointsPosition) ? jE(this, HE, "f").className = "game-toolbar visible" : jE(this, HE, "f").className = "game-toolbar visible up";
                const r = document.createElement("button");
                r.className = "button",
                r.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                r.append(document.createTextNode(t.get("Exit"))),
                r.addEventListener("click", (()=>{
                    e.playUIClick(),
                    i()
                }
                )),
                jE(this, HE, "f").appendChild(r),
                jE(this, WE, "f").appendChild(jE(this, HE, "f"))
            }
            dispose() {
                jE(this, WE, "f").removeChild(jE(this, HE, "f"))
            }
            setVisible(e) {
                jE(this, VE, "f") != e && (e ? jE(this, HE, "f").classList.add("visible") : jE(this, HE, "f").classList.remove("visible"),
                GE(this, VE, e, "f"))
            }
        }
        ;
        var qE, YE, ZE, KE, JE, QE, $E, eS, tS, nS, iS, rS, aS, sS, oS, lS, cS, hS, dS, uS, pS, fS, mS, gS, vS, wS, yS, _S, xS, bS, ES, SS, MS, TS, kS, CS, AS, PS, RS = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, LS = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        YE = new WeakMap,
        ZE = new WeakMap,
        KE = new WeakMap,
        JE = new WeakMap,
        QE = new WeakMap,
        $E = new WeakMap,
        eS = new WeakMap,
        tS = new WeakMap,
        nS = new WeakMap,
        iS = new WeakMap,
        rS = new WeakMap,
        aS = new WeakMap,
        sS = new WeakMap,
        oS = new WeakMap,
        lS = new WeakMap,
        cS = new WeakMap,
        hS = new WeakMap,
        dS = new WeakMap,
        uS = new WeakMap,
        pS = new WeakMap,
        fS = new WeakMap,
        mS = new WeakMap,
        gS = new WeakMap,
        vS = new WeakMap,
        wS = new WeakMap,
        yS = new WeakMap,
        _S = new WeakMap,
        xS = new WeakMap,
        bS = new WeakMap,
        ES = new WeakMap,
        SS = new WeakMap,
        qE = new WeakSet,
        MS = function(e) {
            var t, n, i, r, a, s, o, l, c;
            e ? (RS(this, cS, new _b(LS(this, QE, "f"),LS(this, rS, "f"),LS(this, nS, "f")), "f"),
            RS(this, hS, new ab(LS(this, KE, "f").getTotalNumberOfCheckpointIndices(),LS(this, nS, "f")), "f"),
            RS(this, dS, new Lb(LS(this, nS, "f")), "f"),
            RS(this, uS, new xy(LS(this, QE, "f"),LS(this, nS, "f"),null === (t = LS(this, _S, "f")) || void 0 === t ? void 0 : t.name), "f"),
            LS(this, rS, "f").touchEnabled ? (LS(this, hS, "f").setOverridePosition(!0),
            LS(this, uS, "f").setOverridePosition(!0),
            LS(this, dS, "f").setOverridePosition(!0)) : (LS(this, hS, "f").setOverridePosition(null),
            LS(this, uS, "f").setOverridePosition(null),
            LS(this, dS, "f").setOverridePosition(null),
            RS(this, fS, new XE(LS(this, eS, "f"),LS(this, QE, "f"),LS(this, nS, "f"),LS(this, sS, "f")), "f"),
            LS(this, fS, "f").setVisible(!(null !== (i = null === (n = LS(this, wS, "f")) || void 0 === n ? void 0 : n.hasStarted()) && void 0 !== i && i))),
            LS(this, mS, "f").setEnabled(LS(this, rS, "f").touchEnabled),
            LS(this, qE, "m", PS).call(this)) : (null === (r = LS(this, cS, "f")) || void 0 === r || r.dispose(),
            RS(this, cS, null, "f"),
            null === (a = LS(this, hS, "f")) || void 0 === a || a.dispose(),
            RS(this, hS, null, "f"),
            null === (s = LS(this, dS, "f")) || void 0 === s || s.dispose(),
            RS(this, dS, null, "f"),
            null === (o = LS(this, uS, "f")) || void 0 === o || o.dispose(),
            RS(this, uS, null, "f"),
            null === (l = LS(this, pS, "f")) || void 0 === l || l.dispose(),
            RS(this, pS, null, "f"),
            null === (c = LS(this, fS, "f")) || void 0 === c || c.dispose(),
            RS(this, fS, null, "f"))
        }
        ,
        TS = function() {
            LS(this, qE, "m", kS).call(this, LS(this, tS, "f").getCarColors()),
            LS(this, qE, "m", CS).call(this)
        }
        ,
        kS = function(e) {
            var t, n;
            null != LS(this, wS, "f") && (null != LS(this, uS, "f") && LS(this, _S, "f").isSelf && LS(this, wS, "f").hasFinished() && (null == LS(this, uS, "f").record || LS(this, wS, "f").getTime().lessThan(null === (t = LS(this, uS, "f")) || void 0 === t ? void 0 : t.record)) && (LS(this, uS, "f").record = LS(this, wS, "f").getTime()),
            LS(this, wS, "f").dispose(),
            RS(this, wS, null, "f")),
            RS(this, wS, new Jm(LS(this, YE, "f"),LS(this, KE, "f").getStartTransform(),null,LS(this, vS, "f"),!0,LS(this, $E, "f"),LS(this, eS, "f"),LS(this, JE, "f"),LS(this, KE, "f"),LS(this, nS, "f")), "f"),
            LS(this, wS, "f").addFinishCallback((e=>{
                const t = e.getTime()
                  , n = e.getRecording()
                  , i = e.getColors()
                  , r = LS(this, xS, "f");
                (null == LS(this, xS, "f") || t.lessThan(LS(this, xS, "f"))) && (LS(this, aS, "f").call(this, LS(this, KE, "f").getID(), n, t, i),
                LS(this, _S, "f").isSelf && (LS(this, _S, "f").recording = n,
                LS(this, _S, "f").time = t),
                RS(this, xS, t, "f"));
                let a = null;
                LS(this, _S, "f").isSelf || null == LS(this, _S, "f").time || null == LS(this, _S, "f").name || (a = {
                    record: LS(this, _S, "f").time,
                    name: LS(this, _S, "f").name
                }),
                RS(this, pS, new qb(LS(this, QE, "f"),LS(this, oS, "f"),t,r,a), "f")
            }
            )),
            LS(this, wS, "f").setColors(e),
            LS(this, $E, "f").setCamera(LS(this, wS, "f").cameraOrbit),
            LS(this, SS, "f").disable(),
            null === (n = LS(this, pS, "f")) || void 0 === n || n.dispose(),
            RS(this, pS, null, "f")
        }
        ,
        CS = function() {
            var e, t;
            if (LS(this, nS, "f").getSettingBoolean(uc.GhostCarEnabled) && (null != LS(this, yS, "f") && (LS(this, ZE, "f").deleteCar(LS(this, yS, "f").carId),
            null === (e = LS(this, yS, "f").car) || void 0 === e || e.dispose(),
            RS(this, yS, null, "f")),
            null != LS(this, _S, "f").time && null != LS(this, _S, "f").recording)) {
                const e = LS(this, KE, "f").getStartTransform()
                  , n = new OE
                  , i = LS(this, ZE, "f").createCar(e, LS(this, JE, "f").getMountainVertices(), LS(this, JE, "f").getMountainOffset(), LS(this, KE, "f").getTrackData(), LS(this, _S, "f").recording, (e=>{
                    n.push(e)
                }
                ));
                n.push(i),
                LS(this, ZE, "f").startCar(i.id, new vd(LS(this, _S, "f").time.numberOfFrames + 1e4));
                const r = new Jm(null,e,LS(this, _S, "f").recording,null,!1,LS(this, $E, "f"),LS(this, eS, "f"),LS(this, JE, "f"),LS(this, KE, "f"),LS(this, nS, "f"));
                r.setColors(null !== (t = LS(this, _S, "f").carColors) && void 0 !== t ? t : LS(this, tS, "f").getCarColors()),
                r.audioVolume = .35,
                LS(this, qE, "m", AS).call(this),
                RS(this, yS, {
                    car: r,
                    carId: i.id,
                    replay: n
                }, "f")
            }
        }
        ,
        AS = function() {
            var e;
            if (null != (null === (e = LS(this, yS, "f")) || void 0 === e ? void 0 : e.car) && null != LS(this, wS, "f")) {
                const e = LS(this, yS, "f").car.getPosition().distanceTo(LS(this, wS, "f").getPosition())
                  , t = Math.max(0, Math.min(1, e / 5));
                LS(this, yS, "f").car.setOpacity(t)
            }
        }
        ,
        PS = function() {
            var e, t;
            null != LS(this, uS, "f") && (LS(this, uS, "f").record = null !== (t = null === (e = LS(this, _S, "f")) || void 0 === e ? void 0 : e.time) && void 0 !== t ? t : null)
        }
        ;
        const IS = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g) {
                qE.add(this),
                YE.set(this, void 0),
                ZE.set(this, void 0),
                KE.set(this, void 0),
                JE.set(this, void 0),
                QE.set(this, void 0),
                $E.set(this, void 0),
                eS.set(this, void 0),
                tS.set(this, void 0),
                nS.set(this, void 0),
                iS.set(this, void 0),
                rS.set(this, void 0),
                aS.set(this, void 0),
                sS.set(this, void 0),
                oS.set(this, void 0),
                lS.set(this, !0),
                cS.set(this, void 0),
                hS.set(this, void 0),
                dS.set(this, void 0),
                uS.set(this, void 0),
                pS.set(this, void 0),
                fS.set(this, void 0),
                mS.set(this, void 0),
                gS.set(this, void 0),
                vS.set(this, void 0),
                wS.set(this, null),
                yS.set(this, null),
                _S.set(this, void 0),
                xS.set(this, void 0),
                bS.set(this, void 0),
                ES.set(this, void 0),
                SS.set(this, void 0),
                RS(this, YE, e, "f"),
                RS(this, ZE, t, "f"),
                RS(this, KE, n, "f"),
                RS(this, JE, i, "f"),
                RS(this, QE, r, "f"),
                RS(this, $E, a, "f"),
                RS(this, eS, s, "f"),
                RS(this, tS, o, "f"),
                RS(this, nS, l, "f"),
                RS(this, iS, c, "f"),
                RS(this, rS, h, "f"),
                RS(this, aS, m, "f"),
                RS(this, sS, g, "f"),
                RS(this, _S, p, "f"),
                RS(this, xS, f, "f"),
                RS(this, oS, d, "f"),
                n.loadTrackData(u),
                n.generateMeshes(),
                i.generateMountains(n.getBounds()),
                RS(this, vS, new UE(l), "f"),
                c.setCursorHiddenWhenInactive(!0),
                RS(this, mS, new ME(LS(this, vS, "f"),LS(this, eS, "f"),(()=>{
                    LS(this, qE, "m", TS).call(this)
                }
                ),g), "f"),
                LS(this, mS, "f").setEnabled(LS(this, rS, "f").touchEnabled),
                LS(this, qE, "m", MS).call(this, !0),
                LS(this, qE, "m", PS).call(this),
                RS(this, SS, new vE(l), "f"),
                LS(this, SS, "f").addToggleListener((e=>{
                    var t, n;
                    e ? (null != LS(this, wS, "f") && (LS(this, wS, "f").audioVolume = 0),
                    null != (null === (t = LS(this, yS, "f")) || void 0 === t ? void 0 : t.car) && (LS(this, yS, "f").car.audioVolume = 0),
                    LS(this, qE, "m", MS).call(this, !1),
                    a.setCamera(LS(this, SS, "f").camera)) : null != LS(this, wS, "f") && (null != LS(this, wS, "f") && (LS(this, wS, "f").audioVolume = 1),
                    null != (null === (n = LS(this, yS, "f")) || void 0 === n ? void 0 : n.car) && (LS(this, yS, "f").car.audioVolume = .35),
                    LS(this, qE, "m", MS).call(this, LS(this, lS, "f")),
                    a.setCamera(LS(this, wS, "f").cameraOrbit))
                }
                )),
                LS(this, rS, "f").addChangeListener(RS(this, gS, (e=>{
                    var t, n, i, r, a, s, o, l, c;
                    e ? (null === (t = LS(this, hS, "f")) || void 0 === t || t.setOverridePosition(!0),
                    null === (n = LS(this, uS, "f")) || void 0 === n || n.setOverridePosition(!0),
                    null === (i = LS(this, dS, "f")) || void 0 === i || i.setOverridePosition(!0),
                    null === (r = LS(this, fS, "f")) || void 0 === r || r.dispose(),
                    RS(this, fS, null, "f")) : (null === (a = LS(this, hS, "f")) || void 0 === a || a.setOverridePosition(null),
                    null === (s = LS(this, uS, "f")) || void 0 === s || s.setOverridePosition(null),
                    null === (o = LS(this, dS, "f")) || void 0 === o || o.setOverridePosition(null),
                    LS(this, lS, "f") && !LS(this, SS, "f").enabled && null == LS(this, fS, "f") && (RS(this, fS, new XE(LS(this, eS, "f"),LS(this, QE, "f"),LS(this, nS, "f"),LS(this, sS, "f")), "f"),
                    LS(this, fS, "f").setVisible(!(null !== (c = null === (l = LS(this, wS, "f")) || void 0 === l ? void 0 : l.hasStarted()) && void 0 !== c && c)))),
                    LS(this, mS, "f").setEnabled(e)
                }
                ), "f")),
                LS(this, qE, "m", kS).call(this, o.getCarColors()),
                LS(this, qE, "m", CS).call(this),
                window.addEventListener("keydown", RS(this, bS, (e=>{
                    if (LS(this, SS, "f").enabled || (LS(this, nS, "f").checkKeyBinding(e, Xw.VehicleReset) ? (LS(this, qE, "m", TS).call(this),
                    e.preventDefault()) : LS(this, nS, "f").checkKeyBinding(e, Xw.VehicleCockpitCamera) ? (e.repeat || null == LS(this, wS, "f") || LS(this, wS, "f").hasFinished() || (LS(this, nS, "f").getSettingBoolean(uc.CockpitCameraToggle) ? LS(this, $E, "f").camera == LS(this, wS, "f").cameraOrbit ? LS(this, $E, "f").setCamera(LS(this, wS, "f").cameraCockpit) : LS(this, $E, "f").setCamera(LS(this, wS, "f").cameraOrbit) : LS(this, $E, "f").setCamera(LS(this, wS, "f").cameraCockpit)),
                    e.preventDefault()) : l.checkKeyBinding(e, Xw.ToggleUI) ? (RS(this, lS, !LS(this, lS, "f"), "f"),
                    LS(this, qE, "m", MS).call(this, LS(this, lS, "f")),
                    e.preventDefault()) : "Escape" == e.code && (g(),
                    e.preventDefault())),
                    l.checkKeyBinding(e, Xw.ToggleSpectatorCamera) && null != LS(this, wS, "f")) {
                        LS(this, SS, "f").camera.position.copy(LS(this, $E, "f").camera.position);
                        const t = new Kt(0,0,0,"YXZ").setFromQuaternion(LS(this, $E, "f").camera.quaternion);
                        t.z = 0,
                        LS(this, SS, "f").camera.quaternion.setFromEuler(t),
                        LS(this, SS, "f").toggle(),
                        e.preventDefault()
                    }
                }
                ), "f")),
                window.addEventListener("keyup", RS(this, ES, (e=>{
                    LS(this, SS, "f").enabled || LS(this, nS, "f").checkKeyBinding(e, Xw.VehicleCockpitCamera) && (null == LS(this, wS, "f") || LS(this, wS, "f").hasFinished() || LS(this, nS, "f").getSettingBoolean(uc.CockpitCameraToggle) || LS(this, $E, "f").setCamera(LS(this, wS, "f").cameraOrbit))
                }
                ), "f"))
            }
            dispose(e=!0) {
                var t, n;
                LS(this, iS, "f").setCursorHiddenWhenInactive(!1),
                LS(this, qE, "m", MS).call(this, !1),
                LS(this, mS, "f").dispose(),
                LS(this, rS, "f").removeChangeListener(LS(this, gS, "f")),
                e && LS(this, KE, "f").clear(),
                LS(this, JE, "f").clearMountains(),
                LS(this, vS, "f").dispose(),
                null === (t = LS(this, wS, "f")) || void 0 === t || t.dispose(),
                null != LS(this, yS, "f") && (LS(this, ZE, "f").deleteCar(LS(this, yS, "f").carId),
                null === (n = LS(this, yS, "f").car) || void 0 === n || n.dispose(),
                RS(this, yS, null, "f")),
                window.removeEventListener("keydown", LS(this, bS, "f")),
                window.removeEventListener("keyup", LS(this, ES, "f")),
                LS(this, SS, "f").dispose()
            }
            update(e) {
                var t, n, i, r, a, s, o, l, c, h;
                let d;
                if (d = null == LS(this, wS, "f") || LS(this, SS, "f").enabled ? 0 : e,
                null === (t = LS(this, wS, "f")) || void 0 === t || t.update(d),
                null == LS(this, wS, "f") || LS(this, SS, "f").enabled)
                    null != LS(this, wS, "f") && (LS(this, wS, "f").isPaused = !0);
                else {
                    LS(this, wS, "f").isPaused = !1;
                    const t = LS(this, vS, "f").getControls();
                    (t.up || t.down) && (LS(this, wS, "f").hasStarted() || LS(this, wS, "f").start()),
                    null === (n = LS(this, cS, "f")) || void 0 === n || n.update(LS(this, wS, "f"), e),
                    null === (i = LS(this, dS, "f")) || void 0 === i || i.update(LS(this, wS, "f")),
                    null === (r = LS(this, uS, "f")) || void 0 === r || r.update(LS(this, wS, "f")),
                    null === (a = LS(this, hS, "f")) || void 0 === a || a.update(LS(this, wS, "f")),
                    null === (s = LS(this, fS, "f")) || void 0 === s || s.setVisible(!LS(this, wS, "f").hasStarted())
                }
                if (null != (null === (o = LS(this, yS, "f")) || void 0 === o ? void 0 : o.car)) {
                    const e = null === (l = LS(this, wS, "f")) || void 0 === l ? void 0 : l.getTotalTime().numberOfFrames;
                    if (null != e) {
                        for (let t = LS(this, yS, "f").car.getTotalTime().numberOfFrames + 1; t <= e; t++) {
                            const e = LS(this, yS, "f").replay.getFrame(t);
                            if (null == e) {
                                LS(this, yS, "f").car.dispose(),
                                LS(this, yS, "f").car = null;
                                break
                            }
                            LS(this, yS, "f").car.setCarState(e)
                        }
                    }
                    null === (c = LS(this, yS, "f").car) || void 0 === c || c.update(d)
                }
                LS(this, qE, "m", AS).call(this),
                LS(this, SS, "f").update(e),
                LS(this, $E, "f").update(null === (h = LS(this, wS, "f")) || void 0 === h ? void 0 : h.getPosition()),
                LS(this, eS, "f").update(e, !1, LS(this, $E, "f"), LS(this, nS, "f"))
            }
        }
        ;
        var NS, US, DS, BS, OS, zS, FS, WS, HS, VS = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, GS = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        US = new WeakMap,
        DS = new WeakMap,
        BS = new WeakMap,
        OS = new WeakMap,
        zS = new WeakMap,
        FS = new WeakMap,
        WS = new WeakMap,
        NS = new WeakSet,
        HS = function() {
            var e, t;
            if (GS(this, zS, "f")instanceof _i) {
                const e = window.innerWidth / window.innerHeight;
                GS(this, US, "f").width == window.innerWidth && GS(this, US, "f").height == window.innerHeight && GS(this, zS, "f").aspect == e || (GS(this, BS, "f").setSize(window.innerWidth, window.innerHeight),
                GS(this, zS, "f").aspect = e,
                GS(this, zS, "f").updateProjectionMatrix())
            }
            let n = null !== (t = null === (e = GS(this, DS, "f")) || void 0 === e ? void 0 : e.getSettingFloat(uc.RenderScale)) && void 0 !== t ? t : 1;
            n = Number.isFinite(n) ? Math.min(Math.max(n, .25), 2) : 1;
            const i = window.devicePixelRatio * n;
            GS(this, BS, "f").pixelRatio != i && GS(this, BS, "f").setPixelRatio(i)
        }
        ;
        const jS = class {
            constructor(e, t, n=!0, i=!1) {
                var r;
                NS.add(this),
                US.set(this, void 0),
                DS.set(this, void 0),
                BS.set(this, void 0),
                OS.set(this, void 0),
                zS.set(this, new _i),
                FS.set(this, void 0),
                WS.set(this, {
                    x: 8,
                    y: 10,
                    z: 10
                }),
                VS(this, US, e, "f"),
                VS(this, DS, t, "f"),
                VS(this, BS, new fs({
                    antialias: null === (r = null == t ? void 0 : t.getSettingBoolean(uc.Antialiasing)) || void 0 === r || r,
                    powerPreference: "high-performance",
                    canvas: e,
                    alpha: i
                }), "f"),
                GS(this, BS, "f").outputColorSpace = ce,
                GS(this, BS, "f").shadowMap.enabled = !0,
                VS(this, OS, new gs, "f"),
                n && (GS(this, OS, "f").fog = new ms(6793641,.001)),
                GS(this, OS, "f").add(new Bl(3891597,11714755,4.7)),
                VS(this, FS, new Kl(16777215,4.7), "f"),
                GS(this, FS, "f").position.set(GS(this, WS, "f").x, GS(this, WS, "f").y, GS(this, WS, "f").z),
                GS(this, FS, "f").castShadow = !0,
                GS(this, FS, "f").shadow.camera.top = 10,
                GS(this, FS, "f").shadow.camera.right = 10,
                GS(this, FS, "f").shadow.camera.bottom = -10,
                GS(this, FS, "f").shadow.camera.left = -10,
                GS(this, FS, "f").shadow.camera.near = 1,
                GS(this, FS, "f").shadow.camera.far = 50,
                GS(this, FS, "f").shadow.mapSize.width = 2048,
                GS(this, FS, "f").shadow.mapSize.height = 2048,
                GS(this, OS, "f").add(GS(this, FS, "f")),
                GS(this, OS, "f").add(GS(this, FS, "f").target)
            }
            clear() {
                GS(this, BS, "f").clear()
            }
            update(e) {
                var t, n, i;
                const r = null !== (n = null === (t = GS(this, DS, "f")) || void 0 === t ? void 0 : t.getSettingInteger(uc.CarShadowQuality)) && void 0 !== n ? n : 0;
                if (!Number.isFinite(r) || r <= 0)
                    GS(this, FS, "f").castShadow = !1;
                else {
                    GS(this, FS, "f").castShadow = !0;
                    const e = Math.min(r, GS(this, BS, "f").capabilities.maxTextureSize);
                    GS(this, FS, "f").shadow.mapSize.width == e && GS(this, FS, "f").shadow.mapSize.height == e || (GS(this, FS, "f").shadow.mapSize.setScalar(e),
                    null === (i = GS(this, FS, "f").shadow.map) || void 0 === i || i.dispose(),
                    GS(this, FS, "f").shadow.map = null)
                }
                null != e && (GS(this, FS, "f").position.set(e.x + GS(this, WS, "f").x, e.y + GS(this, WS, "f").y, e.z + GS(this, WS, "f").z),
                GS(this, FS, "f").target.position.copy(e)),
                GS(this, NS, "m", HS).call(this),
                GS(this, BS, "f").render(GS(this, OS, "f"), GS(this, zS, "f"))
            }
            getShadowDirection() {
                return (new ht).subVectors(GS(this, FS, "f").position, GS(this, FS, "f").target.position).normalize()
            }
            getLightTarget() {
                return GS(this, FS, "f").target.position
            }
            getMaxAnisotropy() {
                return GS(this, BS, "f").capabilities.getMaxAnisotropy()
            }
            setCamera(e) {
                VS(this, zS, e, "f")
            }
            get camera() {
                return GS(this, zS, "f")
            }
            get canvas() {
                return GS(this, US, "f")
            }
            setAnimationLoop(e) {
                GS(this, BS, "f").setAnimationLoop(e)
            }
            get scene() {
                return GS(this, OS, "f")
            }
        }
        ;
        var XS, qS, YS, ZS = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        }, KS = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        };
        class JS {
            constructor(e) {
                if (qS.set(this, void 0),
                null != e) {
                    if (!Number.isInteger(e))
                        throw "Seed must be an integer";
                    KS(this, qS, e % ZS(XS, XS, "f", YS).length, "f")
                } else
                    KS(this, qS, 0, "f")
            }
            next() {
                var e;
                return KS(this, qS, (e = ZS(this, qS, "f"),
                ++e), "f"),
                ZS(this, qS, "f") >= ZS(XS, XS, "f", YS).length && KS(this, qS, 0, "f"),
                ZS(XS, XS, "f", YS)[ZS(this, qS, "f")]
            }
        }
        XS = JS,
        qS = new WeakMap,
        YS = {
            value: [.12047764760664692, .19645762332790628, .5525629082262744, .41272626379209965, .7795036003541387, .13367266027110114, .7999601557377349, .9519714253374205, .1735048382917752, .7513367084489158, .6531386724839523, .9026427867068505, .8543272738216994, .11176849958868162, .6705698284858437, .26628732081296946, .31140322993719605, .45170300835470933, .12615515120247944, .0610638094525735, .291990923385425, .4613983868623317, .6615759832726253, .4373182881232056, .7432890501246443, .39316710322388837, .49444122821563297, .5994296685114344, .060050119050233386, .4165885432422003, .43974364800990084, .1628314496954224, .05787972729968116, .225388541259955, .6075775236386991, .8908354370882479, .47072983115144584, .7662003453186828, .20651036895645647, .03724062137286044, .17110277274376795, .7626426077793496, .8372112804261309, .8761690804447455, .13887024930406633, .8287513367412203, .9794446290917873, .807658524448803, .8465629116398186, .5187285629536083, .33962953580139277, .9798419666114342, .6777071959103609, .5388899884934379, .7863389168762325, .4274591420924474, .25631366937500566, .5695289062505289, .026841382754547727, .18267938207996903, .9853642975717878, .24428485895234409, .5322028747608949, .9655065842019517, .043810183244384016, .541216190236913, .05897981610006209, .2849168541804703, .5349823008832073, .9655676144971486, .22831812764497283, .7698701658704175, .4103995069939841, .25782763124411856, .8490222628872495, .39280879489916987, .31999467883347554, .2860820872456349, .9684928577493004, .9973831481899462, .2930912094664657, .4847128131859766, .7218400909709828, .40407009594106236, .7059298060123587, .45362146566562744, .4640974655488792, .16076769483252273, .5989453525750241, .585759299589679, .9417035568973537, .20117930667657413, .5777873180244959, .1991854396549344, .8743781441651348, .624666386634513, .38720573630932886, .9967931526923675, .49817894572849486, .24585267823751833, .8639168275132305, .2865624029759799, .6163605496913385, .5864748073339972, .8781049154377354, .7497547608938613, .7864098057445887, .0334170452332867, .4875588105294657, .6737395339380896, .21851121231639659, .2923739650597854, .6073797612662293, .41823228947229896, .8531029420136382, .3260916332061783, .6306262204574675, .5268576689601923, .3516570914484707, .8659366375222706, .8447448461834428, .3794548980890986, .9832775904115916, .8442256760399809, .3006550591973338, .9718660619781394, .5103245035851833, .794319831388071]
        };
        const QS = JS;
        var $S, eM, tM, nM, iM = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, rM = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class aM {
            constructor(e) {
                $S.set(this, void 0),
                eM.set(this, void 0),
                tM.set(this, void 0),
                nM.set(this, null),
                iM(this, $S, e, "f"),
                iM(this, eM, new di(new ko(9e3,32),new ol({
                    color: 3495480,
                    depthWrite: !1
                })), "f"),
                rM(this, eM, "f").rotation.x = -Math.PI / 2,
                rM(this, eM, "f").renderOrder = -3,
                e.scene.add(rM(this, eM, "f")),
                iM(this, tM, new di(new Ni(120,120),new ol({
                    color: 3495480,
                    depthWrite: !1
                })), "f"),
                rM(this, tM, "f").rotation.x = -Math.PI / 2,
                rM(this, tM, "f").receiveShadow = !0,
                rM(this, tM, "f").renderOrder = -2,
                e.scene.add(rM(this, tM, "f"))
            }
            clearMountains() {
                null != rM(this, nM, "f") && (rM(this, nM, "f").material.dispose(),
                rM(this, nM, "f").geometry.dispose(),
                rM(this, $S, "f").scene.remove(rM(this, nM, "f")),
                iM(this, nM, null, "f"))
            }
            generateMountains(e) {
                this.clearMountains();
                const {vertices: t, offset: n} = aM.createMountainVertices(e)
                  , i = new qn;
                i.setAttribute("position", new Dn(new Float32Array(t),3)),
                i.computeVertexNormals();
                const r = new di(i,new ol({
                    color: 3495480
                }));
                r.position.copy(n),
                r.receiveShadow = !0,
                rM(this, $S, "f").scene.add(r),
                iM(this, nM, r, "f")
            }
            static createMountainVertices(e) {
                const t = new QS
                  , n = Math.max(200, 160 + Math.max(Math.abs(e.max.x - e.min.x) * cw.partWidth / 2 * Math.SQRT2, Math.abs(e.max.y - e.min.y) * cw.partLength / 2 * Math.SQRT2))
                  , i = new De((e.min.x + (e.max.x - e.min.x) / 2) * cw.partWidth,(e.min.y + (e.max.y - e.min.y) / 2) * cw.partLength);
                if (n > 4500)
                    return {
                        vertices: [],
                        offset: new ht
                    };
                const r = Math.floor(n / 10)
                  , a = [];
                for (let e = 0; e < r; ++e) {
                    const e = [];
                    for (let n = 0; n < 8; ++n)
                        0 == n || 7 == n || 1 == n && t.next() < .5 ? e.push(0) : e.push(t.next());
                    a.push(e)
                }
                const s = 100
                  , o = [];
                for (let e = 0; e < a.length; ++e) {
                    const t = e / a.length * Math.PI * 2
                      , i = (e + 1) / a.length * Math.PI * 2
                      , r = a[e];
                    let l;
                    l = e + 1 < a.length ? a[e + 1] : a[0];
                    for (let e = 0; e < r.length - 1; ++e) {
                        const a = n + 100 * e
                          , c = n + 100 * (e + 1);
                        o.push(Math.cos(t) * a, r[e] * s, Math.sin(t) * a),
                        o.push(Math.cos(i) * a, l[e] * s, Math.sin(i) * a),
                        o.push(Math.cos(i) * c, l[e + 1] * s, Math.sin(i) * c),
                        o.push(Math.cos(t) * a, r[e] * s, Math.sin(t) * a),
                        o.push(Math.cos(i) * c, l[e + 1] * s, Math.sin(i) * c),
                        o.push(Math.cos(t) * c, r[e + 1] * s, Math.sin(t) * c)
                    }
                }
                return {
                    vertices: o,
                    offset: new ht(i.x,0,i.y)
                }
            }
            getMountainVertices() {
                if (null == rM(this, nM, "f"))
                    return [];
                const e = rM(this, nM, "f").geometry;
                if (!(e.attributes.position instanceof Dn))
                    throw "Vertices must use BufferAttribute";
                return Array.from(e.attributes.position.array)
            }
            getMountainOffset() {
                return null == rM(this, nM, "f") ? new ht : rM(this, nM, "f").position.clone()
            }
            raycast(e) {
                const t = e.intersectObject(rM(this, tM, "f"));
                if (t.length > 0)
                    return t[0];
                if (null != rM(this, nM, "f")) {
                    const t = e.intersectObject(rM(this, nM, "f"));
                    if (t.length > 0)
                        return t[0]
                }
                return null
            }
            update() {
                const e = new ht
                  , t = new ct
                  , n = new ht;
                rM(this, $S, "f").camera.matrix.decompose(e, t, n),
                rM(this, eM, "f").position.set(e.x, 0, e.z);
                const i = rM(this, $S, "f").getLightTarget();
                rM(this, tM, "f").position.set(i.x, 0, i.z),
                rM(this, tM, "f").visible = rM(this, tM, "f").position.manhattanDistanceTo(rM(this, eM, "f").position) < 8e3
            }
        }
        $S = new WeakMap,
        eM = new WeakMap,
        tM = new WeakMap,
        nM = new WeakMap;
        const sM = aM;
        var oM = n(828)
          , lM = {};
        lM.styleTagTransform = u(),
        lM.setAttributes = l(),
        lM.insert = s().bind(null, "head"),
        lM.domAPI = r(),
        lM.insertStyleElement = h();
        t()(oM.Z, lM);
        oM.Z && oM.Z.locals && oM.Z.locals;
        var cM = n(240)
          , hM = {};
        hM.styleTagTransform = u(),
        hM.setAttributes = l(),
        hM.insert = s().bind(null, "head"),
        hM.domAPI = r(),
        hM.insertStyleElement = h();
        t()(cM.Z, hM);
        cM.Z && cM.Z.locals && cM.Z.locals;
        var dM, uM, pM = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, fM = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        dM = new WeakMap,
        uM = new WeakMap;
        const mM = class {
            constructor(e, t, n) {
                dM.set(this, void 0),
                uM.set(this, void 0),
                pM(this, dM, e, "f"),
                pM(this, uM, document.createElement("div"), "f"),
                fM(this, uM, "f").className = "loading",
                e.appendChild(fM(this, uM, "f"));
                const i = document.createElement("p");
                i.textContent = t.get("Loading") + "...",
                fM(this, uM, "f").appendChild(i);
                const r = document.createElement("div");
                fM(this, uM, "f").appendChild(r);
                const a = document.createElement("div");
                r.appendChild(a);
                const s = document.createElement("div");
                a.appendChild(s),
                n.addProgressListener((e=>{
                    s.style.width = 100 * e + "%"
                }
                ))
            }
            dispose() {
                fM(this, dM, "f").removeChild(fM(this, uM, "f"))
            }
        }
        ;
        var gM = n(156)
          , vM = {};
        vM.styleTagTransform = u(),
        vM.setAttributes = l(),
        vM.insert = s().bind(null, "head"),
        vM.domAPI = r(),
        vM.insertStyleElement = h();
        t()(gM.Z, vM);
        gM.Z && gM.Z.locals && gM.Z.locals;
        var wM, yM, _M, xM, bM, EM, SM, MM, TM, kM, CM, AM, PM, RM, LM, IM, NM, UM, DM, BM, OM = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, zM = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        yM = new WeakMap,
        _M = new WeakMap,
        xM = new WeakMap,
        bM = new WeakMap,
        EM = new WeakMap,
        SM = new WeakMap,
        MM = new WeakMap,
        TM = new WeakMap,
        kM = new WeakMap,
        CM = new WeakMap,
        AM = new WeakMap,
        PM = new WeakMap,
        wM = new WeakSet,
        RM = function() {
            zM(this, MM, "f").className = "hidden"
        }
        ,
        LM = function() {
            zM(this, MM, "f").className = "settings-menu"
        }
        ,
        IM = function() {
            zM(this, TM, "f").innerHTML = "",
            zM(this, wM, "m", NM).call(this, zM(this, _M, "f").get("Gameplay")),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Units"), [{
                title: zM(this, _M, "f").get("Metric"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Imperial"),
                value: "true"
            }], uc.ImperialUnitsEnabled),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Reset hint"), [{
                title: zM(this, _M, "f").get("Disabled"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Enabled"),
                value: "true"
            }], uc.ResetHintEnabled),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Ghost car"), [{
                title: zM(this, _M, "f").get("Disabled"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Enabled"),
                value: "true"
            }], uc.GhostCarEnabled),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Cockpit camera mode"), [{
                title: zM(this, _M, "f").get("Hold"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Toggle"),
                value: "true"
            }], uc.CockpitCameraToggle),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Checkpoints position"), [{
                title: zM(this, _M, "f").get("Bottom"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Top"),
                value: "true"
            }], uc.CheckpointsPosition),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Timer position"), [{
                title: zM(this, _M, "f").get("Bottom"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Top"),
                value: "true"
            }], uc.TimerPosition),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Speedometer position"), [{
                title: zM(this, _M, "f").get("Bottom"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("Top"),
                value: "true"
            }], uc.SpeedometerPosition),
            zM(this, wM, "m", NM).call(this, zM(this, _M, "f").get("Language")),
            zM(this, wM, "m", UM).call(this, null, [{
                title: "",
                value: "ar"
            }, {
                title: "Deutsch",
                value: "de-DE"
            }, {
                title: "English",
                value: "en-US"
            }, {
                title: "Espaol",
                value: "es-ES"
            }, {
                title: "Franais",
                value: "fr-FR"
            }, {
                title: "Italiano",
                value: "it-IT"
            }, {
                title: "",
                value: "ja-JP"
            }, {
                title: "",
                value: "ko-KR"
            }, {
                title: "Polski",
                value: "pl-PL"
            }, {
                title: "Portugus (BR)",
                value: "pt-BR"
            }, {
                title: "Portugus (PT)",
                value: "pt-PT"
            }, {
                title: "",
                value: "ru-RU"
            }, {
                title: "Trke",
                value: "tr-TR"
            }, {
                title: "",
                value: "uk-UA"
            }, {
                title: "",
                value: "zh-CN"
            }, {
                title: "",
                value: "zh-TW"
            }], uc.Language),
            zM(this, wM, "m", NM).call(this, zM(this, _M, "f").get("Graphics")),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Car shadow"), [{
                title: zM(this, _M, "f").get("Off"),
                value: "0"
            }, {
                title: zM(this, _M, "f").get("Low"),
                value: "1024"
            }, {
                title: zM(this, _M, "f").get("Medium"),
                value: "2048"
            }, {
                title: zM(this, _M, "f").get("High"),
                value: "4096"
            }], uc.CarShadowQuality),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Track shadow"), [{
                title: zM(this, _M, "f").get("Off"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("On"),
                value: "true"
            }], uc.TrackShadowEnabled, (()=>{
                zM(this, EM, "f").generateMeshes()
            }
            )),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Clouds"), [{
                title: zM(this, _M, "f").get("Off"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("On"),
                value: "true"
            }], uc.CloudsEnabled),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Particles"), [{
                title: zM(this, _M, "f").get("Off"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("On"),
                value: "true"
            }], uc.ParticlesEnabled),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Skidmarks"), [{
                title: zM(this, _M, "f").get("Off"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("On"),
                value: "true"
            }], uc.SkidmarksEnabled),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Render scale"), [{
                title: "25%",
                value: "0.25"
            }, {
                title: "50%",
                value: "0.5"
            }, {
                title: "100%",
                value: "1"
            }, {
                title: "150%",
                value: "1.5"
            }, {
                title: "200%",
                value: "2"
            }], uc.RenderScale),
            zM(this, wM, "m", UM).call(this, zM(this, _M, "f").get("Anti-aliasing (requires restart)"), [{
                title: zM(this, _M, "f").get("Off"),
                value: "false"
            }, {
                title: zM(this, _M, "f").get("On"),
                value: "true"
            }], uc.Antialiasing),
            zM(this, wM, "m", NM).call(this, zM(this, _M, "f").get("Audio")),
            zM(this, wM, "m", DM).call(this, zM(this, _M, "f").get("Sound effect volume"), uc.SoundEffectVolume),
            zM(this, wM, "m", DM).call(this, zM(this, _M, "f").get("Music volume"), uc.MusicVolume),
            zM(this, wM, "m", DM).call(this, zM(this, _M, "f").get("Checkpoint volume"), uc.CheckpointVolume),
            zM(this, wM, "m", NM).call(this, zM(this, _M, "f").get("Controls")),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Vehicle accelerate"), Xw.VehicleAccelerate),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Vehicle brake"), Xw.VehicleBrake),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Vehicle turn left"), Xw.VehicleTurnLeft),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Vehicle turn right"), Xw.VehicleTurnRight),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Vehicle reset"), Xw.VehicleReset),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Vehicle cockpit camera"), Xw.VehicleCockpitCamera),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Hide UI"), Xw.ToggleUI),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor rotate part"), Xw.EditorRotate),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor height modifier"), Xw.EditorHeightModifier),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor delete part"), Xw.EditorDelete),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor forwards"), Xw.EditorMoveForwards),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor backwards"), Xw.EditorMoveBackwards),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor left"), Xw.EditorMoveLeft),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor right"), Xw.EditorMoveRight),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor rotate left"), Xw.EditorRotateLeft),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor rotate right"), Xw.EditorRotateRight),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor move down"), Xw.EditorMoveDown),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor move up"), Xw.EditorMoveUp),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor test"), Xw.EditorTest),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Editor pick"), Xw.EditorPick),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Toggle FPS counter"), Xw.ToggleFpsCounter),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Toggle spectator camera"), Xw.ToggleSpectatorCamera),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Spectator forwards"), Xw.SpectatorMoveForwards),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Spectator backwards"), Xw.SpectatorMoveBackwards),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Spectator left"), Xw.SpectatorMoveLeft),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Spectator right"), Xw.SpectatorMoveRight),
            zM(this, wM, "m", BM).call(this, zM(this, _M, "f").get("Spectator speed modifier"), Xw.SpectatorSpeedModifier)
        }
        ,
        NM = function(e) {
            const t = document.createElement("h2");
            t.textContent = e,
            zM(this, TM, "f").appendChild(t)
        }
        ,
        UM = function(e, t, n, i) {
            var r;
            const a = null !== (r = zM(this, AM, "f").get(n)) && void 0 !== r ? r : zM(this, bM, "f").getSetting(n)
              , s = document.createElement("div");
            if (s.className = "setting",
            null != e) {
                const t = document.createElement("p");
                t.textContent = e,
                s.appendChild(t)
            } else
                s.classList.add("wrappable");
            const o = document.createElement("div");
            o.className = "button-wrapper",
            s.appendChild(o);
            const l = [];
            t.forEach((({title: e, value: t})=>{
                const r = document.createElement("button");
                r.className = t == a ? "button selected" : "button",
                r.textContent = e,
                r.addEventListener("click", (()=>{
                    zM(this, xM, "f").playUIClick(),
                    l.forEach((e=>{
                        e.className = "button"
                    }
                    )),
                    r.className = "button selected",
                    zM(this, AM, "f").set(n, t),
                    zM(this, bM, "f").updateSettings(Array.from(zM(this, AM, "f"))),
                    null != i && i()
                }
                )),
                o.appendChild(r),
                l.push(r)
            }
            )),
            zM(this, TM, "f").appendChild(s)
        }
        ,
        DM = function(e, t, n=0, i=1) {
            var r;
            let a = parseFloat(null !== (r = zM(this, AM, "f").get(t)) && void 0 !== r ? r : zM(this, bM, "f").getSetting(t));
            Number.isNaN(a) && (a = 0);
            const s = document.createElement("div");
            s.className = "setting";
            const o = document.createElement("p");
            o.textContent = e,
            s.appendChild(o);
            const l = document.createElement("input");
            l.type = "range",
            l.min = (20 * n).toString(),
            l.max = (20 * i).toString(),
            l.value = (20 * a).toString(),
            l.addEventListener("input", (()=>{
                const e = parseFloat(l.value) / 20;
                zM(this, AM, "f").set(t, e.toString()),
                zM(this, bM, "f").updateSettings(Array.from(zM(this, AM, "f")))
            }
            )),
            s.appendChild(l),
            zM(this, TM, "f").appendChild(s)
        }
        ,
        BM = function(e, t) {
            var n, i, r;
            const a = document.createElement("div");
            a.className = "setting";
            const s = document.createElement("p");
            s.textContent = e,
            a.appendChild(s);
            const o = document.createElement("div");
            o.className = "button-wrapper",
            a.appendChild(o);
            const l = null !== (n = zM(this, PM, "f").get(t)) && void 0 !== n ? n : zM(this, bM, "f").getKeyBindings(t)
              , c = document.createElement("button");
            c.className = "button key-binding",
            c.textContent = null !== (i = l[0]) && void 0 !== i ? i : "",
            c.addEventListener("click", (()=>{
                zM(this, xM, "f").playUIClick(),
                zM(this, wM, "m", RM).call(this);
                const e = t=>{
                    "Escape" == t.code || "Tab" == t.code || "Enter" == t.code && null != document.activeElement && document.activeElement != document.body || (zM(this, SM, "f").hide(),
                    l[0] = t.code,
                    c.textContent = t.code,
                    zM(this, wM, "m", LM).call(this),
                    window.removeEventListener("keydown", e),
                    t.preventDefault())
                }
                ;
                window.addEventListener("keydown", e),
                zM(this, SM, "f").showConfirm(zM(this, _M, "f").get("Press any key...\n\nPress [Escape] to cancel."), zM(this, _M, "f").get("Cancel"), zM(this, _M, "f").get("Clear"), (()=>{
                    zM(this, wM, "m", LM).call(this),
                    window.removeEventListener("keydown", e)
                }
                ), (()=>{
                    c.textContent = "",
                    l[0] = null,
                    window.removeEventListener("keydown", e),
                    zM(this, wM, "m", LM).call(this)
                }
                ))
            }
            )),
            o.appendChild(c);
            const h = document.createElement("button");
            h.className = "button key-binding",
            h.textContent = null !== (r = l[1]) && void 0 !== r ? r : "",
            h.addEventListener("click", (()=>{
                zM(this, xM, "f").playUIClick(),
                zM(this, wM, "m", RM).call(this);
                const e = t=>{
                    "Escape" == t.code || "Tab" == t.code || "Enter" == t.code && null != document.activeElement && document.activeElement != document.body || (zM(this, SM, "f").hide(),
                    l[1] = t.code,
                    h.textContent = t.code,
                    zM(this, wM, "m", LM).call(this),
                    window.removeEventListener("keydown", e),
                    t.preventDefault())
                }
                ;
                window.addEventListener("keydown", e),
                zM(this, SM, "f").showConfirm(zM(this, _M, "f").get("Press any key...\n\nPress [Escape] to cancel."), zM(this, _M, "f").get("Cancel"), zM(this, _M, "f").get("Clear"), (()=>{
                    zM(this, wM, "m", LM).call(this),
                    window.removeEventListener("keydown", e)
                }
                ), (()=>{
                    h.textContent = "",
                    l[1] = null,
                    window.removeEventListener("keydown", e),
                    zM(this, wM, "m", LM).call(this)
                }
                ))
            }
            )),
            o.appendChild(h),
            zM(this, TM, "f").appendChild(a)
        }
        ;
        const FM = class {
            constructor(e, t, n, i, r, a, s) {
                wM.add(this),
                yM.set(this, void 0),
                _M.set(this, void 0),
                xM.set(this, void 0),
                bM.set(this, void 0),
                EM.set(this, void 0),
                SM.set(this, void 0),
                MM.set(this, void 0),
                TM.set(this, void 0),
                kM.set(this, void 0),
                CM.set(this, new Map),
                AM.set(this, new Map),
                PM.set(this, new Map),
                OM(this, yM, e, "f"),
                OM(this, _M, t, "f"),
                OM(this, xM, n, "f"),
                OM(this, bM, i, "f"),
                OM(this, EM, r, "f"),
                OM(this, SM, a, "f"),
                OM(this, MM, document.createElement("div"), "f"),
                zM(this, MM, "f").className = "settings-menu",
                e.appendChild(zM(this, MM, "f"));
                const o = document.createElement("h2");
                o.textContent = t.get("Settings"),
                zM(this, MM, "f").appendChild(o),
                OM(this, TM, document.createElement("div"), "f"),
                zM(this, TM, "f").className = "container",
                zM(this, MM, "f").appendChild(zM(this, TM, "f")),
                OM(this, CM, new Map(i.getSettings()), "f"),
                zM(this, wM, "m", IM).call(this);
                const l = document.createElement("div");
                l.className = "button-wrapper",
                zM(this, MM, "f").appendChild(l);
                const c = document.createElement("button");
                c.className = "button cancel",
                c.innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
                c.append(document.createTextNode(t.get("Cancel"))),
                c.addEventListener("click", (()=>{
                    n.playUIClick(),
                    i.updateSettings(Array.from(zM(this, CM, "f"))),
                    r.generateMeshes(),
                    s()
                }
                )),
                l.appendChild(c);
                const h = document.createElement("button");
                h.className = "button reset",
                h.innerHTML = '<img class="button-icon" src="images/reset_settings.svg"> ',
                h.append(document.createTextNode(t.get("Reset"))),
                h.addEventListener("click", (()=>{
                    n.playUIClick(),
                    OM(this, AM, zM(this, bM, "f").defaultSettings(), "f"),
                    i.updateSettings(Array.from(zM(this, AM, "f"))),
                    OM(this, PM, zM(this, bM, "f").defaultKeyBindings(), "f"),
                    r.generateMeshes(),
                    zM(this, wM, "m", IM).call(this)
                }
                )),
                l.appendChild(h);
                const d = document.createElement("button");
                d.className = "button apply",
                d.append(document.createTextNode(t.get("Apply"))),
                d.innerHTML += ' <img class="button-icon" src="images/apply.svg">',
                d.addEventListener("click", (()=>{
                    n.playUIClick(),
                    i.updateSettings(Array.from(zM(this, AM, "f"))),
                    i.saveSettings(),
                    i.setKeyBindings(Array.from(zM(this, PM, "f"))),
                    r.generateMeshes(),
                    t.language = i.getSetting(uc.Language),
                    s()
                }
                )),
                l.appendChild(d),
                window.addEventListener("keydown", OM(this, kM, (e=>{
                    "Escape" == e.code && (s(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                zM(this, yM, "f").removeChild(zM(this, MM, "f")),
                window.removeEventListener("keydown", zM(this, kM, "f"))
            }
        }
        ;
        var WM = n(421)
          , HM = {};
        HM.styleTagTransform = u(),
        HM.setAttributes = l(),
        HM.insert = s().bind(null, "head"),
        HM.domAPI = r(),
        HM.insertStyleElement = h();
        t()(WM.Z, HM);
        WM.Z && WM.Z.locals && WM.Z.locals;
        var VM = n(937)
          , GM = {};
        GM.styleTagTransform = u(),
        GM.setAttributes = l(),
        GM.insert = s().bind(null, "head"),
        GM.domAPI = r(),
        GM.insertStyleElement = h();
        t()(VM.Z, GM);
        VM.Z && VM.Z.locals && VM.Z.locals;
        var jM = n(50)
          , XM = {};
        XM.styleTagTransform = u(),
        XM.setAttributes = l(),
        XM.insert = s().bind(null, "head"),
        XM.domAPI = r(),
        XM.insertStyleElement = h();
        t()(jM.Z, XM);
        jM.Z && jM.Z.locals && jM.Z.locals;
        let qM = null
          , YM = null
          , ZM = null
          , KM = null;
        function JM(e) {
            return null != qM && null != YM && null != ZM && null != KM || (YM = document.createElement("canvas"),
            YM.width = 100,
            YM.height = 100,
            ZM = new jS(YM,null,!1,!0),
            KM = new ji(-1,1,1,-1,.1,1e4),
            KM.position.set(1e3, 1e3, 1e3),
            KM.lookAt(0, 0, 0),
            KM.zoom = .5,
            KM.position.add(new ht(.1,.3,0)),
            KM.updateProjectionMatrix(),
            ZM.scene.add(KM),
            ZM.setCamera(KM),
            qM = new Jm(null,{
                position: new ht,
                quaternion: new ct
            },null,null,!1,ZM,null,null,null,null),
            qM.update(0)),
            qM.setColors(e),
            ZM.update(new ht),
            YM.toDataURL()
        }
        var QM, $M, eT, tT, nT, iT, rT, aT, sT, oT, lT, cT, hT, dT, uT, pT, fT, mT, gT, vT, wT, yT, _T, xT, bT, ET, ST, MT, TT = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, kT = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class CT {
            constructor(e, t, n, i, r, a, s, o, l, c, h) {
                QM.add(this),
                eT.set(this, void 0),
                tT.set(this, void 0),
                nT.set(this, void 0),
                iT.set(this, void 0),
                rT.set(this, void 0),
                aT.set(this, void 0),
                sT.set(this, void 0),
                oT.set(this, void 0),
                lT.set(this, void 0),
                cT.set(this, void 0),
                hT.set(this, void 0),
                dT.set(this, void 0),
                uT.set(this, void 0),
                pT.set(this, void 0),
                fT.set(this, void 0),
                mT.set(this, void 0),
                gT.set(this, null),
                vT.set(this, !1),
                wT.set(this, !1),
                yT.set(this, 0),
                _T.set(this, 0),
                xT.set(this, null),
                bT.set(this, null),
                TT(this, eT, t, "f"),
                TT(this, tT, n, "f"),
                TT(this, nT, i, "f"),
                TT(this, iT, r, "f"),
                TT(this, rT, a, "f"),
                TT(this, aT, s, "f"),
                TT(this, sT, l, "f"),
                TT(this, oT, c, "f"),
                TT(this, lT, h, "f"),
                TT(this, cT, e, "f"),
                TT(this, hT, document.createElement("div"), "f"),
                kT(this, hT, "f").className = "leaderboard",
                e.appendChild(kT(this, hT, "f"));
                const d = document.createElement("h2");
                d.textContent = n.get("Leaderboard"),
                kT(this, hT, "f").appendChild(d),
                TT(this, dT, document.createElement("div"), "f"),
                kT(this, dT, "f").className = "container",
                kT(this, hT, "f").appendChild(kT(this, dT, "f")),
                TT(this, uT, document.createElement("div"), "f"),
                kT(this, uT, "f").className = "loading-spinner",
                kT(this, dT, "f").appendChild(kT(this, uT, "f")),
                kT(this, QM, "m", ET).call(this, !1),
                TT(this, mT, document.createElement("div"), "f"),
                kT(this, mT, "f").className = "pages",
                kT(this, hT, "f").appendChild(kT(this, mT, "f")),
                kT(this, QM, "m", MT).call(this);
                const u = document.createElement("div");
                u.className = "button-wrapper",
                kT(this, hT, "f").appendChild(u);
                const p = document.createElement("button");
                p.className = "button back",
                p.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                p.append(document.createTextNode(n.get("Back"))),
                p.addEventListener("click", (()=>{
                    r.playUIClick(),
                    o()
                }
                )),
                u.appendChild(p),
                TT(this, pT, document.createElement("button"), "f"),
                kT(this, pT, "f").className = "button icon-button first",
                kT(this, pT, "f").innerHTML = '<img class="button-icon" src="images/pin.svg">',
                kT(this, pT, "f").disabled = !0,
                kT(this, pT, "f").addEventListener("click", (()=>{
                    r.playUIClick(),
                    null != kT(this, bT, "f") ? kT(this, bT, "f").scrollIntoView({
                        behavior: "smooth"
                    }) : null != kT(this, xT, "f") && (TT(this, yT, kT(this, xT, "f"), "f"),
                    kT(this, QM, "m", MT).call(this),
                    kT(this, QM, "m", ET).call(this, !0))
                }
                )),
                u.appendChild(kT(this, pT, "f")),
                TT(this, fT, document.createElement("button"), "f"),
                kT(this, fT, "f").className = "button icon-button disabled",
                kT(this, fT, "f").innerHTML = '<img class="button-icon" src="images/verified.svg">',
                kT(this, fT, "f").addEventListener("click", (()=>{
                    r.playUIClick(),
                    TT(this, wT, !kT(this, wT, "f"), "f"),
                    kT(this, wT, "f") ? kT(this, fT, "f").classList.remove("disabled") : kT(this, fT, "f").classList.add("disabled"),
                    kT(this, QM, "m", ET).call(this, !1)
                }
                )),
                u.appendChild(kT(this, fT, "f"))
            }
            dispose() {
                kT(this, cT, "f").removeChild(kT(this, hT, "f"))
            }
            static getPositionSuffix(e) {
                if (e <= 0 || !Number.isInteger(e))
                    throw "Position must be a positive integer.";
                const t = e % 100;
                if (t >= 11 && t <= 13)
                    return "th";
                switch (e % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th"
                }
            }
        }
        $M = CT,
        eT = new WeakMap,
        tT = new WeakMap,
        nT = new WeakMap,
        iT = new WeakMap,
        rT = new WeakMap,
        aT = new WeakMap,
        sT = new WeakMap,
        oT = new WeakMap,
        lT = new WeakMap,
        cT = new WeakMap,
        hT = new WeakMap,
        dT = new WeakMap,
        uT = new WeakMap,
        pT = new WeakMap,
        fT = new WeakMap,
        mT = new WeakMap,
        gT = new WeakMap,
        vT = new WeakMap,
        wT = new WeakMap,
        yT = new WeakMap,
        _T = new WeakMap,
        xT = new WeakMap,
        bT = new WeakMap,
        QM = new WeakSet,
        ET = function e(t) {
            null != kT(this, gT, "f") && (kT(this, gT, "f").isCancelled = !0);
            const n = {
                isCancelled: !1
            };
            TT(this, gT, n, "f"),
            kT(this, dT, "f").innerHTML = "",
            kT(this, dT, "f").appendChild(kT(this, uT, "f")),
            TT(this, bT, null, "f"),
            setTimeout((()=>{
                if (!n.isCancelled) {
                    const i = 20
                      , r = kT(this, yT, "f") * i;
                    kT(this, nT, "f").getLeaderboard(kT(this, eT, "f"), r, i, kT(this, wT, "f")).then((({total: a, entries: s, userEntry: o})=>{
                        if (!n.isCancelled && (TT(this, _T, Math.ceil(a / i), "f"),
                        kT(this, QM, "m", MT).call(this),
                        s.forEach((({id: e, name: t, time: n, carColors: i, verifiedState: a, isSelf: s},o)=>{
                            const l = r + o + 1;
                            kT(this, QM, "m", ST).call(this, l, t, n, i, a, s, e)
                        }
                        )),
                        null != o ? (TT(this, xT, Math.floor((o.position - 1) / i), "f"),
                        kT(this, pT, "f").disabled = !1,
                        t && null != kT(this, bT, "f") && kT(this, bT, "f").scrollIntoView(),
                        kT(this, lT, "f").call(this, o)) : (TT(this, xT, null, "f"),
                        kT(this, pT, "f").disabled = !0,
                        kT(this, lT, "f").call(this, null)),
                        !kT(this, vT, "f"))) {
                            TT(this, vT, !0, "f");
                            let n = null;
                            null != o && (n = {
                                time: o.time,
                                recordingId: o.id
                            }),
                            kT(this, aT, "f").syncRecord(kT(this, rT, "f").profileSlot, kT(this, eT, "f"), n, kT(this, rT, "f").getCarColors()).then((n=>{
                                "Upload" == n && kT(this, QM, "m", e).call(this, t)
                            }
                            ))
                        }
                    }
                    )).catch((e=>{
                        if (!n.isCancelled) {
                            const e = document.createElement("p");
                            e.className = "error-message",
                            e.textContent = kT(this, tT, "f").get("Error: Failed to load leaderboard"),
                            kT(this, dT, "f").appendChild(e)
                        }
                        console.error(e)
                    }
                    )).finally((()=>{
                        n.isCancelled || kT(this, dT, "f").removeChild(kT(this, uT, "f"))
                    }
                    ))
                }
            }
            ), 500)
        }
        ,
        ST = function(e, t, n, i, r, a, s) {
            const o = document.createElement("div");
            o.className = "buttons",
            kT(this, dT, "f").appendChild(o);
            const l = document.createElement("button");
            a ? (TT(this, bT, l, "f"),
            l.className = "button main",
            l.disabled = !0) : (l.className = "button main",
            l.addEventListener("click", (()=>{
                kT(this, iT, "f").playUIClick(),
                kT(this, sT, "f").call(this, new Promise(((e,i)=>{
                    kT(this, nT, "f").getRecording(s).then((({recording: i, carColors: r})=>{
                        e({
                            recording: i,
                            carColors: r,
                            name: t,
                            time: n,
                            isSelf: !1
                        })
                    }
                    )).catch(i)
                }
                )))
            }
            ))),
            o.appendChild(l);
            const c = document.createElement("button");
            c.className = "button preview",
            c.innerHTML = '<img src="images/preview.svg">',
            c.addEventListener("click", (()=>{
                kT(this, iT, "f").playUIClick(),
                kT(this, oT, "f").call(this, new Promise(((e,i)=>{
                    kT(this, nT, "f").getRecording(s).then((({recording: i, carColors: r})=>{
                        e({
                            recording: i,
                            carColors: r,
                            name: t,
                            time: n
                        })
                    }
                    )).catch(i)
                }
                )))
            }
            )),
            o.appendChild(c);
            const h = document.createElement("img");
            h.src = JM(i),
            l.appendChild(h);
            const d = document.createElement("div");
            d.className = "left",
            l.appendChild(d);
            const u = document.createElement("p");
            u.textContent = e + $M.getPositionSuffix(e),
            d.appendChild(u);
            const p = document.createElement("p");
            p.textContent = xy.formatTimeString(n),
            d.appendChild(p);
            const f = document.createElement("div");
            f.className = "right",
            l.appendChild(f);
            const m = document.createElement("p");
            m.className = "name",
            m.textContent = t,
            f.appendChild(m);
            const g = document.createElement("p");
            1 == r ? (g.innerHTML = '<img src="images/state_verified.svg">',
            g.prepend(document.createTextNode(kT(this, tT, "f").get("Verified"))),
            g.className = "verified-state verified") : 0 == r ? (g.innerHTML = '<img src="images/state_invalid.svg">',
            g.prepend(document.createTextNode(kT(this, tT, "f").get("Invalid"))),
            g.className = "verified-state invalid") : (g.innerHTML = '<img src="images/state_pending.svg">',
            g.prepend(document.createTextNode(kT(this, tT, "f").get("Pending"))),
            g.className = "verified-state pending"),
            f.appendChild(g)
        }
        ,
        MT = function e() {
            kT(this, mT, "f").innerHTML = "";
            const t = document.createElement("button");
            t.className = "button",
            t.textContent = "<",
            kT(this, yT, "f") > 0 ? t.addEventListener("click", (()=>{
                kT(this, iT, "f").playUIClick(),
                TT(this, yT, kT(this, yT, "f") - 1, "f"),
                kT(this, QM, "m", e).call(this),
                kT(this, QM, "m", ET).call(this, !1)
            }
            )) : t.disabled = !0,
            kT(this, mT, "f").appendChild(t);
            const n = Math.max(0, kT(this, yT, "f") - Math.floor(3.5));
            for (let t = n; t < n + 7; ++t) {
                const n = document.createElement("button");
                n.textContent = (t + 1).toString(),
                t >= kT(this, _T, "f") ? (n.className = "button page",
                n.disabled = !0) : t == kT(this, yT, "f") ? n.className = "button page selected" : (n.className = "button page",
                n.addEventListener("click", (()=>{
                    kT(this, iT, "f").playUIClick(),
                    TT(this, yT, t, "f"),
                    kT(this, QM, "m", e).call(this),
                    kT(this, QM, "m", ET).call(this, !1)
                }
                ))),
                kT(this, mT, "f").appendChild(n)
            }
            const i = document.createElement("button");
            i.className = "button",
            i.textContent = ">",
            kT(this, yT, "f") + 1 >= kT(this, _T, "f") ? i.disabled = !0 : i.addEventListener("click", (()=>{
                kT(this, iT, "f").playUIClick(),
                TT(this, yT, kT(this, yT, "f") + 1, "f"),
                kT(this, QM, "m", e).call(this),
                kT(this, QM, "m", ET).call(this, !1)
            }
            )),
            kT(this, mT, "f").appendChild(i)
        }
        ;
        const AT = CT;
        var PT, RT, LT, IT, NT, UT, DT = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, BT = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        PT = new WeakMap,
        RT = new WeakMap,
        LT = new WeakMap,
        IT = new WeakMap,
        NT = new WeakMap,
        UT = new WeakMap;
        const OT = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u) {
                var p;
                PT.set(this, void 0),
                RT.set(this, void 0),
                LT.set(this, void 0),
                IT.set(this, void 0),
                NT.set(this, void 0),
                UT.set(this, void 0),
                DT(this, PT, e, "f"),
                DT(this, RT, u, "f"),
                DT(this, LT, document.createElement("div"), "f"),
                BT(this, LT, "f").className = "track-info",
                e.appendChild(BT(this, LT, "f"));
                const f = r.getRecord(i.profileSlot, o);
                DT(this, NT, new AT(BT(this, LT, "f"),o,t,n,a,i,r,c,h,d,(e=>{
                    null == e || null != f && !e.time.lessOrEqual(f.time) ? w.textContent = t.get("Rank") + ": ---" : (v.textContent = t.get("Record") + ": " + xy.formatTimeString(e.time),
                    w.textContent = t.get("Rank") + ": " + e.position + AT.getPositionSuffix(e.position))
                }
                )), "f"),
                DT(this, IT, document.createElement("div"), "f"),
                BT(this, IT, "f").className = "side-panel",
                BT(this, LT, "f").appendChild(BT(this, IT, "f"));
                const m = document.createElement("h2");
                m.textContent = s,
                BT(this, IT, "f").appendChild(m);
                const g = document.createElement("div");
                g.className = "thumbnail",
                g.appendChild(l),
                BT(this, IT, "f").appendChild(g);
                const v = document.createElement("p");
                v.textContent = t.get("Record") + ": " + xy.formatTimeString(null !== (p = null == f ? void 0 : f.time) && void 0 !== p ? p : null),
                BT(this, IT, "f").appendChild(v);
                const w = document.createElement("p");
                BT(this, IT, "f").appendChild(w);
                const y = document.createElement("button");
                y.className = "button play",
                y.innerHTML = '<img src="images/play.svg">',
                y.prepend(document.createTextNode(t.get("Play"))),
                y.addEventListener("click", (()=>{
                    var e, t;
                    a.playUIClick(),
                    BT(this, RT, "f").call(this, {
                        recording: null !== (e = null == f ? void 0 : f.recording) && void 0 !== e ? e : null,
                        carColors: null,
                        name: null,
                        time: null !== (t = null == f ? void 0 : f.time) && void 0 !== t ? t : null,
                        isSelf: !0
                    })
                }
                )),
                BT(this, IT, "f").appendChild(y),
                window.addEventListener("keydown", DT(this, UT, (e=>{
                    "Escape" == e.code && (c(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                BT(this, NT, "f").dispose(),
                BT(this, PT, "f").removeChild(BT(this, LT, "f")),
                window.removeEventListener("keydown", BT(this, UT, "f"))
            }
        }
        ;
        var zT = n(493)
          , FT = {};
        FT.styleTagTransform = u(),
        FT.setAttributes = l(),
        FT.insert = s().bind(null, "head"),
        FT.domAPI = r(),
        FT.insertStyleElement = h();
        t()(zT.Z, FT);
        zT.Z && zT.Z.locals && zT.Z.locals;
        var WT, HT, VT, GT, jT, XT, qT, YT, ZT = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, KT = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        HT = new WeakMap,
        VT = new WeakMap,
        GT = new WeakMap,
        jT = new WeakMap,
        XT = new WeakMap,
        qT = new WeakMap,
        WT = new WeakSet,
        YT = function(e, t) {
            const n = KT(this, GT, "f").getUserProfile(e)
              , i = document.createElement("div");
            i.className = "slot";
            const r = document.createElement("button");
            if (r.className = "button main",
            e == KT(this, GT, "f").profileSlot && r.classList.add("selected"),
            r.addEventListener("click", (()=>{
                KT(this, VT, "f").playUIClick(),
                KT(this, XT, "f").forEach((e=>{
                    e.classList.remove("selected")
                }
                )),
                r.classList.add("selected"),
                t(e)
            }
            )),
            i.appendChild(r),
            KT(this, XT, "f").push(r),
            null != n) {
                const e = document.createElement("img");
                e.src = JM(n.carColors),
                r.appendChild(e);
                const t = document.createElement("p");
                t.className = "name",
                t.textContent = n.nickname,
                r.appendChild(t)
            }
            KT(this, jT, "f").appendChild(i)
        }
        ;
        const JT = class {
            constructor(e, t, n, i, r, a) {
                WT.add(this),
                HT.set(this, void 0),
                VT.set(this, void 0),
                GT.set(this, void 0),
                jT.set(this, void 0),
                XT.set(this, []),
                qT.set(this, void 0),
                ZT(this, HT, document.getElementById("ui"), "f"),
                ZT(this, VT, t, "f"),
                ZT(this, GT, n, "f"),
                ZT(this, jT, document.createElement("div"), "f"),
                KT(this, jT, "f").className = "profile-selection",
                KT(this, HT, "f").appendChild(KT(this, jT, "f"));
                const s = document.createElement("div");
                s.className = "top-bar",
                KT(this, jT, "f").appendChild(s);
                const o = document.createElement("h2");
                o.textContent = e.get("Profiles"),
                s.appendChild(o);
                for (let e = 0; e < 3; e++)
                    KT(this, WT, "m", YT).call(this, e, a);
                const l = document.createElement("div");
                l.className = "bottom-bar",
                KT(this, jT, "f").appendChild(l);
                const c = document.createElement("button");
                c.className = "button",
                c.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                c.append(document.createTextNode(e.get("Back"))),
                c.addEventListener("click", (()=>{
                    t.playUIClick(),
                    i()
                }
                )),
                l.appendChild(c);
                const h = document.createElement("button");
                h.className = "button right",
                h.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                h.append(document.createTextNode(e.get("Import"))),
                h.addEventListener("click", (()=>{
                    t.playUIClick(),
                    r()
                }
                )),
                l.appendChild(h),
                window.addEventListener("keydown", ZT(this, qT, (e=>{
                    "Escape" == e.code && (i(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                KT(this, HT, "f").removeChild(KT(this, jT, "f")),
                window.removeEventListener("keydown", KT(this, qT, "f"))
            }
        }
        ;
        var QT = n(853)
          , $T = {};
        $T.styleTagTransform = u(),
        $T.setAttributes = l(),
        $T.insert = s().bind(null, "head"),
        $T.domAPI = r(),
        $T.insertStyleElement = h();
        t()(QT.Z, $T);
        QT.Z && QT.Z.locals && QT.Z.locals;
        var ek, tk, nk, ik, rk, ak, sk, ok, lk, ck = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, hk = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        tk = new WeakMap,
        nk = new WeakMap,
        ik = new WeakMap,
        rk = new WeakMap,
        ak = new WeakMap,
        sk = new WeakMap,
        ok = new WeakMap,
        ek = new WeakSet,
        lk = function() {
            let e = hk(this, rk, "f").value;
            return /\S/.test(e) || (e = "Anonymous"),
            e
        }
        ;
        const dk = class {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                ek.add(this),
                tk.set(this, void 0),
                nk.set(this, !1),
                ik.set(this, void 0),
                rk.set(this, void 0),
                ak.set(this, null),
                sk.set(this, null),
                ok.set(this, void 0),
                ck(this, tk, document.getElementById("ui"), "f"),
                ck(this, ik, document.createElement("div"), "f"),
                hk(this, ik, "f").className = "nickname",
                hk(this, tk, "f").appendChild(hk(this, ik, "f"));
                const h = document.createElement("h1");
                h.textContent = e.get("Nickname"),
                hk(this, ik, "f").appendChild(h),
                ck(this, rk, document.createElement("input"), "f"),
                hk(this, rk, "f").type = "text",
                hk(this, rk, "f").placeholder = "Anonymous",
                hk(this, rk, "f").maxLength = 50,
                hk(this, rk, "f").spellcheck = !1,
                "Anonymous" != i && (hk(this, rk, "f").value = i),
                hk(this, ik, "f").appendChild(hk(this, rk, "f")),
                hk(this, rk, "f").focus(),
                hk(this, rk, "f").addEventListener("keydown", (e=>{
                    "Enter" == e.code && (l(hk(this, ek, "m", lk).call(this)),
                    e.preventDefault())
                }
                ));
                const d = document.createElement("p");
                d.textContent = e.get("Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time."),
                hk(this, ik, "f").appendChild(d);
                const u = document.createElement("button");
                u.className = "button delete",
                u.innerHTML = ' <img class="button-icon" src="images/delete.svg"> ',
                u.append(e.get("Delete")),
                u.addEventListener("click", (()=>{
                    t.playUIClick(),
                    s(hk(this, ek, "m", lk).call(this))
                }
                )),
                hk(this, ik, "f").appendChild(u);
                const p = document.createElement("button");
                p.className = "button",
                p.innerHTML = '<img class="button-icon" src="images/export.svg"> ',
                p.append(e.get("Export")),
                p.addEventListener("click", (()=>{
                    t.playUIClick(),
                    o(hk(this, ek, "m", lk).call(this))
                }
                )),
                hk(this, ik, "f").appendChild(p);
                const f = document.createElement("button");
                f.className = "button",
                f.textContent = e.get("Ok"),
                f.addEventListener("click", (()=>{
                    t.playUIClick(),
                    l(hk(this, ek, "m", lk).call(this))
                }
                )),
                hk(this, ik, "f").appendChild(f),
                n.getUser(r).then((n=>{
                    const i = 1 == (null == n ? void 0 : n.isVerifier);
                    !hk(this, nk, "f") && i && (ck(this, ak, document.createElement("button"), "f"),
                    hk(this, ak, "f").className = "button nickname-verifier-button",
                    hk(this, ak, "f").textContent = e.get("Verifier"),
                    hk(this, ak, "f").addEventListener("click", (()=>{
                        t.playUIClick(),
                        c()
                    }
                    )),
                    hk(this, tk, "f").appendChild(hk(this, ak, "f")))
                }
                )).catch((e=>{
                    console.error(e)
                }
                )),
                null != a && (ck(this, sk, document.createElement("p"), "f"),
                hk(this, sk, "f").className = "nickname-user-token",
                hk(this, sk, "f").textContent = e.get("User ID") + ": " + a,
                hk(this, tk, "f").appendChild(hk(this, sk, "f"))),
                window.addEventListener("keydown", ck(this, ok, (e=>{
                    "Escape" == e.code && (l(hk(this, ek, "m", lk).call(this)),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                hk(this, tk, "f").removeChild(hk(this, ik, "f")),
                null != hk(this, ak, "f") && hk(this, tk, "f").removeChild(hk(this, ak, "f")),
                null != hk(this, sk, "f") && hk(this, tk, "f").removeChild(hk(this, sk, "f")),
                window.removeEventListener("keydown", hk(this, ok, "f")),
                ck(this, nk, !0, "f")
            }
        }
        ;
        var uk = n(18)
          , pk = {};
        pk.styleTagTransform = u(),
        pk.setAttributes = l(),
        pk.insert = s().bind(null, "head"),
        pk.domAPI = r(),
        pk.insertStyleElement = h();
        t()(uk.Z, pk);
        uk.Z && uk.Z.locals && uk.Z.locals;
        var fk, mk, gk, vk = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, wk = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        fk = new WeakMap,
        mk = new WeakMap,
        gk = new WeakMap;
        const yk = class {
            constructor(e, t, n, i, r) {
                fk.set(this, void 0),
                mk.set(this, void 0),
                gk.set(this, void 0),
                vk(this, fk, document.getElementById("ui"), "f"),
                vk(this, mk, document.createElement("div"), "f"),
                wk(this, mk, "f").className = "user-export",
                wk(this, fk, "f").appendChild(wk(this, mk, "f"));
                const a = document.createElement("textarea");
                a.value = n,
                a.readOnly = null == r,
                a.placeholder = "Paste user token here...",
                wk(this, mk, "f").appendChild(a);
                const s = document.createElement("div");
                s.className = "bar",
                wk(this, mk, "f").appendChild(s);
                const o = document.createElement("button");
                if (o.className = "button",
                o.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                o.append(document.createTextNode(t.get("Back"))),
                o.addEventListener("click", (()=>{
                    e.playUIClick(),
                    i()
                }
                )),
                s.appendChild(o),
                null != r) {
                    const n = document.createElement("button");
                    n.className = "button right",
                    n.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                    n.append(document.createTextNode(t.get("Import"))),
                    n.addEventListener("click", (()=>{
                        e.playUIClick(),
                        r(a.value)
                    }
                    )),
                    s.appendChild(n)
                } else {
                    const n = document.createElement("button");
                    n.className = "button right",
                    n.innerHTML = '<img class="button-icon" src="images/copy.svg"> ',
                    n.append(document.createTextNode(t.get("Copy"))),
                    n.addEventListener("click", (()=>{
                        e.playUIClick();
                        try {
                            navigator.clipboard.writeText(a.value)
                        } catch (e) {
                            console.error(e)
                        }
                    }
                    )),
                    s.appendChild(n)
                }
                window.addEventListener("keydown", vk(this, gk, (e=>{
                    "Escape" == e.code && (i(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                wk(this, fk, "f").removeChild(wk(this, mk, "f")),
                window.removeEventListener("keydown", wk(this, gk, "f"))
            }
        }
          , _k = {
            i8: "0.4.0-beta"
        };
        var xk, bk, Ek, Sk, Mk, Tk, kk, Ck, Ak, Pk, Rk, Lk, Ik, Nk, Uk, Dk, Bk, Ok, zk, Fk, Wk, Hk, Vk, Gk, jk = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, Xk = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        bk = new WeakMap,
        Ek = new WeakMap,
        Sk = new WeakMap,
        Mk = new WeakMap,
        Tk = new WeakMap,
        kk = new WeakMap,
        Ck = new WeakMap,
        Ak = new WeakMap,
        Pk = new WeakMap,
        Rk = new WeakMap,
        Lk = new WeakMap,
        Ik = new WeakMap,
        Nk = new WeakMap,
        Uk = new WeakMap,
        Dk = new WeakMap,
        Bk = new WeakMap,
        Ok = new WeakMap,
        xk = new WeakSet,
        zk = function e(t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v) {
            Xk(this, Sk, "f").innerHTML = "",
            jk(this, Mk, document.createElement("img"), "f"),
            Xk(this, Mk, "f").src = "images/logo.svg",
            Xk(this, Mk, "f").className = "logo",
            Xk(this, Sk, "f").appendChild(Xk(this, Mk, "f")),
            jk(this, Ak, new Hy(Xk(this, Sk, "f"),t,n,o,l,h,a,s,u,!1,(()=>{
                Xk(this, Ak, "f").hide(),
                Xk(this, xk, "m", Wk).call(this),
                Xk(this, xk, "m", Vk).call(this)
            }
            ),((e,i,r,a)=>{
                if (e.hasStartingPoint()) {
                    Xk(this, Ak, "f").hide();
                    const l = ()=>{
                        var e;
                        Xk(this, Ak, "f").show(),
                        null === (e = Xk(this, Pk, "f")) || void 0 === e || e.dispose(),
                        jk(this, Pk, null, "f")
                    }
                      , h = t=>{
                        var n;
                        null === (n = Xk(this, Pk, "f")) || void 0 === n || n.dispose(),
                        jk(this, Pk, null, "f"),
                        m(i, e, t)
                    }
                      , d = f=>{
                        var g;
                        null === (g = Xk(this, Pk, "f")) || void 0 === g || g.dispose(),
                        jk(this, Pk, null, "f"),
                        f.then((t=>{
                            m(i, e, t)
                        }
                        )).catch((()=>{
                            u.show(t.get("Failed to load recording"), t.get("Ok"), (()=>{
                                jk(this, Pk, new OT(Xk(this, Sk, "f"),t,c,s,o,n,i,r,a,l,d,p,h), "f")
                            }
                            ))
                        }
                        ))
                    }
                      , p = f=>{
                        var m;
                        null === (m = Xk(this, Pk, "f")) || void 0 === m || m.dispose(),
                        jk(this, Pk, null, "f"),
                        f.then((t=>{
                            g(e, t)
                        }
                        )).catch((()=>{
                            u.show(t.get("Failed to load recording"), t.get("Ok"), (()=>{
                                jk(this, Pk, new OT(Xk(this, Sk, "f"),t,c,s,o,n,i,r,a,l,d,p,h), "f")
                            }
                            ))
                        }
                        ))
                    }
                    ;
                    jk(this, Pk, new OT(Xk(this, Sk, "f"),t,c,s,o,n,i,r,a,l,d,p,h), "f"),
                    Xk(this, xk, "m", Hk).call(this)
                } else
                    Xk(this, Ak, "f").hide(),
                    u.show(t.get("Track is missing starting point"), t.get("Ok"), (()=>{
                        Xk(this, Ak, "f").show()
                    }
                    ))
            }
            )), "f");
            const w = document.createElement("button");
            w.className = "hidden",
            w.innerHTML = '<img src="images/customize.svg">',
            w.addEventListener("click", (()=>{
                n.playUIClick(),
                p()
            }
            ));
            const y = document.createElement("p");
            y.textContent = t.get("Customize"),
            w.appendChild(y),
            Xk(this, Sk, "f").appendChild(w),
            Xk(this, Uk, "f").push(w);
            const _ = document.createElement("button");
            _.className = "hidden",
            _.innerHTML = '<img src="images/editor.svg">',
            _.addEventListener("click", (()=>{
                n.playUIClick(),
                f()
            }
            ));
            const x = document.createElement("p");
            x.textContent = t.get("Editor"),
            _.appendChild(x),
            Xk(this, Sk, "f").appendChild(_),
            Xk(this, Uk, "f").push(_);
            const b = document.createElement("button");
            b.className = "hidden",
            b.innerHTML = '<img src="images/settings.svg">',
            b.addEventListener("click", (()=>{
                n.playUIClick(),
                Xk(this, xk, "m", Fk).call(this),
                Xk(this, xk, "m", Hk).call(this),
                jk(this, Rk, new FM(Xk(this, Sk, "f"),t,n,d,r,u,(()=>{
                    var w;
                    null === (w = Xk(this, Rk, "f")) || void 0 === w || w.dispose(),
                    jk(this, Rk, null, "f"),
                    Xk(this, xk, "m", e).call(this, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v)
                }
                )), "f")
            }
            ));
            const E = document.createElement("p");
            E.textContent = t.get("Settings"),
            b.appendChild(E),
            Xk(this, Sk, "f").appendChild(b),
            Xk(this, Uk, "f").push(b);
            const S = document.createElement("button");
            S.className = "hidden",
            S.innerHTML = '<img src="images/helmet.svg">',
            S.addEventListener("click", (()=>{
                n.playUIClick(),
                Xk(this, xk, "m", Fk).call(this);
                const e = (i,a)=>{
                    jk(this, Nk, new yk(n,t,a,(()=>{
                        var e;
                        null === (e = Xk(this, Nk, "f")) || void 0 === e || e.dispose(),
                        jk(this, Nk, null, "f"),
                        r()
                    }
                    ),(n=>{
                        var a;
                        null === (a = Xk(this, Nk, "f")) || void 0 === a || a.dispose(),
                        jk(this, Nk, null, "f"),
                        s.hasDuplicateToken(n) ? u.show(t.get("You cannot have duplicate user profiles"), t.get("Ok"), (()=>{
                            e(i, n)
                        }
                        )) : s.isValidToken(n) ? c.getUser(n).then((a=>{
                            null != a ? s.createProfile(i, n, a.name, a.carColors) ? (s.setProfileSlot(i),
                            r()) : u.show(t.get("Failed to create user profile"), t.get("Ok"), (()=>{
                                e(i, n)
                            }
                            )) : u.show(t.get("This user profile does not exist on the server"), t.get("Ok"), (()=>{
                                e(i, n)
                            }
                            ))
                        }
                        )).catch((r=>{
                            console.error(r),
                            u.show(t.get("Failed to download user profile from the server"), t.get("Ok"), (()=>{
                                e(i, n)
                            }
                            ))
                        }
                        )) : u.show(t.get("User token is invalid"), t.get("Ok"), (()=>{
                            e(i, n)
                        }
                        ))
                    }
                    )), "f")
                }
                  , i = (e,a)=>{
                    var o;
                    null === (o = Xk(this, Lk, "f")) || void 0 === o || o.dispose(),
                    jk(this, Lk, null, "f"),
                    null != a || (a = s.getNickname(e)),
                    jk(this, Ik, new dk(t,n,c,a,s.getToken(e),s.getTokenHash(e),(n=>{
                        var a;
                        null === (a = Xk(this, Ik, "f")) || void 0 === a || a.dispose(),
                        jk(this, Ik, null, "f"),
                        u.showConfirm(t.get('Are you sure you would like to delete "{0}"?', [n]), t.get("Cancel"), t.get("Confirm"), (()=>{
                            i(e, n)
                        }
                        ), (()=>{
                            var t;
                            s.deleteProfileSlot(e),
                            e == s.profileSlot && (s.setProfileSlot(null !== (t = s.firstOccupiedProfileSlot()) && void 0 !== t ? t : 0),
                            s.syncUserProfile(c)),
                            r()
                        }
                        ))
                    }
                    ),(r=>{
                        var a;
                        null === (a = Xk(this, Ik, "f")) || void 0 === a || a.dispose(),
                        jk(this, Ik, null, "f"),
                        u.showConfirm(t.get("Are you sure you want to display your private key?") + "\n\n" + t.get("DO NOT SHARE THIS KEY WITH ANYONE."), t.get("Cancel"), t.get("Confirm"), (()=>{
                            i(e, r)
                        }
                        ), (()=>{
                            var a;
                            jk(this, Nk, new yk(n,t,null !== (a = s.getToken(e)) && void 0 !== a ? a : "",(()=>{
                                var t;
                                null === (t = Xk(this, Nk, "f")) || void 0 === t || t.dispose(),
                                jk(this, Nk, null, "f"),
                                i(e, r)
                            }
                            ),null), "f")
                        }
                        ))
                    }
                    ),(t=>{
                        var n;
                        null === (n = Xk(this, Ik, "f")) || void 0 === n || n.dispose(),
                        jk(this, Ik, null, "f"),
                        s.setNickname(t, e),
                        c.submitUserProfile(s.getToken(e), t, s.getCarColors(e)),
                        s.setProfileSlot(e),
                        s.syncUserProfile(c),
                        r()
                    }
                    ),(()=>{
                        var t;
                        null === (t = Xk(this, Ik, "f")) || void 0 === t || t.dispose(),
                        jk(this, Ik, null, "f"),
                        v(s.getToken(e)),
                        Xk(this, xk, "m", Wk).call(this)
                    }
                    )), "f")
                }
                  , r = ()=>{
                    jk(this, Lk, new JT(t,n,s,(()=>{
                        var e;
                        null === (e = Xk(this, Lk, "f")) || void 0 === e || e.dispose(),
                        jk(this, Lk, null, "f"),
                        Xk(this, xk, "m", Wk).call(this)
                    }
                    ),(()=>{
                        var n;
                        null === (n = Xk(this, Lk, "f")) || void 0 === n || n.dispose(),
                        jk(this, Lk, null, "f");
                        const i = s.firstFreeProfileSlot();
                        null == i ? u.show(t.get("You need a free user profile slot to import a new user profile"), t.get("Ok"), (()=>{
                            r()
                        }
                        )) : e(i, "")
                    }
                    ),(e=>i(e, null))), "f")
                }
                ;
                r()
            }
            ));
            const M = document.createElement("p");
            M.textContent = t.get("Profile"),
            S.appendChild(M),
            Xk(this, Sk, "f").appendChild(S),
            Xk(this, Uk, "f").push(S);
            const T = document.createElement("button");
            T.className = "hidden",
            T.innerHTML = '<img src="images/play.svg">',
            T.addEventListener("click", (()=>{
                n.playUIClick(),
                Xk(this, xk, "m", Fk).call(this),
                Xk(this, xk, "m", Hk).call(this),
                Xk(this, Ak, "f").show()
            }
            ));
            const k = document.createElement("p");
            k.textContent = t.get("Play"),
            T.appendChild(k),
            Xk(this, Sk, "f").appendChild(T),
            Xk(this, Uk, "f").push(T);
            const C = document.createElement("div");
            if (C.className = "bottom-buttons",
            Xk(this, Sk, "f").appendChild(C),
            window.electron) {
                const e = document.createElement("button");
                e.className = "button small",
                e.innerHTML = '<img src="images/quit.svg"> Quit',
                e.addEventListener("click", (()=>{
                    var e;
                    n.playUIClick(),
                    null === (e = window.electron) || void 0 === e || e.quit()
                }
                )),
                C.appendChild(e),
                Xk(this, Dk, "f").push(e)
            }
            jk(this, Tk, document.createElement("a"), "f"),
            Xk(this, Tk, "f").className = "discord-link",
            Xk(this, Tk, "f").href = "https://www.kodub.com/discord/polytrack",
            Xk(this, Tk, "f").target = "_blank",
            Xk(this, Tk, "f").innerHTML = '<img src="images/discord.svg">',
            Xk(this, Sk, "f").appendChild(Xk(this, Tk, "f")),
            jk(this, kk, document.createElement("div"), "f"),
            Xk(this, kk, "f").className = "info",
            Xk(this, Sk, "f").appendChild(Xk(this, kk, "f"));
            const A = document.createElement("a");
            A.href = "https://www.kodub.com",
            A.target = "_blank",
            A.textContent = "kodub.com - " + t.get("Version") + " " + _k.i8,
            Xk(this, kk, "f").appendChild(A);
            const P = document.createElement("a");
            P.href = "https://opengameart.org/content/sci-fi-theme-1",
            P.target = "_blank",
            P.textContent = '"Sci-fi Theme" by Maou (CC-BY 4.0)',
            Xk(this, kk, "f").appendChild(P),
            i.hasLoaded() ? Xk(this, xk, "m", Wk).call(this) : (jk(this, Ck, new mM(Xk(this, Sk, "f"),t,i), "f"),
            i.addCompleteListener((()=>{
                var e;
                null === (e = Xk(this, Ck, "f")) || void 0 === e || e.dispose(),
                jk(this, Ck, null, "f");
                null == s.getToken() ? (S.disabled = !0,
                Xk(this, xk, "m", Hk).call(this),
                u.show(t.get("Failed to create user token.") + " " + t.get("Leaderboard is disabled.") + "\n\n" + t.get("Please try another browser or device."), t.get("Ok"), (()=>{
                    Xk(this, xk, "m", Vk).call(this),
                    Xk(this, xk, "m", Wk).call(this)
                }
                ))) : c.submitAllowed ? (S.disabled = !1,
                Xk(this, xk, "m", Wk).call(this)) : (S.disabled = !0,
                Xk(this, xk, "m", Hk).call(this),
                u.show(t.get("Computer determinism check failed.") + " " + t.get("Leaderboard is disabled.") + "\n\n" + t.get("Please try another browser or device."), t.get("Ok"), (()=>{
                    Xk(this, xk, "m", Vk).call(this),
                    Xk(this, xk, "m", Wk).call(this)
                }
                )))
            }
            )))
        }
        ,
        Fk = function() {
            Xk(this, Uk, "f").forEach((e=>{
                e.className = "hidden"
            }
            )),
            Xk(this, Dk, "f").forEach((e=>{
                e.classList.add("hidden")
            }
            )),
            Xk(this, Tk, "f").className = "hidden",
            Xk(this, kk, "f").className = "hidden"
        }
        ,
        Wk = function() {
            Xk(this, Uk, "f").forEach((e=>{
                e.className = "button-image button"
            }
            )),
            Xk(this, Dk, "f").forEach((e=>{
                e.classList.remove("hidden")
            }
            )),
            Xk(this, Tk, "f").className = "discord-link",
            Xk(this, kk, "f").className = "info"
        }
        ,
        Hk = function() {
            Xk(this, Mk, "f").className = "hidden"
        }
        ,
        Vk = function() {
            Xk(this, Mk, "f").className = "logo"
        }
        ,
        Gk = function() {
            const e = Xk(this, bk, "f").getBounds()
              , t = new De((e.min.x + (e.max.x - e.min.x) / 2) * cw.partWidth,(e.min.y + (e.max.y - e.min.y) / 2) * cw.partLength);
            Xk(this, Bk, "f").position.set(t.x + 250 * Math.cos(Xk(this, Ok, "f")), 100, t.y - 250 * Math.sin(Xk(this, Ok, "f"))),
            Xk(this, Bk, "f").rotation.y = Xk(this, Ok, "f") + Math.PI / 2
        }
        ;
        const qk = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v) {
                xk.add(this),
                bk.set(this, void 0),
                Ek.set(this, void 0),
                Sk.set(this, void 0),
                Mk.set(this, void 0),
                Tk.set(this, void 0),
                kk.set(this, void 0),
                Ck.set(this, null),
                Ak.set(this, void 0),
                Pk.set(this, null),
                Rk.set(this, null),
                Lk.set(this, null),
                Ik.set(this, null),
                Nk.set(this, null),
                Uk.set(this, []),
                Dk.set(this, []),
                Bk.set(this, void 0),
                Ok.set(this, Math.random() * Math.PI * 2),
                jk(this, bk, r, "f"),
                jk(this, Ek, document.getElementById("ui"), "f"),
                jk(this, Sk, document.createElement("div"), "f"),
                Xk(this, Sk, "f").className = "menu",
                Xk(this, xk, "m", zk).call(this, e, t, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v),
                Xk(this, Ek, "f").appendChild(Xk(this, Sk, "f")),
                jk(this, Bk, new _i(70,1,.1,1e4), "f"),
                n.scene.add(Xk(this, Bk, "f")),
                Xk(this, xk, "m", Gk).call(this)
            }
            dispose() {
                var e;
                Xk(this, Ek, "f").removeChild(Xk(this, Sk, "f")),
                null === (e = Xk(this, Pk, "f")) || void 0 === e || e.dispose(),
                jk(this, Pk, null, "f")
            }
            get camera() {
                return Xk(this, Bk, "f")
            }
            update(e) {
                jk(this, Ok, Xk(this, Ok, "f") + .05 * e, "f"),
                Xk(this, xk, "m", Gk).call(this)
            }
        }
        ;
        var Yk, Zk, Kk, Jk, Qk, $k, eC, tC, nC, iC, rC, aC, sC, oC = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, lC = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        Zk = new WeakMap,
        Kk = new WeakMap,
        Jk = new WeakMap,
        Qk = new WeakMap,
        $k = new WeakMap,
        eC = new WeakMap,
        tC = new WeakMap,
        nC = new WeakMap,
        iC = new WeakMap,
        rC = new WeakMap,
        aC = new WeakMap,
        Yk = new WeakSet,
        sC = function() {
            lC(this, Kk, "f").loadTrackData(lC(this, Qk, "f").getRandomTrackData(!1)),
            lC(this, Kk, "f").generateMeshes(),
            lC(this, Jk, "f").generateMountains(lC(this, Kk, "f").getBounds());
            let e = null;
            const t = lC(this, Kk, "f").getID();
            if (null != t) {
                const n = lC(this, $k, "f").getRecord(lC(this, iC, "f").profileSlot, t);
                null != n && (e = n.recording)
            }
            null != e && (oC(this, aC, new Jm(lC(this, Zk, "f"),lC(this, Kk, "f").getStartTransform(),e,null,!1,lC(this, tC, "f"),lC(this, nC, "f"),lC(this, Jk, "f"),lC(this, Kk, "f"),lC(this, eC, "f")), "f"),
            lC(this, aC, "f").audioVolume = 0,
            lC(this, aC, "f").start())
        }
        ;
        const cC = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, m, g, v, w, y) {
                Yk.add(this),
                Zk.set(this, void 0),
                Kk.set(this, void 0),
                Jk.set(this, void 0),
                Qk.set(this, void 0),
                $k.set(this, void 0),
                eC.set(this, void 0),
                tC.set(this, void 0),
                nC.set(this, void 0),
                iC.set(this, void 0),
                rC.set(this, void 0),
                aC.set(this, null),
                oC(this, Zk, e, "f"),
                oC(this, Kk, t, "f"),
                oC(this, Jk, i, "f"),
                oC(this, Qk, r, "f"),
                oC(this, $k, l, "f"),
                oC(this, eC, u, "f"),
                oC(this, tC, c, "f"),
                oC(this, nC, h, "f"),
                oC(this, iC, o, "f"),
                oC(this, rC, new qk(a,h,c,f,t,n,o,l,d,p,r,u,s,m,g,v,w,y), "f"),
                c.setCamera(lC(this, rC, "f").camera),
                f.hasLoaded() ? lC(this, Yk, "m", sC).call(this) : f.addCompleteListener((()=>{
                    lC(this, Yk, "m", sC).call(this)
                }
                ))
            }
            dispose() {
                var e;
                null === (e = lC(this, aC, "f")) || void 0 === e || e.dispose(),
                lC(this, rC, "f").dispose(),
                lC(this, Kk, "f").clear(),
                lC(this, Jk, "f").clearMountains()
            }
            update(e) {
                var t, n;
                null === (t = lC(this, aC, "f")) || void 0 === t || t.update(e),
                lC(this, rC, "f").update(e),
                lC(this, tC, "f").update(null === (n = lC(this, aC, "f")) || void 0 === n ? void 0 : n.getPosition()),
                lC(this, nC, "f").update(e, !0, lC(this, tC, "f"), lC(this, eC, "f"))
            }
        }
        ;
        var hC = n(47)
          , dC = {};
        dC.styleTagTransform = u(),
        dC.setAttributes = l(),
        dC.insert = s().bind(null, "head"),
        dC.domAPI = r(),
        dC.insertStyleElement = h();
        t()(hC.Z, dC);
        hC.Z && hC.Z.locals && hC.Z.locals;
        var uC, pC, fC, mC, gC, vC, wC, yC, _C, xC = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, bC = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        uC = new WeakMap,
        pC = new WeakMap,
        fC = new WeakMap,
        mC = new WeakMap,
        gC = new WeakMap,
        vC = new WeakMap,
        wC = new WeakMap,
        yC = new WeakMap,
        _C = new WeakMap;
        const EC = class {
            constructor(e) {
                uC.set(this, !1),
                pC.set(this, void 0),
                fC.set(this, void 0),
                mC.set(this, void 0),
                gC.set(this, void 0),
                vC.set(this, void 0),
                wC.set(this, void 0),
                yC.set(this, null),
                _C.set(this, null);
                const t = document.getElementById("ui");
                xC(this, pC, document.createElement("div"), "f"),
                bC(this, pC, "f").className = "hidden",
                t.appendChild(bC(this, pC, "f")),
                xC(this, fC, document.createElement("div"), "f"),
                bC(this, fC, "f").className = "background",
                bC(this, pC, "f").appendChild(bC(this, fC, "f")),
                xC(this, mC, document.createElement("div"), "f"),
                bC(this, mC, "f").className = "box",
                bC(this, pC, "f").appendChild(bC(this, mC, "f")),
                xC(this, gC, document.createElement("p"), "f"),
                bC(this, mC, "f").appendChild(bC(this, gC, "f")),
                xC(this, vC, document.createElement("button"), "f"),
                bC(this, vC, "f").className = "button",
                bC(this, vC, "f").addEventListener("click", (()=>{
                    e.playUIClick(),
                    xC(this, uC, !1, "f"),
                    null != bC(this, yC, "f") && bC(this, yC, "f").call(this),
                    bC(this, uC, "f") || this.hide()
                }
                )),
                bC(this, mC, "f").appendChild(bC(this, vC, "f")),
                xC(this, wC, document.createElement("button"), "f"),
                bC(this, wC, "f").className = "button",
                bC(this, wC, "f").addEventListener("click", (()=>{
                    e.playUIClick(),
                    xC(this, uC, !1, "f"),
                    null != bC(this, _C, "f") && bC(this, _C, "f").call(this),
                    bC(this, uC, "f") || this.hide()
                }
                )),
                bC(this, mC, "f").appendChild(bC(this, wC, "f")),
                window.addEventListener("keydown", (e=>{
                    this.isOpen && "Escape" == e.code && (null != bC(this, yC, "f") && bC(this, yC, "f").call(this),
                    this.hide(),
                    e.stopImmediatePropagation(),
                    e.preventDefault())
                }
                ))
            }
            get isOpen() {
                return bC(this, uC, "f")
            }
            show(e, t, n) {
                xC(this, uC, !0, "f"),
                bC(this, pC, "f").className = "message-box message",
                bC(this, gC, "f").textContent = e,
                bC(this, vC, "f").textContent = "",
                bC(this, wC, "f").textContent = t,
                xC(this, yC, n, "f"),
                xC(this, _C, n, "f")
            }
            showConfirm(e, t, n, i, r) {
                xC(this, uC, !0, "f"),
                bC(this, pC, "f").className = "message-box confirm",
                bC(this, gC, "f").textContent = e,
                bC(this, vC, "f").textContent = t,
                bC(this, wC, "f").textContent = n,
                xC(this, yC, i, "f"),
                xC(this, _C, r, "f")
            }
            hide() {
                xC(this, uC, !1, "f"),
                bC(this, pC, "f").className = "hidden",
                bC(this, gC, "f").textContent = "",
                bC(this, vC, "f").textContent = "",
                bC(this, wC, "f").textContent = "",
                xC(this, yC, null, "f"),
                xC(this, _C, null, "f")
            }
        }
        ;
        var SC, MC, TC, kC, CC = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        }, AC = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        };
        SC = new WeakMap,
        MC = new WeakMap,
        TC = new WeakMap,
        kC = new WeakMap;
        const PC = class {
            constructor() {
                SC.set(this, 0),
                MC.set(this, 0),
                TC.set(this, []),
                kC.set(this, [])
            }
            hasLoaded() {
                return CC(this, MC, "f") == CC(this, SC, "f")
            }
            getProgress() {
                return CC(this, MC, "f") / CC(this, SC, "f")
            }
            addResource() {
                var e;
                AC(this, SC, (e = CC(this, SC, "f"),
                ++e), "f")
            }
            loadedResource() {
                var e;
                AC(this, MC, (e = CC(this, MC, "f"),
                ++e), "f");
                for (let e = 0; e < CC(this, TC, "f").length; ++e)
                    CC(this, TC, "f")[e](this.getProgress());
                if (this.hasLoaded())
                    for (let e = 0; e < CC(this, kC, "f").length; ++e)
                        CC(this, kC, "f")[e]()
            }
            addProgressListener(e) {
                CC(this, TC, "f").push(e)
            }
            addCompleteListener(e) {
                CC(this, kC, "f").push(e)
            }
            preloadImage(e) {
                this.addResource();
                const t = new Image;
                t.addEventListener("load", (()=>{
                    this.loadedResource()
                }
                )),
                t.src = e
            }
        }
        ;
        var RC, LC, IC, NC, UC, DC, BC, OC = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, zC = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        LC = new WeakMap,
        IC = new WeakMap,
        NC = new WeakMap,
        UC = new WeakMap,
        RC = new WeakSet,
        DC = function(e, t, n, i, r) {
            var a;
            const s = zC(this, NC, "f").getToken(e)
              , o = e + "_" + t
              , l = (null !== (a = zC(this, UC, "f").get(o)) && void 0 !== a ? a : 0) + 1;
            return zC(this, UC, "f").set(o, l),
            zC(this, IC, "f").submitLeaderboard(t, n, i, r).then((({uploadId: r})=>{
                null != s && zC(this, UC, "f").get(o) == l && zC(this, NC, "f").getToken(e) == s && zC(this, LC, "f").saveRecord(e, t, r, n, i)
            }
            ))
        }
        ,
        BC = function(e, t, n) {
            var i;
            const r = zC(this, NC, "f").getToken(e)
              , a = e + "_" + t
              , s = (null !== (i = zC(this, UC, "f").get(a)) && void 0 !== i ? i : 0) + 1;
            return zC(this, UC, "f").set(a, s),
            zC(this, IC, "f").getRecording(n).then((({recording: i, time: o})=>{
                if (null != r && zC(this, UC, "f").get(a) == s && zC(this, NC, "f").getToken(e) == r) {
                    const r = this.getRecordTime(e, t);
                    (null == r || o.lessThan(r)) && zC(this, LC, "f").saveRecord(e, t, n, o, i)
                }
            }
            ))
        }
        ;
        const FC = class {
            constructor(e, t, n) {
                RC.add(this),
                LC.set(this, void 0),
                IC.set(this, void 0),
                NC.set(this, void 0),
                UC.set(this, new Map),
                OC(this, LC, e, "f"),
                OC(this, IC, t, "f"),
                OC(this, NC, n, "f")
            }
            setRecord(e, t, n, i, r) {
                zC(this, LC, "f").saveRecord(e, t, null, n, i),
                zC(this, RC, "m", DC).call(this, e, t, n, i, r)
            }
            syncRecord(e, t, n, i) {
                return new Promise(((r,a)=>{
                    const s = this.getRecord(e, t);
                    null != s && (null == n || s.uploadId != n.recordingId && s.time.lessThan(n.time)) ? zC(this, RC, "m", DC).call(this, e, t, s.time, s.recording, i).then((()=>r("Upload"))).catch(a) : null != n && (null == s || s.uploadId != n.recordingId && n.time.lessThan(s.time)) ? zC(this, RC, "m", BC).call(this, e, t, n.recordingId).then((()=>r("Download"))).catch(a) : r(null)
                }
                ))
            }
            getRecordTime(e, t) {
                const n = this.getRecord(e, t);
                return null == n ? null : n.time
            }
            getRecord(e, t) {
                return zC(this, LC, "f").loadRecord(e, t)
            }
        }
        ;
        var WC, HC, VC, GC, jC, XC, qC, YC = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, ZC = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        HC = new WeakMap,
        VC = new WeakMap,
        GC = new WeakMap,
        jC = new WeakMap,
        WC = new WeakSet,
        XC = function(e, t) {
            return t.addResource(),
            new Promise((n=>{
                const i = new XMLHttpRequest;
                i.overrideMimeType("text/plain"),
                i.onreadystatechange = ()=>{
                    if (4 == i.readyState && 200 == i.status) {
                        t.loadedResource();
                        const e = Gv.fromExportString(i.responseText, ZC(this, jC, "f"));
                        if (null == e)
                            throw "Failed to load standard track";
                        const {trackName: r, trackData: a} = e;
                        n({
                            id: a.getId(ZC(this, jC, "f")),
                            name: r,
                            trackData: a,
                            thumbnail: a.createThumbnail(ZC(this, jC, "f")),
                            saveTime: null
                        })
                    }
                }
                ,
                i.open("GET", e, !0),
                i.send()
            }
            ))
        }
        ,
        qC = function(e) {
            var t;
            const n = ZC(this, GC, "f").loadTrack(e, ZC(this, jC, "f"));
            if (null != n) {
                const {trackData: i, saveTime: r} = n
                  , a = {
                    id: i.getId(ZC(this, jC, "f")),
                    name: e,
                    trackData: i,
                    thumbnail: i.createThumbnail(ZC(this, jC, "f")),
                    saveTime: r
                };
                for (let e = 0; e <= ZC(this, VC, "f").length; e++)
                    if (e == ZC(this, VC, "f").length || (null !== (t = ZC(this, VC, "f")[e].saveTime) && void 0 !== t ? t : -1 / 0) < r) {
                        ZC(this, VC, "f").splice(e, 0, a);
                        break
                    }
            }
        }
        ;
        const KC = class {
            constructor(e, t, n) {
                WC.add(this),
                HC.set(this, []),
                VC.set(this, []),
                GC.set(this, void 0),
                jC.set(this, void 0),
                YC(this, GC, n, "f"),
                YC(this, jC, t, "f"),
                Promise.all([ZC(this, WC, "m", XC).call(this, "tracks/track1.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track2.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track3.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track4.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track5.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track6.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track7.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track8.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track9.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track10.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track11.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track12.track", e), ZC(this, WC, "m", XC).call(this, "tracks/track13.track", e)]).then((e=>{
                    YC(this, HC, e, "f")
                }
                ))
            }
            refreshCustomTracks() {
                const e = ZC(this, GC, "f").getAllTrackNames();
                null != e && (ZC(this, VC, "f").length = 0,
                e.forEach((e=>{
                    ZC(this, WC, "m", qC).call(this, e)
                }
                )))
            }
            isCustomTracksEmpty() {
                return 0 == ZC(this, VC, "f").length
            }
            forEach(e) {
                this.forEachStandard(e),
                this.forEachCustom(e)
            }
            forEachStandard(e) {
                ZC(this, HC, "f").forEach((t=>{
                    e(t.id, t.name, t.trackData, t.thumbnail)
                }
                ))
            }
            forEachCustom(e) {
                ZC(this, VC, "f").forEach((t=>{
                    e(t.id, t.name, t.trackData, t.thumbnail)
                }
                ))
            }
            getRandomTrackData(e) {
                let t;
                return t = e ? ZC(this, HC, "f").concat(ZC(this, VC, "f")) : ZC(this, HC, "f"),
                t[Math.floor(Math.random() * t.length)].trackData
            }
        }
        ;
        var JC;
        !function(e) {
            e[e.Road = 0] = "Road",
            e[e.RoadTurns = 1] = "RoadTurns",
            e[e.RoadWide = 2] = "RoadWide",
            e[e.Plane = 3] = "Plane",
            e[e.Block = 4] = "Block",
            e[e.WallTrack = 5] = "WallTrack",
            e[e.Pillar = 6] = "Pillar",
            e[e.Sign = 7] = "Sign"
        }(JC || (JC = {}));
        const QC = JC;
        var $C, eA, tA, nA, iA = function(e, t, n, i) {
            return new (n || (n = Promise))((function(r, a) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function o(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        a(e)
                    }
                }
                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value,
                    t instanceof n ? t : new n((function(e) {
                        e(t)
                    }
                    ))).then(s, o)
                }
                l((i = i.apply(e, t || [])).next())
            }
            ))
        }, rA = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, aA = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class sA {
            constructor(e) {
                $C.add(this),
                eA.set(this, void 0),
                tA.set(this, new Map),
                rA(this, eA, e, "f"),
                aA(this, $C, "m", nA).call(this)
            }
            getPhysicsParts() {
                const e = [];
                return aA(this, tA, "f").forEach((({id: t, physicsShapeVertices: n, detector: i})=>{
                    e.push({
                        type: t,
                        vertices: n,
                        detector: i
                    })
                }
                )),
                e
            }
            hasPart(e) {
                return aA(this, tA, "f").has(e)
            }
            getPart(e) {
                const t = aA(this, tA, "f").get(e);
                if (null == t)
                    throw 'Track part with the id "' + e + '" does not exist';
                return t
            }
            getAllParts() {
                return Array.from(aA(this, tA, "f").values())
            }
            getPartTypesWithDetector(e) {
                const t = [];
                return aA(this, tA, "f").forEach(((n,i)=>{
                    null != n.detector && n.detector.type == e && t.push(i)
                }
                )),
                t
            }
        }
        eA = new WeakMap,
        tA = new WeakMap,
        $C = new WeakSet,
        nA = function() {
            return iA(this, void 0, void 0, (function*() {
                const e = (t = ["models/block.glb", "models/pillar.glb", "models/plane.glb", "models/road.glb", "models/road_wide.glb", "models/signs.glb", "models/wall_track.glb"],
                Promise.all(t.map((e=>{
                    return t = e,
                    new Promise((e=>{
                        (new Cc).load(t, (t=>{
                            e(t)
                        }
                        ))
                    }
                    ));
                    var t
                }
                ))));
                var t;
                const n = new ol({
                    vertexColors: !0
                })
                  , i = (t,i,r,...a)=>iA(this, [t, i, r, ...a], void 0, (function*(t, i, r, a=null, s=null, o=null) {
                    if (aA(this, eA, "f").addResource(),
                    aA(this, tA, "f").has(i))
                        throw "Track part types have same Id";
                    const l = {
                        id: i,
                        mesh: null,
                        physicsShapeVertices: [],
                        tiles: new qy(null != a ? a : [[0, 0, 0]]),
                        detector: null != s ? s : null,
                        category: t
                    };
                    aA(this, tA, "f").set(i, l);
                    const c = yield e;
                    function h(e) {
                        const t = e.material;
                        if (!(t instanceof al))
                            throw "Material is not a MeshStandardMaterial";
                        const n = e.geometry.clone()
                          , i = new Float32Array(n.attributes.position.array.length);
                        for (let e = 0; e < i.length; e += 3)
                            i[e + 0] = t.color.r,
                            i[e + 1] = t.color.g,
                            i[e + 2] = t.color.b;
                        return n.attributes.color = new Dn(i,3),
                        n
                    }
                    const d = [];
                    let u = [];
                    r.forEach((([e,t])=>{
                        const i = function(e, t) {
                            const i = c.find((t=>t.scene.name == e));
                            if (null == i)
                                throw 'Scene "' + e + '" does not exist';
                            const r = i.scene.getObjectByName(t);
                            if (null == r)
                                throw 'Mesh "' + t + '" does not exist in scene "' + e + '"';
                            let a;
                            if (0 == r.children.length) {
                                const e = r;
                                a = h(e),
                                e.updateMatrixWorld(!0),
                                a.applyMatrix4(e.matrix)
                            } else {
                                const e = r.children.map((e=>h(e)));
                                a = Mc(e, !0),
                                r.updateMatrixWorld(!0),
                                a.applyMatrix4(r.matrix)
                            }
                            const s = new di(a,n);
                            return s.name = t,
                            s
                        }(e, t);
                        d.push(i);
                        const r = i.geometry.toNonIndexed();
                        if (!(r.attributes.position instanceof Dn))
                            throw "Vertices must use BufferAttribute";
                        u = u.concat(Array.from(r.attributes.position.array))
                    }
                    ));
                    const p = Mc(d.map((e=>e.geometry)), !0)
                      , f = new di(p,n);
                    l.mesh = f,
                    l.physicsShapeVertices = u,
                    null != o && o(l),
                    aA(this, eA, "f").loadedResource()
                }
                ));
                function r(e, t, n, i) {
                    if (null == e.mesh)
                        throw "Mesh not loaded";
                    const r = e.mesh.geometry.attributes.color.array;
                    for (let e = 0; e < 3 * r.length; e += 3) {
                        const a = new An(r[e + 0],r[e + 1],r[e + 2]);
                        a.offsetHSL(t, n, i),
                        r[e + 0] = a.r,
                        r[e + 1] = a.g,
                        r[e + 2] = a.b
                    }
                }
                function a(e) {
                    return r(e, 0, .5, 0)
                }
                function s(e) {
                    return r(e, .65, .4, 0)
                }
                function o(e) {
                    return r(e, 0, 0, -.135)
                }
                i(QC.Road, Qg.Straight, [["Road", "Straight"]]),
                i(QC.Road, Qg.StraightPillarBottom, [["Road", "Straight"], ["Pillar", "SurfacePillarBottom"]]),
                i(QC.Road, Qg.StraightPillarShort, [["Road", "Straight"], ["Pillar", "SurfacePillarShort"]]),
                i(QC.Road, Qg.TurnSharp, [["Road", "TurnSharp"]]),
                i(QC.Road, Qg.TurnSharpPillarBottom, [["Road", "TurnSharp"], ["Pillar", "SurfacePillarBottom"]]),
                i(QC.Road, Qg.TurnSharpPillarShort, [["Road", "TurnSharp"], ["Pillar", "SurfacePillarShort"]]),
                i(QC.RoadTurns, Qg.TurnShort, [["Road", "TurnShort"]], [[0, 0, 0], [1, 0, 0], [0, 0, -1], [1, 0, -1]]),
                i(QC.RoadTurns, Qg.TurnLong, [["Road", "TurnLong"]], [[0, 0, 0], [1, 0, 0], [0, 0, -1], [1, 0, -1], [2, 0, -1], [1, 0, -2], [2, 0, -2]]),
                i(QC.RoadTurns, Qg.TurnLong2, [["Road", "TurnLong2"]], [[0, 0, 0], [0, 0, -1], [1, 0, -1], [0, 0, -2], [1, 0, -2], [2, 0, -2], [1, 0, -3], [2, 0, -3], [3, 0, -3]]),
                i(QC.RoadTurns, Qg.TurnLong3, [["Road", "TurnLong3"]], [[0, 0, 0], [0, 0, -1], [1, 0, -1], [0, 0, -2], [1, 0, -2], [2, 0, -2], [1, 0, -3], [2, 0, -3], [3, 0, -3], [2, 0, -4], [3, 0, -4], [4, 0, -4]]),
                i(QC.RoadTurns, Qg.TurnSLeft, [["Road", "TurnSLeft"]], [[0, 0, 0], [0, 0, -1], [0, 0, -2], [-1, 0, 0], [-1, 0, -1], [-1, 0, -2]]),
                i(QC.RoadTurns, Qg.TurnSRight, [["Road", "TurnSRight"]], [[0, 0, 0], [0, 0, -1], [0, 0, -2], [1, 0, 0], [1, 0, -1], [1, 0, -2]]),
                i(QC.Road, Qg.SlopeUp, [["Road", "SlopeUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Road, Qg.SlopeUpBlock, [["Road", "SlopeUp"], ["Blocks", "BlockSlopeUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Road, Qg.SlopeUpLong, [["Road", "SlopeUpLong"]], [[0, 0, 0], [0, 0, -1], [0, 1, -1], [0, 2, -1]]),
                i(QC.Road, Qg.SlopeDown, [["Road", "SlopeDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Road, Qg.SlopeDownBlock, [["Road", "SlopeDown"], ["Blocks", "BlockSlopeDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Road, Qg.SlopeDownLong, [["Road", "SlopeDownLong"]], [[0, 0, 0], [0, 1, 0], [0, 1, 1], [0, 2, 1]]),
                i(QC.Road, Qg.Slope, [["Road", "Slope"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Road, Qg.SlopePillar, [["Road", "Slope"], ["Pillar", "PillarTopSlope"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Road, Qg.SlopePillarShort, [["Road", "Slope"], ["Pillar", "PillarShortSlope"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Road, Qg.SlopeBlock, [["Road", "Slope"], ["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Road, Qg.IntersectionT, [["Road", "IntersectionT"]]),
                i(QC.Road, Qg.IntersectionTPillarBottom, [["Road", "IntersectionT"], ["Pillar", "SurfacePillarBottom"]]),
                i(QC.Road, Qg.IntersectionTPillarShort, [["Road", "IntersectionT"], ["Pillar", "SurfacePillarShort"]]),
                i(QC.Road, Qg.IntersectionCross, [["Road", "IntersectionCross"]]),
                i(QC.Road, Qg.IntersectionCrossPillarBottom, [["Road", "IntersectionCross"], ["Pillar", "SurfacePillarBottom"]]),
                i(QC.Road, Qg.IntersectionCrossPillarShort, [["Road", "IntersectionCross"], ["Pillar", "SurfacePillarShort"]]),
                i(QC.Road, Qg.Start, [["Road", "Start"]]),
                i(QC.Road, Qg.Finish, [["Road", "Finish"]], [[0, 0, 0]], {
                    type: Iv.Finish,
                    center: [0, 2.2, 0],
                    size: [11, 3.8, 2]
                }),
                i(QC.Road, Qg.Checkpoint, [["Road", "Checkpoint"]], [[0, 0, 0]], {
                    type: Iv.Checkpoint,
                    center: [0, 2.2, 0],
                    size: [11, 3.8, 2]
                }),
                i(QC.RoadWide, Qg.ToWideMiddle, [["RoadWide", "ToWideMiddle"]]),
                i(QC.RoadWide, Qg.ToWideLeft, [["RoadWide", "ToWideLeft"]]),
                i(QC.RoadWide, Qg.ToWideRight, [["RoadWide", "ToWideRight"]]),
                i(QC.RoadWide, Qg.ToWideDouble, [["RoadWide", "ToWideDouble"]]),
                i(QC.RoadWide, Qg.ToWideDiagonal, [["RoadWide", "ToWideDiagonal"]]),
                i(QC.RoadWide, Qg.StraightWide, [["RoadWide", "StraightWide"]]),
                i(QC.RoadWide, Qg.InnerCornerWide, [["RoadWide", "InnerCornerWide"]]),
                i(QC.RoadWide, Qg.OuterCornerWide, [["RoadWide", "OuterCornerWide"]]),
                i(QC.RoadWide, Qg.SlopeUpLeftWide, [["RoadWide", "SlopeUpLeftWide"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeUpLeftWideBlock, [["RoadWide", "SlopeUpLeftWide"], ["Blocks", "BlockSlopeUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeUpRightWide, [["RoadWide", "SlopeUpRightWide"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeUpRightWideBlock, [["RoadWide", "SlopeUpRightWide"], ["Blocks", "BlockSlopeUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeDownLeftWide, [["RoadWide", "SlopeDownLeftWide"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeDownLeftWideBlock, [["RoadWide", "SlopeDownLeftWide"], ["Blocks", "BlockSlopeDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeDownRightWide, [["RoadWide", "SlopeDownRightWide"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeDownRightWideBlock, [["RoadWide", "SlopeDownRightWide"], ["Blocks", "BlockSlopeDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.RoadWide, Qg.SlopeLeftWide, [["RoadWide", "SlopeLeftWide"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.RoadWide, Qg.SlopeLeftWideBlock, [["RoadWide", "SlopeLeftWide"], ["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.RoadWide, Qg.SlopeRightWide, [["RoadWide", "SlopeRightWide"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.RoadWide, Qg.SlopeRightWideBlock, [["RoadWide", "SlopeRightWide"], ["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.RoadWide, Qg.CheckpointWide, [["RoadWide", "CheckpointWide"]], [[0, 0, 0], [1, 0, 0]], {
                    type: Iv.Checkpoint,
                    center: [10, 2.2, 0],
                    size: [31.1, 3.8, 2]
                }),
                i(QC.RoadWide, Qg.FinishWide, [["RoadWide", "FinishWide"]], [[0, 0, 0], [1, 0, 0]], {
                    type: Iv.Finish,
                    center: [10, 2.2, 0],
                    size: [31.1, 3.8, 2]
                }),
                i(QC.Plane, Qg.Plane, [["Planes", "Plane"]]),
                i(QC.Plane, Qg.PlanePillarBottom, [["Planes", "Plane"], ["Pillar", "SurfacePillarBottom"]]),
                i(QC.Plane, Qg.PlanePillarShort, [["Planes", "Plane"], ["Pillar", "SurfacePillarShort"]]),
                i(QC.Plane, Qg.HalfPlane, [["Planes", "HalfPlane"]]),
                i(QC.Plane, Qg.QuarterPlane, [["Planes", "QuarterPlane"]]),
                i(QC.Plane, Qg.PlaneSlopeUp, [["Planes", "PlaneSlopeUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Plane, Qg.PlaneSlopeDown, [["Planes", "PlaneSlopeDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Plane, Qg.PlaneSlope, [["Planes", "PlaneSlope"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Plane, Qg.PlaneBridge, [["Planes", "PlaneBridge"]]),
                i(QC.Plane, Qg.PlaneBridgeCorner, [["Planes", "PlaneBridgeCorner"]]),
                i(QC.Plane, Qg.PlaneBridgeIntersectionT, [["Planes", "PlaneBridgeIntersectionT"]]),
                i(QC.Plane, Qg.PlaneBridgeIntersectionCross, [["Planes", "PlaneBridgeIntersectionCross"]]),
                i(QC.Plane, Qg.PlaneWall, [["Planes", "PlaneWall"]]),
                i(QC.Plane, Qg.PlaneWallCorner, [["Planes", "PlaneWallCorner"]]),
                i(QC.Plane, Qg.PlaneWallInnerCorner, [["Planes", "PlaneWallInnerCorner"]]),
                i(QC.Plane, Qg.PlaneCheckpoint, [["Planes", "PlaneCheckpoint"]], [[0, 0, 0]], {
                    type: Iv.Checkpoint,
                    center: [0, 2.2, 0],
                    size: [18.75, 3.8, 2]
                }),
                i(QC.Plane, Qg.PlaneFinish, [["Planes", "PlaneFinish"]], [[0, 0, 0]], {
                    type: Iv.Finish,
                    center: [0, 2.2, 0],
                    size: [18.75, 3.8, 2]
                }),
                i(QC.Plane, Qg.PlaneCheckpointWide, [["Planes", "PlaneCheckpointWide"]], [[0, 0, 0], [1, 0, 0]], {
                    type: Iv.Checkpoint,
                    center: [10, 2.2, 0],
                    size: [38.75, 3.8, 2]
                }),
                i(QC.Plane, Qg.PlaneFinishWide, [["Planes", "PlaneFinishWide"]], [[0, 0, 0], [1, 0, 0]], {
                    type: Iv.Finish,
                    center: [10, 2.2, 0],
                    size: [38.75, 3.8, 2]
                }),
                i(QC.Plane, Qg.PlaneSlopeUpBlock, [["Planes", "PlaneSlopeUp"], ["Blocks", "BlockSlopeUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Plane, Qg.PlaneSlopeDownBlock, [["Planes", "PlaneSlopeDown"], ["Blocks", "BlockSlopeDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Plane, Qg.PlaneSlopeBlock, [["Planes", "PlaneSlope"], ["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Plane, Qg.PlaneSlopePillar, [["Planes", "PlaneSlope"], ["Pillar", "PillarTopSlope"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Plane, Qg.PlaneSlopePillarShort, [["Planes", "PlaneSlope"], ["Pillar", "PillarShortSlope"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0]]),
                i(QC.Block, Qg.Block, [["Blocks", "Block"]]),
                i(QC.Block, Qg.HalfBlock, [["Blocks", "HalfBlock"]]),
                i(QC.Block, Qg.QuarterBlock, [["Blocks", "QuarterBlock"]]),
                i(QC.Block, Qg.BlockSlopedDown, [["Blocks", "BlockSlopedDown"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Block, Qg.BlockSlopedDownInnerCorner, [["Blocks", "BlockSlopedDownInnerCorner"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Block, Qg.BlockSlopedDownOuterCorner, [["Blocks", "BlockSlopedDownOuterCorner"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Block, Qg.BlockSlopedUp, [["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Block, Qg.BlockSlopedUpInnerCorner, [["Blocks", "BlockSlopedUpInnerCorner"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Block, Qg.BlockSlopedUpOuterCorner, [["Blocks", "BlockSlopedUpOuterCorner"]], [[0, 0, 0], [0, 1, 0]]),
                i(QC.Block, Qg.BlockSlopeDown, [["Blocks", "BlockSlopeDown"]]),
                i(QC.Block, Qg.BlockSlopeUp, [["Blocks", "BlockSlopeUp"]]),
                i(QC.Block, Qg.BlockBridge, [["Blocks", "BlockBridge"]]),
                i(QC.Block, Qg.BlockBridgeCorner, [["Blocks", "BlockBridgeCorner"]]),
                i(QC.Block, Qg.BlockBridgeIntersectionT, [["Blocks", "BlockBridgeIntersectionT"]]),
                i(QC.Block, Qg.BlockBridgeIntersectionCross, [["Blocks", "BlockBridgeIntersectionCross"]]),
                i(QC.Block, Qg.RedBlock, [["Blocks", "Block"]], null, null, a),
                i(QC.Block, Qg.RedHalfBlock, [["Blocks", "HalfBlock"]], null, null, a),
                i(QC.Block, Qg.RedQuarterBlock, [["Blocks", "QuarterBlock"]], null, null, a),
                i(QC.Block, Qg.RedBlockSlopedDown, [["Blocks", "BlockSlopedDown"]], [[0, 0, 0], [0, 1, 0]], null, a),
                i(QC.Block, Qg.RedBlockSlopedDownInnerCorner, [["Blocks", "BlockSlopedDownInnerCorner"]], [[0, 0, 0], [0, 1, 0]], null, a),
                i(QC.Block, Qg.RedBlockSlopedDownOuterCorner, [["Blocks", "BlockSlopedDownOuterCorner"]], [[0, 0, 0], [0, 1, 0]], null, a),
                i(QC.Block, Qg.RedBlockSlopedUp, [["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0]], null, a),
                i(QC.Block, Qg.RedBlockSlopedUpInnerCorner, [["Blocks", "BlockSlopedUpInnerCorner"]], [[0, 0, 0], [0, 1, 0]], null, a),
                i(QC.Block, Qg.RedBlockSlopedUpOuterCorner, [["Blocks", "BlockSlopedUpOuterCorner"]], [[0, 0, 0], [0, 1, 0]], null, a),
                i(QC.Block, Qg.RedBlockSlopeDown, [["Blocks", "BlockSlopeDown"]], null, null, a),
                i(QC.Block, Qg.RedBlockSlopeUp, [["Blocks", "BlockSlopeUp"]], null, null, a),
                i(QC.Block, Qg.RedBlockBridge, [["Blocks", "BlockBridge"]], null, null, a),
                i(QC.Block, Qg.RedBlockBridgeCorner, [["Blocks", "BlockBridgeCorner"]], null, null, a),
                i(QC.Block, Qg.RedBlockBridgeIntersectionT, [["Blocks", "BlockBridgeIntersectionT"]], null, null, a),
                i(QC.Block, Qg.RedBlockBridgeIntersectionCross, [["Blocks", "BlockBridgeIntersectionCross"]], null, null, a),
                i(QC.Block, Qg.BlueBlock, [["Blocks", "Block"]], null, null, s),
                i(QC.Block, Qg.BlueHalfBlock, [["Blocks", "HalfBlock"]], null, null, s),
                i(QC.Block, Qg.BlueQuarterBlock, [["Blocks", "QuarterBlock"]], null, null, s),
                i(QC.Block, Qg.BlueBlockSlopedDown, [["Blocks", "BlockSlopedDown"]], [[0, 0, 0], [0, 1, 0]], null, s),
                i(QC.Block, Qg.BlueBlockSlopedDownInnerCorner, [["Blocks", "BlockSlopedDownInnerCorner"]], [[0, 0, 0], [0, 1, 0]], null, s),
                i(QC.Block, Qg.BlueBlockSlopedDownOuterCorner, [["Blocks", "BlockSlopedDownOuterCorner"]], [[0, 0, 0], [0, 1, 0]], null, s),
                i(QC.Block, Qg.BlueBlockSlopedUp, [["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0]], null, s),
                i(QC.Block, Qg.BlueBlockSlopedUpInnerCorner, [["Blocks", "BlockSlopedUpInnerCorner"]], [[0, 0, 0], [0, 1, 0]], null, s),
                i(QC.Block, Qg.BlueBlockSlopedUpOuterCorner, [["Blocks", "BlockSlopedUpOuterCorner"]], [[0, 0, 0], [0, 1, 0]], null, s),
                i(QC.Block, Qg.BlueBlockSlopeDown, [["Blocks", "BlockSlopeDown"]], null, null, s),
                i(QC.Block, Qg.BlueBlockSlopeUp, [["Blocks", "BlockSlopeUp"]], null, null, s),
                i(QC.Block, Qg.BlueBlockBridge, [["Blocks", "BlockBridge"]], null, null, s),
                i(QC.Block, Qg.BlueBlockBridgeCorner, [["Blocks", "BlockBridgeCorner"]], null, null, s),
                i(QC.Block, Qg.BlueBlockBridgeIntersectionT, [["Blocks", "BlockBridgeIntersectionT"]], null, null, s),
                i(QC.Block, Qg.BlueBlockBridgeIntersectionCross, [["Blocks", "BlockBridgeIntersectionCross"]], null, null, s),
                i(QC.Block, Qg.BlackBlock, [["Blocks", "Block"]], null, null, o),
                i(QC.Block, Qg.BlackHalfBlock, [["Blocks", "HalfBlock"]], null, null, o),
                i(QC.Block, Qg.BlackQuarterBlock, [["Blocks", "QuarterBlock"]], null, null, o),
                i(QC.Block, Qg.BlackBlockSlopedDown, [["Blocks", "BlockSlopedDown"]], [[0, 0, 0], [0, 1, 0]], null, o),
                i(QC.Block, Qg.BlackBlockSlopedDownInnerCorner, [["Blocks", "BlockSlopedDownInnerCorner"]], [[0, 0, 0], [0, 1, 0]], null, o),
                i(QC.Block, Qg.BlackBlockSlopedDownOuterCorner, [["Blocks", "BlockSlopedDownOuterCorner"]], [[0, 0, 0], [0, 1, 0]], null, o),
                i(QC.Block, Qg.BlackBlockSlopedUp, [["Blocks", "BlockSlopedUp"]], [[0, 0, 0], [0, 1, 0]], null, o),
                i(QC.Block, Qg.BlackBlockSlopedUpInnerCorner, [["Blocks", "BlockSlopedUpInnerCorner"]], [[0, 0, 0], [0, 1, 0]], null, o),
                i(QC.Block, Qg.BlackBlockSlopedUpOuterCorner, [["Blocks", "BlockSlopedUpOuterCorner"]], [[0, 0, 0], [0, 1, 0]], null, o),
                i(QC.Block, Qg.BlackBlockSlopeDown, [["Blocks", "BlockSlopeDown"]], null, null, o),
                i(QC.Block, Qg.BlackBlockSlopeUp, [["Blocks", "BlockSlopeUp"]], null, null, o),
                i(QC.Block, Qg.BlackBlockBridge, [["Blocks", "BlockBridge"]], null, null, o),
                i(QC.Block, Qg.BlackBlockBridgeCorner, [["Blocks", "BlockBridgeCorner"]], null, null, o),
                i(QC.Block, Qg.BlackBlockBridgeIntersectionT, [["Blocks", "BlockBridgeIntersectionT"]], null, null, o),
                i(QC.Block, Qg.BlackBlockBridgeIntersectionCross, [["Blocks", "BlockBridgeIntersectionCross"]], null, null, o),
                i(QC.WallTrack, Qg.WallTrackTop, [["WallTrack", "WallTrackTop"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]]),
                i(QC.WallTrack, Qg.WallTrackMiddle, [["WallTrack", "WallTrackMiddle"]]),
                i(QC.WallTrack, Qg.WallTrackBottom, [["WallTrack", "WallTrackBottom"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]]),
                i(QC.WallTrack, Qg.WallTrackTopCorner, [["WallTrack", "WallTrackTopCorner"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]]),
                i(QC.WallTrack, Qg.WallTrackMiddleCorner, [["WallTrack", "WallTrackMiddleCorner"]]),
                i(QC.WallTrack, Qg.WallTrackBottomCorner, [["WallTrack", "WallTrackBottomCorner"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]]),
                i(QC.WallTrack, Qg.WallTrackBottomInnerCorner, [["WallTrack", "WallTrackBottomInnerCorner"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]]),
                i(QC.WallTrack, Qg.WallTrackInnerCorner, [["WallTrack", "WallTrackInnerCorner"]]),
                i(QC.WallTrack, Qg.WallTrackTopInnerCorner, [["WallTrack", "WallTrackTopInnerCorner"]], [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]]),
                i(QC.WallTrack, Qg.WallTrackCeiling, [["WallTrack", "WallTrackCeiling"]]),
                i(QC.WallTrack, Qg.WallTrackFloor, [["WallTrack", "WallTrackFloor"]]),
                i(QC.Pillar, Qg.PillarTop, [["Pillar", "PillarTop"]]),
                i(QC.Pillar, Qg.PillarMiddle, [["Pillar", "PillarMiddle"]]),
                i(QC.Pillar, Qg.PillarBottom, [["Pillar", "PillarBottom"]]),
                i(QC.Pillar, Qg.PillarShort, [["Pillar", "PillarShort"]]),
                i(QC.Pillar, Qg.PillarBranch1, [["Pillar", "PillarBranch1"]]),
                i(QC.Pillar, Qg.PillarBranch1Top, [["Pillar", "PillarBranch1Top"]]),
                i(QC.Pillar, Qg.PillarBranch1Middle, [["Pillar", "PillarBranch1Middle"]]),
                i(QC.Pillar, Qg.PillarBranch1Bottom, [["Pillar", "PillarBranch1Bottom"]]),
                i(QC.Pillar, Qg.PillarBranch2, [["Pillar", "PillarBranch2"]]),
                i(QC.Pillar, Qg.PillarBranch2Top, [["Pillar", "PillarBranch2Top"]]),
                i(QC.Pillar, Qg.PillarBranch2Middle, [["Pillar", "PillarBranch2Middle"]]),
                i(QC.Pillar, Qg.PillarBranch2Bottom, [["Pillar", "PillarBranch2Bottom"]]),
                i(QC.Pillar, Qg.PillarBranch3, [["Pillar", "PillarBranch3"]]),
                i(QC.Pillar, Qg.PillarBranch3Top, [["Pillar", "PillarBranch3Top"]]),
                i(QC.Pillar, Qg.PillarBranch3Middle, [["Pillar", "PillarBranch3Middle"]]),
                i(QC.Pillar, Qg.PillarBranch3Bottom, [["Pillar", "PillarBranch3Bottom"]]),
                i(QC.Pillar, Qg.PillarBranch4, [["Pillar", "PillarBranch4"]]),
                i(QC.Pillar, Qg.PillarBranch4Top, [["Pillar", "PillarBranch4Top"]]),
                i(QC.Pillar, Qg.PillarBranch4Middle, [["Pillar", "PillarBranch4Middle"]]),
                i(QC.Pillar, Qg.PillarBranch4Bottom, [["Pillar", "PillarBranch4Bottom"]]),
                i(QC.Pillar, Qg.PillarBranch5, [["Pillar", "PillarBranch5"]]),
                i(QC.Pillar, Qg.PillarBranch5Top, [["Pillar", "PillarBranch5Top"]]),
                i(QC.Pillar, Qg.PillarBranch5Middle, [["Pillar", "PillarBranch5Middle"]]),
                i(QC.Pillar, Qg.PillarBranch5Bottom, [["Pillar", "PillarBranch5Bottom"]]),
                i(QC.Sign, Qg.SignArrowLeft, [["Signs", "SignArrowLeft"]]),
                i(QC.Sign, Qg.SignArrowRight, [["Signs", "SignArrowRight"]]),
                i(QC.Sign, Qg.SignArrowUp, [["Signs", "SignArrowUp"]]),
                i(QC.Sign, Qg.SignArrowDown, [["Signs", "SignArrowDown"]]),
                i(QC.Sign, Qg.SignWarning, [["Signs", "SignWarning"]]),
                i(QC.Sign, Qg.SignWrongWay, [["Signs", "SignWrongWay"]])
            }
            ))
        }
        ;
        var oA = n(367)
          , lA = {};
        lA.styleTagTransform = u(),
        lA.setAttributes = l(),
        lA.insert = s().bind(null, "head"),
        lA.domAPI = r(),
        lA.insertStyleElement = h();
        t()(oA.Z, lA);
        oA.Z && oA.Z.locals && oA.Z.locals;
        const cA = class {
            constructor() {
                this.transitionLayer = document.getElementById("transition-layer"),
                this.callback = null
            }
            trigger(e) {
                null == this.callback && (this.transitionLayer.style.opacity = "1",
                setTimeout((()=>{
                    this.transitionLayer.style.opacity = "0",
                    null != this.callback && (this.callback(),
                    this.callback = null)
                }
                ), 250)),
                this.callback = e
            }
        }
        ;
        var hA, dA, uA = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, pA = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        hA = new WeakMap,
        dA = new WeakMap;
        const fA = class {
            constructor(e, t, n) {
                hA.set(this, void 0),
                dA.set(this, void 0),
                uA(this, hA, t, "f");
                const i = e.getShadowDirection().negate();
                n.addResource();
                const r = (new Ul).load("images/clouds.jpg", (()=>{
                    n.loadedResource()
                }
                ));
                r.wrapT = P,
                r.wrapS = P;
                const a = new rl(1e6,5,2,0,2 * Math.PI,0,Math.PI)
                  , s = new wi({
                    defines: {
                        CLOUDS_ENABLED: t.getSettingBoolean(uc.CloudsEnabled)
                    },
                    uniforms: {
                        scrollA: {
                            value: new De(100 * Math.random(),100 * Math.random())
                        },
                        scrollB: {
                            value: new De(100 * Math.random(),100 * Math.random())
                        },
                        sampler: {
                            value: r
                        },
                        cloudDensity: {
                            value: .6
                        },
                        cloudLight: {
                            value: new ht(.75,.75,.75)
                        },
                        sunPosition: {
                            value: i
                        }
                    },
                    vertexShader: "\n\t\t\t\tvarying vec3 fPos;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewPosition;\n\t\t\t\t\tgl_Position.z = 0.0;\n\t\t\t\t\tfPos = position;\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\t\t\t\tvarying vec3 fPos;\n\n\t\t\t\tuniform vec2 offset;\n\t\t\t\tuniform vec2 scrollA;\n\t\t\t\tuniform vec2 scrollB;\n\t\t\t\tuniform sampler2D sampler;\n\n\t\t\t\tuniform float cloudDensity;\n\t\t\t\tuniform vec3 cloudLight;\n\n\t\t\t\tuniform vec3 sunPosition;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t#ifdef CLOUDS_ENABLED\n\t\t\t\t\t\tfloat c00 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) - scrollB.x * 0.981, fPos.z / ((fPos.y + 0.06) / 0.1) - scrollB.y * 1.041) + scrollA).r;\n\t\t\t\t\t\tfloat c10 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) + scrollB.x * 0.821, fPos.z / ((fPos.y + 0.06) / 0.1) - scrollB.y * 0.951) + scrollA).r;\n\t\t\t\t\t\tfloat c01 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) - scrollB.x * 1.043, fPos.z / ((fPos.y + 0.06) / 0.1) + scrollB.y * 0.899) + scrollA).r;\n\t\t\t\t\t\tfloat c11 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) + scrollB.x * 0.901, fPos.z / ((fPos.y + 0.06) / 0.1) + scrollB.y * 1.045) + scrollA).r;\n\t\t\t\t\t\tfloat cloud = min(1.0, max(0.0, (c00 + c10 + c01 + c11) / 4.0 - (1.0 - cloudDensity)) * 3.0);\n\n\t\t\t\t\t\tvec3 cloudColor = vec3(min(1.0, (c00 + c10 + c01 + c11) / 4.0 - (1.0 - cloudDensity)) * 4.0 + cloudDensity) * cloudLight;\n\t\t\t\t\t\tfloat cloudIntensity = cloud * min(1.0, max(0.0, fPos.y * 2.0 / 1000000.0));\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec3 cloudColor = vec3(0.0);\n\t\t\t\t\t\tfloat cloudIntensity = 0.0;\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tvec3 horizonColor = vec3(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0);\n\t\t\t\t\tvec3 zenithColor = vec3(5.0 / 255.0, 140.0 / 255.0, 255.0 / 255.0);\n\t\t\t\t\tfloat h = pow(clamp(fPos.y / 1000000.0, 0.01, 1.0), 0.2);\n\t\t\t\t\tvec3 skyColor = zenithColor * h + horizonColor * (1.0 - h);\n\n\t\t\t\t\tvec3 normal = normalize(-fPos);\n\t\t\t\t\tfloat sun = pow(max(0.0, max(0.0, dot(normal, sunPosition)) - 0.999), 4.0) * 60000000000.0;\n\t\t\t\t\tvec3 sunColor = vec3(20.0 * sun, 20.0 * sun, 19.0 * sun);\n\n\t\t\t\t\tgl_FragColor = vec4((skyColor * (1.0 - cloudIntensity) + cloudColor * cloudIntensity) * max(vec3(0.0), vec3(1.0) - sunColor) + sunColor, 1.0);\n\t\t\t\t}\n\t\t\t"
                });
                s.side = 1,
                s.depthWrite = !1,
                uA(this, dA, new di(a,s), "f"),
                pA(this, dA, "f").renderOrder = -3,
                pA(this, dA, "f").matrixAutoUpdate = !1,
                pA(this, dA, "f").updateMatrix(),
                e.scene.add(pA(this, dA, "f"))
            }
            update(e, t) {
                pA(this, hA, "f").getSettingBoolean(uc.CloudsEnabled) ? (pA(this, dA, "f").material.uniforms.scrollA.value.x += .00226 * e,
                pA(this, dA, "f").material.uniforms.scrollA.value.y += .001646 * e,
                pA(this, dA, "f").material.uniforms.scrollB.value.x += .001752 * e,
                pA(this, dA, "f").material.uniforms.scrollB.value.y += .001057 * e,
                1 != pA(this, dA, "f").material.defines.CLOUDS_ENABLED && (pA(this, dA, "f").material.defines.CLOUDS_ENABLED = !0,
                pA(this, dA, "f").material.needsUpdate = !0)) : 0 != pA(this, dA, "f").material.defines.CLOUDS_ENABLED && (pA(this, dA, "f").material.defines.CLOUDS_ENABLED = !1,
                pA(this, dA, "f").material.needsUpdate = !0),
                pA(this, dA, "f").position.copy(t.position),
                pA(this, dA, "f").updateMatrix()
            }
        }
        ;
        const mA = class {
            constructor() {
                this.token = null,
                this.nickname = TA.defaultNickname,
                this.carColors = Rh.random()
            }
        }
        ;
        var gA, vA, wA, yA, _A, xA, bA, EA = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, SA = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class MA {
            constructor(e) {
                var t;
                gA.add(this),
                wA.set(this, void 0),
                yA.set(this, void 0),
                _A.set(this, void 0),
                EA(this, wA, e, "f"),
                EA(this, yA, null !== (t = SA(this, wA, "f").loadUserProfileSlot()) && void 0 !== t ? t : 0, "f"),
                EA(this, _A, SA(this, gA, "m", bA).call(this, SA(this, yA, "f")), "f")
            }
            createProfile(e, t, n, i) {
                return !!this.isValidToken(t) && (SA(this, wA, "f").saveUserProfile(e, t, n, i),
                null != SA(this, wA, "f").loadUserProfile(e))
            }
            isValidToken(e) {
                return !(!/^[0-9a-f]*$/.test(e) || 64 != e.length)
            }
            hasDuplicateToken(e) {
                var t;
                for (let n = 0; n < 3; n++)
                    if ((null === (t = SA(this, wA, "f").loadUserProfile(n)) || void 0 === t ? void 0 : t.token) == e)
                        return !0;
                return !1
            }
            firstOccupiedProfileSlot() {
                for (let e = 0; e < 3; e++)
                    if (null != SA(this, wA, "f").loadUserProfile(e))
                        return e;
                return null
            }
            firstFreeProfileSlot() {
                for (let e = 0; e < 3; e++)
                    if (null == SA(this, wA, "f").loadUserProfile(e))
                        return e;
                return null
            }
            deleteProfileSlot(e) {
                SA(this, wA, "f").deleteAllRecords(e),
                SA(this, wA, "f").deleteUserProfile(e)
            }
            setProfileSlot(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                EA(this, yA, e, "f"),
                EA(this, _A, SA(this, gA, "m", bA).call(this, SA(this, yA, "f")), "f"),
                SA(this, wA, "f").saveUserProfileSlot(SA(this, yA, "f"))
            }
            setNickname(e, t=SA(this, yA, "f")) {
                let n;
                n = t == SA(this, yA, "f") ? SA(this, _A, "f") : SA(this, gA, "m", bA).call(this, t),
                n.nickname = e,
                SA(this, wA, "f").saveUserProfile(t, n.token, n.nickname, n.carColors)
            }
            setCarColors(e, t=SA(this, yA, "f")) {
                let n;
                n = t == SA(this, yA, "f") ? SA(this, _A, "f") : SA(this, gA, "m", bA).call(this, t),
                n.carColors = e,
                SA(this, wA, "f").saveUserProfile(t, n.token, n.nickname, n.carColors)
            }
            get profileSlot() {
                return SA(this, yA, "f")
            }
            getUserProfile(e=SA(this, yA, "f")) {
                var t;
                return e == SA(this, yA, "f") ? {
                    token: SA(this, _A, "f").token,
                    nickname: SA(this, _A, "f").nickname,
                    carColors: SA(this, _A, "f").carColors
                } : null !== (t = SA(this, wA, "f").loadUserProfile(e)) && void 0 !== t ? t : null
            }
            getToken(e=SA(this, yA, "f")) {
                var t, n;
                return e == SA(this, yA, "f") ? SA(this, _A, "f").token : null !== (n = null === (t = SA(this, wA, "f").loadUserProfile(e)) || void 0 === t ? void 0 : t.token) && void 0 !== n ? n : null
            }
            getTokenHash(e=SA(this, yA, "f")) {
                var t, n;
                let i;
                return i = e == SA(this, yA, "f") ? SA(this, _A, "f").token : null !== (n = null === (t = SA(this, wA, "f").loadUserProfile(e)) || void 0 === t ? void 0 : t.token) && void 0 !== n ? n : null,
                null == i ? null : (0,
                Mv.sha256)(i)
            }
            getNickname(e=SA(this, yA, "f")) {
                var t, n;
                return e == SA(this, yA, "f") ? SA(this, _A, "f").nickname : null !== (n = null === (t = SA(this, wA, "f").loadUserProfile(e)) || void 0 === t ? void 0 : t.nickname) && void 0 !== n ? n : vA.defaultNickname
            }
            getCarColors(e=SA(this, yA, "f")) {
                var t, n;
                return e == SA(this, yA, "f") ? SA(this, _A, "f").carColors : null !== (n = null === (t = SA(this, wA, "f").loadUserProfile(e)) || void 0 === t ? void 0 : t.carColors) && void 0 !== n ? n : Rh.random()
            }
            syncUserProfile(e) {
                const t = this.getUserProfile();
                null != t && e.getUser(t.token).then((e=>{
                    if (null == e)
                        return;
                    const n = this.getUserProfile();
                    null != n && n.token == t.token && n.nickname == t.nickname && n.carColors.serialize() == t.carColors.serialize() && (this.setNickname(e.name),
                    this.setCarColors(e.carColors))
                }
                )).catch((e=>{
                    console.error(e)
                }
                ))
            }
        }
        vA = MA,
        wA = new WeakMap,
        yA = new WeakMap,
        _A = new WeakMap,
        gA = new WeakSet,
        xA = function(e) {
            let t, n = "";
            try {
                const e = new Uint8Array(32);
                crypto.getRandomValues(e),
                n += e
            } catch (e) {}
            try {
                n += crypto.randomUUID()
            } catch (e) {}
            0 == n.length ? (t = null,
            console.error("Failed to generate user token")) : t = (0,
            Mv.sha256)(n);
            const i = vA.defaultNickname
              , r = Rh.random();
            SA(this, wA, "f").saveUserProfile(e, t, i, r)
        }
        ,
        bA = function(e) {
            var t;
            return null == SA(this, wA, "f").loadUserProfile(e) && SA(this, gA, "m", xA).call(this, e),
            null !== (t = SA(this, wA, "f").loadUserProfile(e)) && void 0 !== t ? t : new mA
        }
        ,
        MA.defaultNickname = "Anonymous";
        const TA = MA;
        var kA, CA, AA, PA, RA, LA, IA, NA, UA, DA, BA, OA, zA, FA, WA, HA, VA, GA, jA, XA = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class qA {
            constructor() {
                kA.add(this)
            }
            migrate(e) {
                XA(CA, CA, "f", AA) || XA(CA, CA, "f", PA) || XA(this, kA, "m", zA).call(this) || (XA(this, kA, "m", LA).call(this, e),
                XA(this, kA, "m", IA).call(this, e),
                XA(this, kA, "m", NA).call(this, e),
                XA(this, kA, "m", OA).call(this))
            }
            saveRecord(e, t, n, i, r) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                try {
                    localStorage.setItem(XA(CA, CA, "f", FA) + e + "_" + t, JSON.stringify({
                        uploadId: n,
                        frames: i.numberOfFrames.toString(),
                        recording: r.serialize()
                    }))
                } catch (e) {
                    console.error(e)
                }
            }
            loadRecord(e, t) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                try {
                    const n = localStorage.getItem(XA(CA, CA, "f", FA) + e + "_" + t);
                    if (null == n)
                        return null;
                    const i = JSON.parse(n);
                    if ("object" != typeof i)
                        return null;
                    if (!("uploadId"in i))
                        return null;
                    let r;
                    if (null == i.uploadId)
                        r = null;
                    else if (r = Number.parseInt(i.uploadId, 10),
                    !Number.isSafeInteger(r))
                        return null;
                    if (!("frames"in i))
                        return null;
                    const a = Number.parseInt(i.frames, 10);
                    if (!Number.isSafeInteger(a))
                        return null;
                    const s = new vd(a);
                    if (!("recording"in i))
                        return null;
                    const o = Gf.deserialize(i.recording);
                    return null == o ? null : {
                        uploadId: r,
                        time: s,
                        recording: o
                    }
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            deleteAllRecords(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                try {
                    Object.keys(localStorage).forEach((t=>{
                        t.startsWith(XA(CA, CA, "f", FA) + e + "_") && localStorage.removeItem(t)
                    }
                    ))
                } catch (e) {
                    console.error(e)
                }
            }
            saveTrack(e, t, n) {
                const i = t.toSaveString(n);
                try {
                    return localStorage.setItem(XA(CA, CA, "f", WA) + e, JSON.stringify({
                        data: i,
                        saveTime: (new Date).getTime()
                    })),
                    !0
                } catch (e) {
                    return console.error(e),
                    !1
                }
            }
            loadTrack(e, t) {
                let n, i;
                try {
                    const t = localStorage.getItem(XA(CA, CA, "f", WA) + e);
                    if (null == t)
                        return null;
                    const r = JSON.parse(t);
                    if ("string" != typeof r.data)
                        return null;
                    if ("number" != typeof r.saveTime)
                        return null;
                    n = r.data,
                    i = r.saveTime
                } catch (e) {
                    return console.error(e),
                    null
                }
                const r = Gv.fromSaveString(n, t);
                return null == r ? null : {
                    trackData: r,
                    saveTime: i
                }
            }
            deleteTrack(e) {
                try {
                    return localStorage.removeItem(XA(CA, CA, "f", WA) + e),
                    !0
                } catch (e) {
                    return console.error(e),
                    !1
                }
            }
            checkTrackExists(e) {
                try {
                    return null != localStorage.getItem(XA(CA, CA, "f", WA) + e)
                } catch (e) {
                    return null
                }
            }
            getAllTrackNames() {
                let e;
                try {
                    e = Object.keys(localStorage)
                } catch (e) {
                    return console.error(e),
                    null
                }
                return e.filter((e=>e.startsWith(XA(CA, CA, "f", WA)))).map((e=>e.substring(XA(CA, CA, "f", WA).length)))
            }
            saveUserProfileSlot(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                try {
                    localStorage.setItem(XA(CA, CA, "f", HA), JSON.stringify(e))
                } catch (e) {
                    console.error(e)
                }
            }
            loadUserProfileSlot() {
                try {
                    const e = localStorage.getItem(XA(CA, CA, "f", HA));
                    if (null != e)
                        try {
                            const t = JSON.parse(e);
                            if (!Number.isSafeInteger(t) || t < 0)
                                throw "Profile slot is invalid";
                            return t
                        } catch (e) {
                            console.error(e)
                        }
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            saveUserProfile(e, t, n, i) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                try {
                    localStorage.setItem(XA(CA, CA, "f", VA) + e, JSON.stringify({
                        token: t,
                        nickname: n,
                        carColors: i.serialize()
                    }))
                } catch (e) {
                    console.error(e)
                }
            }
            loadUserProfile(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw "Profile slot is invalid";
                try {
                    const t = localStorage.getItem(XA(CA, CA, "f", VA) + e);
                    if (null != t)
                        try {
                            const e = JSON.parse(t);
                            if ("object" != typeof e)
                                throw "User profile is not an object";
                            if ("string" != typeof e.token)
                                throw "User profile token field has invalid type";
                            if ("string" != typeof e.nickname)
                                throw "User profile nickname field has invalid type";
                            if ("string" != typeof e.carColors)
                                throw "User profile carColors field has invalid type";
                            return {
                                token: e.token,
                                nickname: e.nickname,
                                carColors: Rh.deserialize(e.carColors)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            deleteUserProfile(e) {
                try {
                    localStorage.removeItem(XA(CA, CA, "f", VA) + e)
                } catch (e) {
                    console.error(e)
                }
            }
            saveSettings(e) {
                try {
                    const t = [];
                    for (const [n,i] of e.entries())
                        t.push([uc[n], i]);
                    localStorage.setItem(XA(CA, CA, "f", GA), JSON.stringify(t))
                } catch (e) {
                    console.error(e)
                }
            }
            loadSettings() {
                try {
                    const e = localStorage.getItem(XA(CA, CA, "f", GA));
                    if (null == e)
                        return null;
                    const t = JSON.parse(e);
                    if (!Array.isArray(t))
                        return null;
                    const n = [];
                    return t.forEach((e=>{
                        if (!Array.isArray(e))
                            return;
                        if (2 != e.length)
                            return;
                        if ("string" != typeof e[0])
                            return;
                        const t = e[0]
                          , i = uc[t];
                        if (null == i)
                            return;
                        const r = e[1];
                        "string" == typeof e[1] && n.push([i, r])
                    }
                    )),
                    n
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            saveKeyBindings(e) {
                try {
                    const t = [];
                    for (const [n,i] of e.entries())
                        t.push([Xw[n], i]);
                    localStorage.setItem(XA(CA, CA, "f", jA), JSON.stringify(t))
                } catch (e) {
                    console.error(e)
                }
            }
            loadKeyBindings() {
                try {
                    const e = localStorage.getItem(XA(CA, CA, "f", jA));
                    if (null == e)
                        return null;
                    const t = JSON.parse(e);
                    if (!Array.isArray(t))
                        return null;
                    const n = [];
                    return t.forEach((e=>{
                        if (!Array.isArray(e))
                            return;
                        if (2 != e.length)
                            return;
                        if ("string" != typeof e[0])
                            return;
                        const t = e[0]
                          , i = Xw[t];
                        if (null == i)
                            return;
                        const r = e[1];
                        Array.isArray(r) && 2 == r.length && (null != r[0] && "string" != typeof r[0] || null != r[1] && "string" != typeof r[1] || n.push([i, r]))
                    }
                    )),
                    n
                } catch (e) {
                    console.error(e)
                }
                return null
            }
        }
        CA = qA,
        kA = new WeakSet,
        LA = function(e) {
            try {
                Object.keys(localStorage).forEach((t=>{
                    if ("car_colors" == t)
                        try {
                            const e = localStorage.getItem(t);
                            if (null != e) {
                                const n = JSON.parse(e)
                                  , i = new Rh(new An(n[0]),new An(n[1]),new An(n[2]),new An(n[3]));
                                XA(this, kA, "m", DA).call(this, i),
                                localStorage.removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("record_"))
                        try {
                            localStorage.removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("custom_track_"))
                        try {
                            const n = localStorage.getItem(t);
                            if (null != n) {
                                const i = Uv(JSON.parse(n), e);
                                if (null != i) {
                                    const {trackName: n, trackData: r} = i;
                                    this.saveTrack(n, r, e) && localStorage.removeItem(t)
                                }
                            }
                        } catch (e) {
                            console.error(e)
                        }
                }
                ))
            } catch (e) {
                console.error(e)
            }
        }
        ,
        IA = function(e) {
            try {
                Object.keys(localStorage).forEach((t=>{
                    if ("v1_car" == t)
                        try {
                            const e = localStorage.getItem(t);
                            if (null != e) {
                                const n = JSON.parse(e)
                                  , i = new Rh(new An(n[0]),new An(n[1]),new An(n[2]),new An(n[3]));
                                XA(this, kA, "m", DA).call(this, i),
                                localStorage.removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("v1_record_"))
                        try {
                            localStorage.removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("v1_track_"))
                        try {
                            const n = localStorage.getItem(t);
                            if (null != n) {
                                const i = t.substring("v1_track_".length)
                                  , r = Dv(n, e);
                                if (null == r)
                                    throw "Failed to load v1 track for migration";
                                if (!this.saveTrack(i, r, e))
                                    throw "Failed to save v1 track for migration";
                                localStorage.removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                }
                ))
            } catch (e) {
                console.error(e)
            }
        }
        ,
        NA = function(e) {
            try {
                Object.keys(localStorage).forEach((t=>{
                    if ("v2_car" == t)
                        try {
                            const e = localStorage.getItem(t);
                            if (null != e) {
                                const n = Rh.deserialize(e);
                                XA(this, kA, "m", DA).call(this, n),
                                localStorage.removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                    if ("v2_user" == t)
                        try {
                            const e = localStorage.getItem(t);
                            if (null != e) {
                                const n = JSON.parse(e);
                                if (Array.isArray(n) || "object" != typeof n)
                                    throw "User profile is not an object";
                                const i = n.token;
                                if (null != i && "string" != typeof i)
                                    throw "User profile token is not a string";
                                const r = n.nickname;
                                if ("string" != typeof r)
                                    throw "User profile nickname is not a string";
                                const a = Rh.random();
                                XA(this, kA, "m", UA).call(this, i, r, a),
                                localStorage.removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("v2_record_"))
                        try {
                            localStorage.removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("v2_track_"))
                        try {
                            const n = localStorage.getItem(t);
                            if (null != n) {
                                const i = t.substring("v2_track_".length)
                                  , r = Bv(n, e);
                                if (null == r)
                                    throw "Failed to load v2 track for migration";
                                if (!this.saveTrack(i, r, e))
                                    throw "Failed to save v2 track for migration";
                                localStorage.removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                }
                ))
            } catch (e) {
                console.error(e)
            }
        }
        ,
        UA = function(e, t, n) {
            var i;
            const r = this.loadUserProfile(0);
            null == r ? this.saveUserProfile(0, e, t, n) : this.saveUserProfile(0, null !== (i = r.token) && void 0 !== i ? i : e, r.nickname, r.carColors)
        }
        ,
        DA = function(e) {
            const t = this.loadUserProfile(0);
            null == t ? this.saveUserProfile(0, null, TA.defaultNickname, e) : this.saveUserProfile(0, t.token, t.nickname, e)
        }
        ,
        OA = function() {
            try {
                localStorage.setItem(XA(CA, CA, "f", BA), "")
            } catch (e) {
                console.error(e)
            }
        }
        ,
        zA = function() {
            try {
                return null != localStorage.getItem(XA(CA, CA, "f", BA))
            } catch (e) {
                console.error(e)
            }
            return !1
        }
        ,
        AA = {
            value: "0.0.0" == _k.i8
        },
        PA = {
            value: _k.i8.toLowerCase().includes("beta")
        },
        RA = {
            value: "polytrack_v3_" + (XA(CA, CA, "f", AA) ? "dev_" : "") + (XA(CA, CA, "f", PA) ? "beta_" : "")
        },
        BA = {
            value: XA(CA, CA, "f", RA) + "migrated"
        },
        FA = {
            value: XA(CA, CA, "f", RA) + "record_"
        },
        WA = {
            value: XA(CA, CA, "f", RA) + "track_"
        },
        HA = {
            value: XA(CA, CA, "f", RA) + "user_slot"
        },
        VA = {
            value: XA(CA, CA, "f", RA) + "user_"
        },
        GA = {
            value: XA(CA, CA, "f", RA) + "settings"
        },
        jA = {
            value: XA(CA, CA, "f", RA) + "key_bindings"
        };
        const YA = qA;
        var ZA, KA, JA, QA, $A, eP, tP, nP = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, iP = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        class rP {
            constructor() {
                ZA.add(this),
                JA.set(this, void 0),
                QA.set(this, !1),
                $A.set(this, null);
                const e = document.getElementById("ui");
                if (null == e)
                    throw "Failed to find UI element";
                nP(this, JA, e, "f"),
                window.addEventListener("mousemove", (()=>{
                    document.body.classList.remove("hide-cursor"),
                    iP(this, QA, "f") && (null != iP(this, $A, "f") && clearTimeout(iP(this, $A, "f")),
                    nP(this, $A, setTimeout((()=>{
                        document.body.classList.add("hide-cursor"),
                        nP(this, $A, null, "f")
                    }
                    ), iP(KA, KA, "f", eP)), "f"))
                }
                )),
                window.addEventListener("resize", (()=>{
                    iP(this, ZA, "m", tP).call(this)
                }
                )),
                iP(this, ZA, "m", tP).call(this)
            }
            setCursorHiddenWhenInactive(e) {
                nP(this, QA, e, "f"),
                e ? nP(this, $A, setTimeout((()=>{
                    document.body.classList.add("hide-cursor"),
                    nP(this, $A, null, "f")
                }
                ), iP(KA, KA, "f", eP)), "f") : (document.body.classList.remove("hide-cursor"),
                null != iP(this, $A, "f") && (clearTimeout(iP(this, $A, "f")),
                nP(this, $A, null, "f")))
            }
        }
        KA = rP,
        JA = new WeakMap,
        QA = new WeakMap,
        $A = new WeakMap,
        ZA = new WeakSet,
        tP = function() {
            const e = Math.max(.01, Math.min(window.innerWidth, 1.4375 * window.innerHeight) / 1150);
            e < 1 ? (iP(this, JA, "f").style.width = "calc(100% / " + e + ")",
            iP(this, JA, "f").style.height = "calc(100% / " + e + ")",
            iP(this, JA, "f").style.transform = "scale(" + e + ")") : (iP(this, JA, "f").style.width = "",
            iP(this, JA, "f").style.height = "",
            iP(this, JA, "f").style.transform = "")
        }
        ,
        eP = {
            value: 1e3
        };
        const aP = rP;
        var sP, oP, lP = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, cP = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        const hP = "https://vps.kodub.com:43274/";
        sP = new WeakMap,
        oP = new WeakMap;
        const dP = class {
            constructor(e) {
                sP.set(this, void 0),
                this.submitAllowed = !1,
                oP.set(this, 1e4),
                lP(this, sP, e, "f")
            }
            getLeaderboard(e, t, n, i) {
                const r = cP(this, sP, "f").getTokenHash();
                let a = hP + "leaderboard?version=" + _k.i8 + "&trackId=" + e + "&skip=" + t + "&amount=" + n + "&onlyVerified=" + i;
                return null != r && (a += "&userTokenHash=" + encodeURIComponent(r)),
                new Promise(((e,t)=>{
                    const n = new XMLHttpRequest;
                    n.overrideMimeType("text/plain"),
                    n.onreadystatechange = ()=>{
                        if (n.readyState == XMLHttpRequest.DONE)
                            if (200 == n.status)
                                try {
                                    const i = JSON.parse(n.responseText)
                                      , r = i.total;
                                    if ("number" != typeof r)
                                        return void t("Total is not a number");
                                    if (!Number.isSafeInteger(r))
                                        return void t("Total is not a safe integer");
                                    const a = i.entries;
                                    if (!Array.isArray(a))
                                        return void t("Entries is not an array");
                                    const s = [];
                                    for (let e = 0; e < a.length; e++) {
                                        const n = a[e];
                                        if (null == n)
                                            return void t("Entry is missing");
                                        if (!Object.prototype.hasOwnProperty.call(n, "id"))
                                            return void t('Entry is missing "id" field');
                                        if (!Object.prototype.hasOwnProperty.call(n, "name"))
                                            return void t('Entry is missing "name" field');
                                        if (!Object.prototype.hasOwnProperty.call(n, "frames"))
                                            return void t('Entry is missing "frames" field');
                                        if (!Object.prototype.hasOwnProperty.call(n, "carColors"))
                                            return void t('Entry is missing "carColors" field');
                                        if (!Object.prototype.hasOwnProperty.call(n, "verifiedState"))
                                            return void t('Entry is missing "verifiedState" field');
                                        if (!Object.prototype.hasOwnProperty.call(n, "isSelf"))
                                            return void t('Entry is missing "isSelf" field');
                                        if ("number" != typeof n.id)
                                            return void t('"id" field has incorrect type');
                                        if ("string" != typeof n.name)
                                            return void t('"name" field has incorrect type');
                                        if ("number" != typeof n.frames)
                                            return void t('"frames" field has incorrect type');
                                        if (!Number.isSafeInteger(n.frames))
                                            return void t('"frames" field has an invalid value');
                                        if ("string" != typeof n.carColors)
                                            return void t('"carColors" field has incorrect type');
                                        let i = null;
                                        if (null != n.verifiedState) {
                                            if ("boolean" != typeof n.verifiedState)
                                                return void t('"verifiedState" field has incorrect type');
                                            i = 1 == n.verifiedState
                                        }
                                        s.push({
                                            id: n.id,
                                            name: n.name,
                                            time: new vd(n.frames),
                                            carColors: Rh.deserialize(n.carColors),
                                            verifiedState: i,
                                            isSelf: 1 == n.isSelf
                                        })
                                    }
                                    let o = null;
                                    if (null != i.userEntry) {
                                        const e = i.userEntry.position;
                                        if ("number" != typeof e)
                                            return void t("User position is not a number");
                                        if (!Number.isSafeInteger(e))
                                            return void t("User position is not a safe integer");
                                        const n = i.userEntry.frames;
                                        if ("number" != typeof n)
                                            return void t("User frames is not a number");
                                        if (!Number.isSafeInteger(n))
                                            return void t("User frames is not a safe integer");
                                        const r = new vd(n)
                                          , a = i.userEntry.id;
                                        if ("number" != typeof a)
                                            return void t("User record id is not a number");
                                        if (!Number.isSafeInteger(a))
                                            return void t("User record id is not a safe integer");
                                        o = {
                                            position: e,
                                            time: r,
                                            id: a
                                        }
                                    }
                                    e({
                                        total: r,
                                        entries: s,
                                        userEntry: o
                                    })
                                } catch (e) {
                                    t("Unknown error: " + e)
                                }
                            else
                                t("Failed to connect to server, status: " + n.status)
                    }
                    ,
                    n.open("GET", a, !0),
                    n.send()
                }
                ))
            }
            getRecording(e) {
                const t = hP + "recording?version=" + _k.i8 + "&recordingId=" + e;
                return new Promise(((e,n)=>{
                    const i = new XMLHttpRequest;
                    i.overrideMimeType("text/plain"),
                    i.onreadystatechange = ()=>{
                        if (i.readyState == XMLHttpRequest.DONE)
                            if (200 == i.status)
                                try {
                                    const t = JSON.parse(i.responseText);
                                    if ("string" != typeof t.recording)
                                        return void n("JSON recording field has incorrect type");
                                    const r = Gf.deserialize(t.recording);
                                    if (null == r)
                                        return void n("Failed to deserialize recording");
                                    let a = null;
                                    if (null != t.verifiedState) {
                                        if ("boolean" != typeof t.verifiedState)
                                            return void n("JSON verifiedState field has incorrect type");
                                        a = 1 == t.verifiedState
                                    }
                                    if ("number" != typeof t.frames)
                                        return void n("JSON frames field has incorrect type");
                                    const s = t.frames;
                                    if (!Number.isSafeInteger(s))
                                        return void n("JSON frames is not a safe integer");
                                    const o = new vd(s);
                                    if ("string" != typeof t.carColors)
                                        return void n("JSON carColors field has incorrect type");
                                    const l = Rh.deserialize(t.carColors);
                                    e({
                                        recording: r,
                                        time: o,
                                        verifiedState: a,
                                        carColors: l
                                    })
                                } catch (e) {
                                    n("Unknown error: " + e)
                                }
                            else
                                n("Failed to connect to server, status: " + i.status)
                    }
                    ,
                    i.open("GET", t, !0),
                    i.send()
                }
                ))
            }
            submitLeaderboard(e, t, n, i) {
                return new Promise(((r,a)=>{
                    const s = cP(this, sP, "f").getToken();
                    if (this.submitAllowed && null != s) {
                        const o = cP(this, sP, "f").getNickname()
                          , l = n.serialize();
                        if (l.length >= cP(this, oP, "f"))
                            a("Recording is too large");
                        else {
                            const n = hP + "leaderboard"
                              , c = "version=" + _k.i8 + "&userToken=" + encodeURIComponent(s) + "&name=" + encodeURIComponent(o) + "&carColors=" + i.serialize() + "&trackId=" + e + "&frames=" + t.numberOfFrames + "&recording=" + l
                              , h = new XMLHttpRequest;
                            h.overrideMimeType("text/plain"),
                            h.onreadystatechange = ()=>{
                                if (4 == h.readyState)
                                    if (200 == h.status)
                                        try {
                                            const e = JSON.parse(h.responseText);
                                            if (null == e)
                                                r({
                                                    uploadId: null
                                                });
                                            else {
                                                const t = Number.parseInt(e, 10);
                                                Number.isSafeInteger(t) ? r({
                                                    uploadId: t
                                                }) : a("UploadId is not a safe integer")
                                            }
                                        } catch (e) {
                                            a("Unknown error: " + e)
                                        }
                                    else
                                        a("Failed to connect to server, status: " + h.status)
                            }
                            ,
                            h.open("POST", n, !0),
                            h.send(c)
                        }
                    } else
                        r({
                            uploadId: null
                        })
                }
                ))
            }
            submitUserProfile(e, t, n) {
                return new Promise(((i,r)=>{
                    if (this.submitAllowed && null != e) {
                        const a = hP + "user"
                          , s = "version=" + _k.i8 + "&userToken=" + encodeURIComponent(e) + "&name=" + encodeURIComponent(t) + "&carColors=" + n.serialize()
                          , o = new XMLHttpRequest;
                        o.overrideMimeType("text/plain"),
                        o.onreadystatechange = ()=>{
                            4 == o.readyState && (200 == o.status ? i() : r("Failed to connect to server, status: " + o.status))
                        }
                        ,
                        o.open("POST", a, !0),
                        o.send(s)
                    } else
                        i()
                }
                ))
            }
            verifyRecordings(e, t, n, i) {
                return new Promise(((r,a)=>{
                    if (this.submitAllowed)
                        if (null == e)
                            a("No user token");
                        else {
                            const s = hP + "verifyRecordings"
                              , o = "version=" + _k.i8 + "&userToken=" + encodeURIComponent(e) + (null != t ? "&trackId=" + t : "") + "&maxFrames=" + n.numberOfFrames + "&recordings=" + encodeURIComponent(JSON.stringify(i))
                              , l = new XMLHttpRequest;
                            l.overrideMimeType("text/plain"),
                            l.onreadystatechange = ()=>{
                                if (4 == l.readyState)
                                    if (200 == l.status)
                                        try {
                                            if ("" == l.responseText)
                                                return void r({
                                                    unverifiedRecordings: [],
                                                    exhaustive: !0
                                                });
                                            const e = JSON.parse(l.responseText);
                                            if (!("exhaustive"in e))
                                                return void a('Field "exhaustive" does not exist');
                                            const t = 1 == e.exhaustive;
                                            if (!("unverifiedRecordings"in e))
                                                return void a('Field "unverifiedRecordings" does not exist');
                                            const n = e.unverifiedRecordings;
                                            if (!Array.isArray(n))
                                                return void a('Field "unverifiedRecordings" is not an array');
                                            for (let e = 0; e < n.length; e++) {
                                                const t = n[e];
                                                if ("object" != typeof t)
                                                    return void a("Recording is not an object");
                                                if ("number" != typeof t.id || !Number.isSafeInteger(t.id))
                                                    return void a("Recording id is not a valid integer");
                                                if ("string" != typeof t.recording)
                                                    return void a("Recording recording is not a string");
                                                if ("number" != typeof t.frames || t.frames <= 0 || !Number.isSafeInteger(t.frames))
                                                    return void a("Recording frames is not a valid integer")
                                            }
                                            r({
                                                unverifiedRecordings: n,
                                                exhaustive: t
                                            })
                                        } catch (e) {
                                            a("Unknown error: " + e)
                                        }
                                    else
                                        403 == l.status ? a("User is not a verifier") : a("Failed to connect to server, status: " + l.status)
                            }
                            ,
                            l.open("POST", s, !0),
                            l.send(o)
                        }
                    else
                        a("Submit not allowed")
                }
                ))
            }
            getUser(e) {
                return new Promise(((t,n)=>{
                    if (null == e)
                        n("No user token");
                    else {
                        const i = hP + "user?version=" + _k.i8 + "&userToken=" + encodeURIComponent(e)
                          , r = new XMLHttpRequest;
                        r.overrideMimeType("text/plain"),
                        r.onreadystatechange = ()=>{
                            if (r.readyState == XMLHttpRequest.DONE)
                                if (200 == r.status)
                                    try {
                                        const e = JSON.parse(r.responseText)
                                          , i = e.name;
                                        if ("string" != typeof i)
                                            return void n("Name is not a string");
                                        if (0 == i.length || i.length > 50)
                                            return void n("Name as invalid length");
                                        const a = e.carColors;
                                        if ("string" != typeof a)
                                            return void n("CarColors data is not a string");
                                        const s = Rh.deserialize(a)
                                          , o = e.isVerifier;
                                        if ("boolean" != typeof o)
                                            return void n("IsVerifier is not a boolean");
                                        t({
                                            name: i,
                                            carColors: s,
                                            isVerifier: o
                                        })
                                    } catch (e) {
                                        n("Unknown error: " + e)
                                    }
                                else
                                    n("Failed to connect to server, status: " + r.status)
                        }
                        ,
                        r.open("GET", i, !0),
                        r.send()
                    }
                }
                ))
            }
        }
        ;
        var uP, pP, fP, mP, gP, vP = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, wP = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        pP = new WeakMap,
        fP = new WeakMap,
        mP = new WeakMap,
        uP = new WeakSet,
        gP = function(e) {
            e.forEach((([e,t])=>{
                if (!wP(this, mP, "f").has(e))
                    throw "Key binding is missing";
                wP(this, mP, "f").set(e, t)
            }
            ))
        }
        ;
        const yP = class {
            constructor(e) {
                uP.add(this),
                pP.set(this, void 0),
                fP.set(this, this.defaultSettings()),
                mP.set(this, this.defaultKeyBindings()),
                vP(this, pP, e, "f");
                const t = e.loadSettings();
                null != t && this.updateSettings(t);
                const n = e.loadKeyBindings();
                null != n && wP(this, uP, "m", gP).call(this, n)
            }
            defaultSettings() {
                return new Map([[uc.ImperialUnitsEnabled, "false"], [uc.ResetHintEnabled, "true"], [uc.GhostCarEnabled, "true"], [uc.CockpitCameraToggle, "true"], [uc.CheckpointsPosition, "false"], [uc.TimerPosition, "false"], [uc.SpeedometerPosition, "false"], [uc.Language, "en-US"], [uc.CarShadowQuality, "2048"], [uc.TrackShadowEnabled, "true"], [uc.CloudsEnabled, "true"], [uc.ParticlesEnabled, "true"], [uc.SkidmarksEnabled, "true"], [uc.RenderScale, "1"], [uc.Antialiasing, "true"], [uc.SoundEffectVolume, "1"], [uc.MusicVolume, "1"], [uc.CheckpointVolume, "1"]])
            }
            defaultKeyBindings() {
                return new Map([[Xw.VehicleAccelerate, ["KeyW", "ArrowUp"]], [Xw.VehicleTurnRight, ["KeyD", "ArrowRight"]], [Xw.VehicleBrake, ["KeyS", "ArrowDown"]], [Xw.VehicleTurnLeft, ["KeyA", "ArrowLeft"]], [Xw.VehicleReset, ["KeyR", "Enter"]], [Xw.VehicleCockpitCamera, ["KeyC", "KeyM"]], [Xw.ToggleUI, ["KeyH", null]], [Xw.EditorRotate, ["KeyR", "Space"]], [Xw.EditorHeightModifier, ["ShiftLeft", "ShiftRight"]], [Xw.EditorDelete, ["Delete", "KeyX"]], [Xw.EditorMoveForwards, ["KeyW", "ArrowUp"]], [Xw.EditorMoveRight, ["KeyD", "ArrowRight"]], [Xw.EditorMoveBackwards, ["KeyS", "ArrowDown"]], [Xw.EditorMoveLeft, ["KeyA", "ArrowLeft"]], [Xw.EditorRotateLeft, ["KeyQ", null]], [Xw.EditorRotateRight, ["KeyE", null]], [Xw.EditorMoveDown, ["KeyZ", null]], [Xw.EditorMoveUp, ["KeyC", null]], [Xw.EditorTest, ["KeyT", null]], [Xw.EditorPick, ["KeyG", null]], [Xw.ToggleFpsCounter, ["Comma", null]], [Xw.ToggleSpectatorCamera, ["Period", null]], [Xw.SpectatorMoveForwards, ["KeyW", "ArrowUp"]], [Xw.SpectatorMoveRight, ["KeyD", "ArrowRight"]], [Xw.SpectatorMoveBackwards, ["KeyS", "ArrowDown"]], [Xw.SpectatorMoveLeft, ["KeyA", "ArrowLeft"]], [Xw.SpectatorSpeedModifier, ["ShiftLeft", "ShiftRight"]]])
            }
            getSettings() {
                return Array.from(wP(this, fP, "f"))
            }
            getSetting(e) {
                const t = wP(this, fP, "f").get(e);
                if (null == t)
                    throw "Setting name is missing";
                return t
            }
            getSettingBoolean(e) {
                return "true" == this.getSetting(e)
            }
            getSettingFloat(e) {
                return parseFloat(this.getSetting(e))
            }
            getSettingInteger(e) {
                return parseInt(this.getSetting(e), 10)
            }
            updateSettings(e) {
                e.forEach((([e,t])=>{
                    if (!wP(this, fP, "f").has(e))
                        throw "Setting name is missing";
                    wP(this, fP, "f").set(e, t)
                }
                ))
            }
            saveSettings() {
                wP(this, pP, "f").saveSettings(wP(this, fP, "f"))
            }
            getKeyBindings(e) {
                var t;
                return null !== (t = wP(this, mP, "f").get(e)) && void 0 !== t ? t : [null, null]
            }
            setKeyBindings(e) {
                wP(this, uP, "m", gP).call(this, e),
                wP(this, pP, "f").saveKeyBindings(wP(this, mP, "f"))
            }
            checkKeyBinding(e, t) {
                var n;
                const i = null !== (n = wP(this, mP, "f").get(t)) && void 0 !== n ? n : [];
                for (let t = 0; t < i.length; t++) {
                    const n = i[t];
                    if (null != n && e.code == n)
                        return !0
                }
                return !1
            }
        }
        ;
        var _P;
        !function(e) {
            e[e.Init = 0] = "Init",
            e[e.Verify = 1] = "Verify",
            e[e.TestDeterminism = 2] = "TestDeterminism",
            e[e.CreateCar = 3] = "CreateCar",
            e[e.DeleteCar = 4] = "DeleteCar",
            e[e.StartCar = 5] = "StartCar",
            e[e.ControlCar = 6] = "ControlCar",
            e[e.PauseCar = 7] = "PauseCar",
            e[e.VerifyResult = 8] = "VerifyResult",
            e[e.DeterminismResult = 9] = "DeterminismResult",
            e[e.UpdateResult = 10] = "UpdateResult"
        }(_P || (_P = {}));
        const xP = _P;
        var bP, EP, SP, MP, TP, kP, CP = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, AP = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        EP = new WeakMap,
        SP = new WeakMap,
        MP = new WeakMap,
        TP = new WeakMap,
        bP = new WeakSet,
        kP = function(e) {
            AP(this, SP, "f").postMessage({
                messageType: xP.Init,
                trackParts: e.getPhysicsParts()
            })
        }
        ;
        const PP = class {
            constructor(e, t) {
                bP.add(this),
                EP.set(this, void 0),
                SP.set(this, void 0),
                MP.set(this, !1),
                TP.set(this, 0),
                CP(this, SP, new Worker("simulation_worker.bundle.js"), "f"),
                null != e && null != t ? (CP(this, EP, e, "f"),
                t.hasLoaded() ? AP(this, bP, "m", kP).call(this, e) : t.addCompleteListener((()=>{
                    AP(this, bP, "m", kP).call(this, e)
                }
                ))) : CP(this, EP, null, "f")
            }
            dispose() {
                AP(this, SP, "f").terminate(),
                CP(this, MP, !0, "f")
            }
            validate(e, t, n) {
                return new Promise(((i,r)=>{
                    var a, s;
                    const o = e.getStartTransform();
                    if (null == o)
                        i(!1);
                    else {
                        const l = sM.createMountainVertices(e.getBounds());
                        if (null == AP(this, EP, "f"))
                            throw "TrackPartManager is not initialized";
                        if (null == Jm.models)
                            throw "Car collision model not loaded";
                        const c = (CP(this, TP, (s = AP(this, TP, "f"),
                        a = s++,
                        s), "f"),
                        a)
                          , h = setInterval((()=>{
                            AP(this, MP, "f") && (clearInterval(h),
                            r("Simulation has been disposed"))
                        }
                        ), 10);
                        AP(this, SP, "f").addEventListener("message", (e=>{
                            e.data.messageType == xP.VerifyResult && e.data.carId == c && (clearInterval(h),
                            i(e.data.result))
                        }
                        )),
                        AP(this, SP, "f").postMessage({
                            messageType: xP.Verify,
                            mountainVertices: l.vertices,
                            mountainOffset: {
                                x: l.offset.x,
                                y: l.offset.y,
                                z: l.offset.z
                            },
                            trackData: e.toSaveString(AP(this, EP, "f")),
                            carId: c,
                            carCollisionShapeVertices: Jm.models.collisionShapeVertices,
                            carMassOffset: Jm.massOffset,
                            carRecording: t.serialize(),
                            carPosition: {
                                x: o.position.x,
                                y: o.position.y,
                                z: o.position.z
                            },
                            carQuaternion: {
                                x: o.quaternion.x,
                                y: o.quaternion.y,
                                z: o.quaternion.z,
                                w: o.quaternion.w
                            },
                            targetFrames: n.numberOfFrames
                        })
                    }
                }
                ))
            }
            testDeterminism() {
                return new Promise((e=>{
                    const t = n=>{
                        if (n.data.messageType === xP.DeterminismResult)
                            e(n.data.isDeterminstic),
                            AP(this, SP, "f").removeEventListener("message", t)
                    }
                    ;
                    AP(this, SP, "f").addEventListener("message", t),
                    AP(this, SP, "f").postMessage({
                        messageType: xP.TestDeterminism
                    })
                }
                ))
            }
            createCar(e, t, n, i, r, a) {
                var s, o;
                if (null == AP(this, EP, "f"))
                    throw "TrackPartManager is not initialized";
                if (null == Jm.models)
                    throw "Car collision model not loaded";
                const l = (CP(this, TP, (o = AP(this, TP, "f"),
                s = o++,
                o), "f"),
                s);
                AP(this, SP, "f").addEventListener("message", (e=>{
                    if (e.data.messageType == xP.UpdateResult) {
                        e.data.carStates.forEach((e=>{
                            e.id == l && a(e)
                        }
                        ))
                    }
                }
                )),
                AP(this, SP, "f").postMessage({
                    messageType: xP.CreateCar,
                    mountainVertices: t,
                    mountainOffset: {
                        x: n.x,
                        y: n.y,
                        z: n.z
                    },
                    trackData: i.toSaveString(AP(this, EP, "f")),
                    carId: l,
                    carCollisionShapeVertices: Jm.models.collisionShapeVertices,
                    carMassOffset: Jm.massOffset,
                    carPosition: {
                        x: e.position.x,
                        y: e.position.y,
                        z: e.position.z
                    },
                    carQuaternion: {
                        x: e.quaternion.x,
                        y: e.quaternion.y,
                        z: e.quaternion.z,
                        w: e.quaternion.w
                    },
                    carRecording: null == r ? void 0 : r.serialize()
                });
                const c = .11898833513259888
                  , h = [new ht(.627909,.15101166486740114,1.3478).applyQuaternion(e.quaternion).add(e.position), new ht(-.627909,.15101166486740114,1.3478).applyQuaternion(e.quaternion).add(e.position), new ht(.720832,.15101166486740114,-1.52686).applyQuaternion(e.quaternion).add(e.position), new ht(-.720832,.15101166486740114,-1.52686).applyQuaternion(e.quaternion).add(e.position)]
                  , d = [(new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(e.quaternion), (new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(e.quaternion), (new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(e.quaternion), (new ct).setFromEuler((new Kt).set(0, Math.PI, 0)).multiply(e.quaternion)];
                return {
                    id: l,
                    frames: 0,
                    totalFrames: 0,
                    speedKmh: 0,
                    hasStarted: !1,
                    hasFinished: !1,
                    nextCheckpointIndex: 0,
                    position: {
                        x: e.position.x,
                        y: e.position.y,
                        z: e.position.z
                    },
                    quaternion: {
                        x: e.quaternion.x,
                        y: e.quaternion.y,
                        z: e.quaternion.z,
                        w: e.quaternion.w
                    },
                    collisionImpulses: [],
                    wheelInContact: [!1, !1, !1, !1],
                    wheelSuspensionLength: [c, c, c, c],
                    wheelSuspensionVelocity: [0, 0, 0, 0],
                    wheelRotation: [0, 0, 0, 0],
                    wheelDeltaRotation: [0, 0, 0, 0],
                    wheelSkidInfo: [0, 0, 0, 0],
                    wheelPosition: h,
                    wheelQuaternion: d,
                    brakeLightEnabled: !1,
                    controls: {
                        up: !1,
                        right: !1,
                        down: !1,
                        left: !1
                    }
                }
            }
            deleteCar(e) {
                AP(this, SP, "f").postMessage({
                    messageType: xP.DeleteCar,
                    carId: e
                })
            }
            startCar(e, t) {
                AP(this, SP, "f").postMessage({
                    messageType: xP.StartCar,
                    carId: e,
                    targetSimulationTimeFrames: null == t ? void 0 : t.numberOfFrames
                })
            }
            controlCar(e, t, n, i, r) {
                AP(this, SP, "f").postMessage({
                    messageType: xP.ControlCar,
                    carId: e,
                    up: t,
                    right: n,
                    down: i,
                    left: r
                })
            }
            pauseCar(e, t) {
                AP(this, SP, "f").postMessage({
                    messageType: xP.PauseCar,
                    carId: e,
                    isPaused: t
                })
            }
        }
        ;
        var RP = n(4)
          , LP = {};
        LP.styleTagTransform = u(),
        LP.setAttributes = l(),
        LP.insert = s().bind(null, "head"),
        LP.domAPI = r(),
        LP.insertStyleElement = h();
        t()(RP.Z, LP);
        RP.Z && RP.Z.locals && RP.Z.locals;
        var IP, NP, UP, DP, BP = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, OP = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        IP = new WeakMap,
        NP = new WeakMap,
        UP = new WeakMap,
        DP = new WeakMap;
        const zP = class {
            constructor(e, t) {
                IP.set(this, void 0),
                NP.set(this, void 0),
                UP.set(this, void 0),
                DP.set(this, void 0),
                BP(this, IP, document.getElementById("ui"), "f"),
                BP(this, NP, document.createElement("div"), "f"),
                OP(this, NP, "f").className = "verifier-ui",
                OP(this, IP, "f").appendChild(OP(this, NP, "f")),
                BP(this, UP, document.createElement("p"), "f"),
                OP(this, NP, "f").appendChild(OP(this, UP, "f"));
                const n = document.createElement("button");
                n.className = "button",
                n.textContent = "Stop",
                n.addEventListener("click", (()=>{
                    e.playUIClick(),
                    t()
                }
                )),
                OP(this, NP, "f").appendChild(n),
                window.addEventListener("keydown", BP(this, DP, (e=>{
                    "Escape" == e.code && (t(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                OP(this, IP, "f").removeChild(OP(this, NP, "f")),
                window.removeEventListener("keydown", OP(this, DP, "f"))
            }
            setText(e) {
                OP(this, UP, "f").textContent = e
            }
        }
        ;
        var FP, WP, HP, VP, GP, jP, XP, qP, YP, ZP, KP, JP, QP, $P, eR, tR, nR, iR, rR, aR, sR, oR, lR, cR, hR, dR, uR, pR = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, fR = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        WP = new WeakMap,
        HP = new WeakMap,
        VP = new WeakMap,
        GP = new WeakMap,
        jP = new WeakMap,
        XP = new WeakMap,
        qP = new WeakMap,
        YP = new WeakMap,
        ZP = new WeakMap,
        KP = new WeakMap,
        JP = new WeakMap,
        QP = new WeakMap,
        $P = new WeakMap,
        eR = new WeakMap,
        tR = new WeakMap,
        nR = new WeakMap,
        iR = new WeakMap,
        rR = new WeakMap,
        aR = new WeakMap,
        sR = new WeakMap,
        oR = new WeakMap,
        lR = new WeakMap,
        cR = new WeakMap,
        FP = new WeakSet,
        hR = function(e) {
            const t = fR(this, ZP, "f").slice();
            do {
                const n = Math.floor(Math.random() * t.length)
                  , i = t.splice(n, 1)[0];
                if (e > i.timeout)
                    return i
            } while (t.length > 0);
            return null
        }
        ,
        dR = function() {
            var e;
            const t = new Date;
            if (!fR(this, QP, "f") && fR(this, JP, "f").length < fR(this, sR, "f") && Math.abs(t.getTime() - fR(this, $P, "f").getTime()) >= fR(this, oR, "f")) {
                pR(this, QP, !0, "f"),
                pR(this, $P, t, "f");
                const n = fR(this, FP, "m", hR).call(this, t);
                null != n || fR(this, KP, "f").length > 0 ? fR(this, GP, "f").verifyRecordings(fR(this, XP, "f"), null !== (e = null == n ? void 0 : n.id) && void 0 !== e ? e : null, fR(this, lR, "f"), fR(this, KP, "f")).then((({unverifiedRecordings: e, exhaustive: i})=>{
                    fR(this, KP, "f").length = 0,
                    null != n && (pR(this, JP, fR(this, JP, "f").concat(e.map((({id: e, recording: t, frames: i})=>({
                        trackData: n.data,
                        recordingId: e,
                        recording: Gf.deserialize(t),
                        time: new vd(i)
                    })))), "f"),
                    i && (n.timeout = new Date(t.getTime() + Math.floor(6e4 * (30 + 30 * Math.random())))))
                }
                )).catch((e=>{
                    console.error(e),
                    fR(this, GP, "f").getUser(fR(this, XP, "f")).then((e=>{
                        null != e && e.isVerifier || pR(this, eR, !1, "f")
                    }
                    ))
                }
                )).finally((()=>{
                    pR(this, QP, !1, "f")
                }
                )) : pR(this, QP, !1, "f")
            }
        }
        ,
        uR = function() {
            fR(this, jP, "f").hasLoaded() && fR(this, eR, "f") && (fR(this, FP, "m", dR).call(this),
            fR(this, YP, "f").forEach((e=>{
                var t;
                if (!e.isBusy && fR(this, JP, "f").length > 0) {
                    e.isBusy = !0;
                    const {trackData: n, recordingId: i, recording: r, time: a} = fR(this, JP, "f").splice(0, 1)[0];
                    null == r ? (fR(this, KP, "f").push({
                        id: i,
                        verifiedState: !1
                    }),
                    e.isBusy = !1) : (pR(this, iR, (t = fR(this, iR, "f"),
                    ++t), "f"),
                    e.simulation.validate(n, r, a).then((e=>{
                        var t, n;
                        pR(this, rR, (t = fR(this, rR, "f"),
                        ++t), "f"),
                        e || pR(this, aR, (n = fR(this, aR, "f"),
                        ++n), "f"),
                        fR(this, KP, "f").push({
                            id: i,
                            verifiedState: e
                        })
                    }
                    )).catch((e=>{
                        if (!fR(this, nR, "f"))
                            throw e
                    }
                    )).finally((()=>{
                        var t;
                        e.isBusy = !1,
                        pR(this, iR, (t = fR(this, iR, "f"),
                        --t), "f")
                    }
                    )))
                }
            }
            )))
        }
        ;
        const mR = class {
            constructor(e, t, n, i, r, a, s, o, l) {
                FP.add(this),
                WP.set(this, void 0),
                HP.set(this, void 0),
                VP.set(this, void 0),
                GP.set(this, void 0),
                jP.set(this, void 0),
                XP.set(this, void 0),
                qP.set(this, void 0),
                YP.set(this, []),
                ZP.set(this, []),
                KP.set(this, []),
                JP.set(this, []),
                QP.set(this, !1),
                $P.set(this, new Date),
                eR.set(this, !0),
                tR.set(this, void 0),
                nR.set(this, !1),
                iR.set(this, 0),
                rR.set(this, 0),
                aR.set(this, 0),
                sR.set(this, 100),
                oR.set(this, 1e3),
                lR.set(this, new vd(6e5)),
                cR.set(this, 4),
                pR(this, WP, e, "f"),
                pR(this, HP, t, "f"),
                pR(this, VP, a, "f"),
                pR(this, GP, n, "f"),
                pR(this, jP, s, "f"),
                pR(this, XP, o, "f"),
                t.clear(),
                pR(this, qP, new zP(e,l), "f"),
                navigator && navigator.hardwareConcurrency > 0 && pR(this, cR, navigator.hardwareConcurrency, "f");
                for (let e = 0; e < fR(this, cR, "f"); e++)
                    fR(this, YP, "f").push({
                        simulation: new PP(r,fR(this, jP, "f")),
                        isBusy: !1
                    });
                i.forEach(((e,t,n)=>{
                    fR(this, ZP, "f").push({
                        id: e,
                        name: t,
                        data: n,
                        timeout: new Date
                    })
                }
                )),
                pR(this, tR, setInterval((()=>{
                    fR(this, FP, "m", uR).call(this)
                }
                ), 10), "f")
            }
            dispose() {
                pR(this, nR, !0, "f"),
                fR(this, qP, "f").dispose(),
                fR(this, YP, "f").forEach((e=>{
                    e.simulation.dispose()
                }
                )),
                fR(this, YP, "f").length = 0,
                clearInterval(fR(this, tR, "f"))
            }
            update(e) {
                if (fR(this, jP, "f").hasLoaded()) {
                    const e = new Date;
                    let t = "";
                    fR(this, eR, "f") ? (t += "Recordings are being verified...\n",
                    t += "\nNumber of threads: " + fR(this, cR, "f"),
                    t += "\n",
                    t += "\nBacklog: " + fR(this, JP, "f").length,
                    t += "\nProcessing: " + fR(this, iR, "f"),
                    t += "\nRecordings verified: " + fR(this, rR, "f"),
                    t += "\nInvalid recordings found: " + fR(this, aR, "f"),
                    t += "\n",
                    t += "\nTracks",
                    fR(this, ZP, "f").forEach((n=>{
                        const i = e <= n.timeout;
                        t += i ? "\n\tEmpty\t- " + n.name : "\n\tProcessing\t- " + n.name
                    }
                    ))) : t += "Error: User is no longer a verifier",
                    fR(this, qP, "f").setText(t)
                }
                fR(this, WP, "f").update(e, !1, fR(this, HP, "f"), fR(this, VP, "f"))
            }
        }
          , gR = {
            Checkpoints: " ",
            "Checkpoint order": "  ",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "  !",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "        \n\n   !",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "        \n\n   !",
            "Failed to save - Track name is needed!": "  -   !",
            "Track saved!": "  !",
            "Failed to save!": " !",
            'Are you sure you want to overwrite "{0}"?': '        "{0}"',
            Export: "",
            "Failed to export - Track name is needed!": "  -   !",
            "Track name": " ",
            "Are you sure you want to exit the editor?": "        ",
            "All unsaved data will be lost!": "     !",
            "Press [{0}] or [{1}] to restart": " [{0}]  [{1}]  ",
            "Press [{0}] to restart": " [{0}]  ",
            Leaderboard: "",
            Back: "",
            "Error: Failed to load leaderboard": ":   ",
            Verified: " ",
            Invalid: " ",
            Pending: " ",
            Loading: " ",
            "Failed to load recording": "  ",
            Ok: "",
            "Track is missing starting point": "   ",
            "Failed to create user token.": "    .",
            "Leaderboard is disabled.": "   .",
            "Please try another browser or device.": "     .",
            "Computer determinism check failed.": "   .",
            Customize: "",
            Editor: "",
            Settings: "",
            Profile: " ",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "      ",
            "Failed to create user profile": "     ",
            "This user profile does not exist on the server": "       ",
            "Failed to download user profile from the server": "       ",
            "User token is invalid": "   ",
            "Are you sure you want to display your private key?": "       ",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "      .",
            "You need a free user profile slot to import a new user profile": "           ",
            Nickname: " ",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "     .       .",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": " ",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': '      "{0}"',
            Reset: " ",
            Apply: "",
            Gameplay: " ",
            Units: "",
            Metric: "",
            Imperial: "",
            "Reset hint": "  ",
            Disabled: "",
            Enabled: "",
            "Ghost car": " ",
            "Cockpit camera mode": "   ",
            Hold: "",
            Toggle: "",
            "Checkpoints position": "  ",
            "Timer position": " ",
            "Speedometer position": "  ",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": " ",
            "Track shadow": " ",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: " ",
            "Render scale": " ",
            "Anti-aliasing (requires restart)": "  (  )",
            Audio: "",
            "Sound effect volume": "  ",
            "Music volume": " ",
            "Checkpoint volume": "  ",
            Controls: "",
            "Vehicle accelerate": " ",
            "Vehicle brake": " ",
            "Vehicle turn left": "  ",
            "Vehicle turn right": "  ",
            "Vehicle reset": "  ",
            "Vehicle cockpit camera": "  ",
            "Hide UI": "  ",
            "Editor rotate part": "   ",
            "Editor height modifier": "   ",
            "Editor delete part": "   ",
            "Editor forwards": "   ",
            "Editor backwards": "   ",
            "Editor left": "   ",
            "Editor right": "   ",
            "Editor rotate left": "   ",
            "Editor rotate right": "   ",
            "Editor move down": "  ",
            "Editor move up": "  ",
            "Editor test": " ",
            "Editor pick": " ",
            "Toggle FPS counter": "    ",
            "Toggle spectator camera": "  ",
            "Spectator forwards": "  ",
            "Spectator backwards": "  ",
            "Spectator left": "  ",
            "Spectator right": "  ",
            "Spectator speed modifier": "  ",
            "Press any key...\n\nPress [Escape] to cancel.": "   ...\n\n [] .",
            Clear: "",
            "New record": "  ",
            Record: " ",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "  ",
            'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}"  .     ',
            Overwrite: " ",
            "Paste track data here...": "   ...",
            Rank: "",
            "No record": "  ",
            "Standard tracks": " ",
            "Custom tracks": " ",
            'Are you sure you want to delete "{0}"?': '       "{0}"',
            Delete: ""
        }
          , vR = {
            Checkpoints: "Kontrollpunkte",
            "Checkpoint order": "Kontrollpunktreihenfolge",
            Height: "Hhe",
            Exit: "Beenden",
            Random: "Zufllig",
            Primary: "Primr",
            Secondary: "Sekundr",
            Frame: "Rahmen",
            Rims: "Felgen",
            Test: "Test",
            "Starting point is missing!": "Startpunkt fehlt!",
            Generate: "Generieren",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Sind Sie sicher, dass Sie eine neue Strecke generieren mchten?\n\nIhre aktuelle Strecke geht verloren!",
            Load: "Laden",
            Save: "Speichern",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Sind Sie sicher, dass Sie eine neue Strecke laden mchten?\n\nIhre aktuelle Strecke geht verloren!",
            "Failed to save - Track name is needed!": "Speichern fehlgeschlagen - Streckenname erforderlich!",
            "Track saved!": "Strecke gespeichert!",
            "Failed to save!": "Speichern fehlgeschlagen!",
            'Are you sure you want to overwrite "{0}"?': 'Sind Sie sicher, dass Sie "{0}" berschreiben mchten?',
            Export: "Exportieren",
            "Failed to export - Track name is needed!": "Export fehlgeschlagen - Streckenname erforderlich!",
            "Track name": "Streckenname",
            "Are you sure you want to exit the editor?": "Sind Sie sicher, dass Sie den Editor verlassen mchten?",
            "All unsaved data will be lost!": "Alle nicht gespeicherten Daten gehen verloren!",
            "Press [{0}] or [{1}] to restart": "Drcken Sie [{0}] oder [{1}] zum Neustarten",
            "Press [{0}] to restart": "Drcken Sie [{0}] zum Neustarten",
            Leaderboard: "Bestenliste",
            Back: "Zurck",
            "Error: Failed to load leaderboard": "Fehler: Laden der Bestenliste fehlgeschlagen",
            Verified: "Verifiziert",
            Invalid: "Ungltig",
            Pending: "Ausstehend",
            Loading: "Laden",
            "Failed to load recording": "Laden der Aufnahme fehlgeschlagen",
            Ok: "Ok",
            "Track is missing starting point": "Strecke hat keinen Startpunkt",
            "Failed to create user token.": "Fehler beim Erstellen des Benutzer-Token.",
            "Leaderboard is disabled.": "Bestenliste ist deaktiviert.",
            "Please try another browser or device.": "Bitte versuchen Sie einen anderen Browser oder ein anderes Gert.",
            "Computer determinism check failed.": "Der Computer-Determinismus-Check ist fehlgeschlagen.",
            Customize: "Anpassen",
            Editor: "Editor",
            Settings: "Einstellungen",
            Profile: "Profil",
            Play: "Spielen",
            Version: "Version",
            "You cannot have duplicate user profiles": "Sie knnen keine doppelten Benutzerprofile haben",
            "Failed to create user profile": "Benutzerprofil konnte nicht erstellt werden",
            "This user profile does not exist on the server": "Dieses Benutzerprofil existiert nicht auf dem Server",
            "Failed to download user profile from the server": "Benutzerprofil konnte nicht vom Server heruntergeladen werden",
            "User token is invalid": "Benutzertoken ist ungltig",
            "Are you sure you want to display your private key?": "Mchten Sie Ihren privaten Schlssel wirklich anzeigen?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "TEILEN SIE DIESEN SCHLSSEL NICHT MIT JEMANDEM.",
            "You need a free user profile slot to import a new user profile": "Sie bentigen einen freien Benutzerprofil-Slot, um ein neues Benutzerprofil zu importieren",
            Nickname: "Spitzname",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Whlen Sie einen Spitznamen, der in der Bestenliste angezeigt wird. Ihr Spitzname kann jederzeit gendert werden.",
            Cancel: "Abbrechen",
            Confirm: "Besttigen",
            Verifier: "Verifizierer",
            "User ID": "Benutzer-ID",
            Profiles: "Profile",
            'Are you sure you would like to delete "{0}"?': 'Mchten Sie "{0}" wirklich lschen?',
            Reset: "Zurcksetzen",
            Apply: "Anwenden",
            Gameplay: "Spielablauf",
            Units: "Einheiten",
            Metric: "Metrisch",
            Imperial: "Imperial",
            "Reset hint": "Hinweis zurcksetzen",
            Disabled: "Deaktiviert",
            Enabled: "Aktiviert",
            "Ghost car": "Geisterauto",
            "Cockpit camera mode": "Cockpit-Kameramodus",
            Hold: "Halten",
            Toggle: "Umschalten",
            "Checkpoints position": "Position der Kontrollpunkte",
            "Timer position": "Position des Timers",
            "Speedometer position": "Position des Tachometers",
            Bottom: "Unten",
            Top: "Oben",
            Language: "Sprache",
            Graphics: "Grafik",
            "Car shadow": "Auto-Schatten",
            "Track shadow": "Strecken-Schatten",
            Off: "Aus",
            On: "An",
            Low: "Niedrig",
            Medium: "Mittel",
            High: "Hoch",
            Clouds: "Wolken",
            Particles: "Partikel",
            Skidmarks: "Reifenspuren",
            "Render scale": "Render-Skalierung",
            "Anti-aliasing (requires restart)": "Antialiasing (erfordert Neustart)",
            Audio: "Audio",
            "Sound effect volume": "Lautstrke Soundeffekte",
            "Music volume": "Lautstrke Musik",
            "Checkpoint volume": "Lautstrke Kontrollpunkt",
            Controls: "Steuerung",
            "Vehicle accelerate": "Fahrzeug beschleunigen",
            "Vehicle brake": "Fahrzeug bremsen",
            "Vehicle turn left": "Fahrzeug links lenken",
            "Vehicle turn right": "Fahrzeug rechts lenken",
            "Vehicle reset": "Fahrzeug zurcksetzen",
            "Vehicle cockpit camera": "Fahrzeug-Cockpit-Kamera",
            "Hide UI": "UI ausblenden",
            "Editor rotate part": "Editor Teil drehen",
            "Editor height modifier": "Editor Hhenmodifikator",
            "Editor delete part": "Editor Teil lschen",
            "Editor forwards": "Editor vorwrts",
            "Editor backwards": "Editor rckwrts",
            "Editor left": "Editor links",
            "Editor right": "Editor rechts",
            "Editor rotate left": "Editor nach links drehen",
            "Editor rotate right": "Editor nach rechts drehen",
            "Editor move down": "Editor nach unten bewegen",
            "Editor move up": "Editor nach oben bewegen",
            "Editor test": "Editor-Test",
            "Editor pick": "Editor-Auswahl",
            "Toggle FPS counter": "FPS-Zhler umschalten",
            "Toggle spectator camera": "Zuschauer-Kamera umschalten",
            "Spectator forwards": "Zuschauer vorwrts",
            "Spectator backwards": "Zuschauer rckwrts",
            "Spectator left": "Zuschauer links",
            "Spectator right": "Zuschauer rechts",
            "Spectator speed modifier": "Zuschauer-Geschwindigkeitsmodifikator",
            "Press any key...\n\nPress [Escape] to cancel.": "Drcken Sie eine beliebige Taste...\n\nDrcken Sie [Escape], um abzubrechen.",
            Clear: "Lschen",
            "New record": "Neuer Rekord",
            Record: "Rekord",
            Current: "Aktuell",
            Difference: "Differenz",
            Copy: "Kopieren",
            Import: "Importieren",
            "Failed to import track": "Import der Strecke fehlgeschlagen",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'Die Strecke "{0}" existiert bereits. Mchten Sie sie berschreiben?',
            Overwrite: "berschreiben",
            "Paste track data here...": "Streckendaten hier einfgen...",
            Rank: "Rang",
            "No record": "Kein Rekord",
            "Standard tracks": "Standardstrecken",
            "Custom tracks": "Benutzerdefinierte Strecken",
            'Are you sure you want to delete "{0}"?': 'Sind Sie sicher, dass Sie "{0}" lschen mchten?',
            Delete: "Lschen"
        }
          , wR = {
            Checkpoints: "Checkpoints",
            "Checkpoint order": "Checkpoint order",
            Height: "Height",
            Exit: "Exit",
            Random: "Random",
            Primary: "Primary",
            Secondary: "Secondary",
            Frame: "Frame",
            Rims: "Rims",
            Test: "Test",
            "Starting point is missing!": "Starting point is missing!",
            Generate: "Generate",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Are you sure you want to generate a new track?\n\nYour current track will be lost!",
            Load: "Load",
            Save: "Save",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Are you sure you want to load a new track?\n\nYour current track will be lost!",
            "Failed to save - Track name is needed!": "Failed to save - Track name is needed!",
            "Track saved!": "Track saved!",
            "Failed to save!": "Failed to save!",
            'Are you sure you want to overwrite "{0}"?': 'Are you sure you want to overwrite "{0}"?',
            Export: "Export",
            "Failed to export - Track name is needed!": "Failed to export - Track name is needed!",
            "Track name": "Track name",
            "Are you sure you want to exit the editor?": "Are you sure you want to exit the editor?",
            "All unsaved data will be lost!": "All unsaved data will be lost!",
            "Press [{0}] or [{1}] to restart": "Press [{0}] or [{1}] to restart",
            "Press [{0}] to restart": "Press [{0}] to restart",
            Leaderboard: "Leaderboard",
            Back: "Back",
            "Error: Failed to load leaderboard": "Error: Failed to load leaderboard",
            Verified: "Verified",
            Invalid: "Invalid",
            Pending: "Pending",
            Loading: "Loading",
            "Failed to load recording": "Failed to load recording",
            Ok: "Ok",
            "Track is missing starting point": "Track is missing starting point",
            "Failed to create user token.": "Failed to create user token.",
            "Leaderboard is disabled.": "Leaderboard is disabled.",
            "Please try another browser or device.": "Please try another browser or device.",
            "Computer determinism check failed.": "Computer determinism check failed.",
            Customize: "Customize",
            Editor: "Editor",
            Settings: "Settings",
            Profile: "Profile",
            Play: "Play",
            Version: "Version",
            "You cannot have duplicate user profiles": "You cannot have duplicate user profiles",
            "Failed to create user profile": "Failed to create user profile",
            "This user profile does not exist on the server": "This user profile does not exist on the server",
            "Failed to download user profile from the server": "Failed to download user profile from the server",
            "User token is invalid": "User token is invalid",
            "Are you sure you want to display your private key?": "Are you sure you want to display your private key?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "DO NOT SHARE THIS KEY WITH ANYONE.",
            "You need a free user profile slot to import a new user profile": "You need a free user profile slot to import a new user profile",
            Nickname: "Nickname",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.",
            Cancel: "Cancel",
            Confirm: "Confirm",
            Verifier: "Verifier",
            "User ID": "User ID",
            Profiles: "Profiles",
            'Are you sure you would like to delete "{0}"?': 'Are you sure you would like to delete "{0}"?',
            Reset: "Reset",
            Apply: "Apply",
            Gameplay: "Gameplay",
            Units: "Units",
            Metric: "Metric",
            Imperial: "Imperial",
            "Reset hint": "Reset hint",
            Disabled: "Disabled",
            Enabled: "Enabled",
            "Ghost car": "Ghost car",
            "Cockpit camera mode": "Cockpit camera mode",
            Hold: "Hold",
            Toggle: "Toggle",
            "Checkpoints position": "Checkpoints position",
            "Timer position": "Timer position",
            "Speedometer position": "Speedometer position",
            Bottom: "Bottom",
            Top: "Top",
            Language: "Language",
            Graphics: "Graphics",
            "Car shadow": "Car shadow",
            "Track shadow": "Track shadow",
            Off: "Off",
            On: "On",
            Low: "Low",
            Medium: "Medium",
            High: "High",
            Clouds: "Clouds",
            Particles: "Particles",
            Skidmarks: "Skidmarks",
            "Render scale": "Render scale",
            "Anti-aliasing (requires restart)": "Anti-aliasing (requires restart)",
            Audio: "Audio",
            "Sound effect volume": "Sound effect volume",
            "Music volume": "Music volume",
            "Checkpoint volume": "Checkpoint volume",
            Controls: "Controls",
            "Vehicle accelerate": "Vehicle accelerate",
            "Vehicle brake": "Vehicle brake",
            "Vehicle turn left": "Vehicle turn left",
            "Vehicle turn right": "Vehicle turn right",
            "Vehicle reset": "Vehicle reset",
            "Vehicle cockpit camera": "Vehicle cockpit camera",
            "Hide UI": "Hide UI",
            "Editor rotate part": "Editor rotate part",
            "Editor height modifier": "Editor height modifier",
            "Editor delete part": "Editor delete part",
            "Editor forwards": "Editor forwards",
            "Editor backwards": "Editor backwards",
            "Editor left": "Editor left",
            "Editor right": "Editor right",
            "Editor rotate left": "Editor rotate left",
            "Editor rotate right": "Editor rotate right",
            "Editor move down": "Editor move down",
            "Editor move up": "Editor move up",
            "Editor test": "Editor test",
            "Editor pick": "Editor pick",
            "Toggle FPS counter": "Toggle FPS counter",
            "Toggle spectator camera": "Toggle spectator camera",
            "Spectator forwards": "Spectator forwards",
            "Spectator backwards": "Spectator backwards",
            "Spectator left": "Spectator left",
            "Spectator right": "Spectator right",
            "Spectator speed modifier": "Spectator speed modifier",
            "Press any key...\n\nPress [Escape] to cancel.": "Press any key...\n\nPress [Escape] to cancel.",
            Clear: "Clear",
            "New record": "New record",
            Record: "Record",
            Current: "Current",
            Difference: "Difference",
            Copy: "Copy",
            Import: "Import",
            "Failed to import track": "Failed to import track",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'The track "{0}" already exists. Do you wish to overwrite it?',
            Overwrite: "Overwrite",
            "Paste track data here...": "Paste track data here...",
            Rank: "Rank",
            "No record": "No record",
            "Standard tracks": "Standard tracks",
            "Custom tracks": "Custom tracks",
            'Are you sure you want to delete "{0}"?': 'Are you sure you want to delete "{0}"?',
            Delete: "Delete"
        }
          , yR = {
            Checkpoints: "Puntos de control",
            "Checkpoint order": "Orden de puntos de control",
            Height: "Altura",
            Exit: "Salir",
            Random: "Aleatorio",
            Primary: "Primario",
            Secondary: "Secundario",
            Frame: "Marco",
            Rims: "Llantas",
            Test: "Prueba",
            "Starting point is missing!": "Falta el punto de inicio!",
            Generate: "Generar",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Ests seguro de que deseas generar una nueva pista?\n\nTu pista actual se perder!",
            Load: "Cargar",
            Save: "Guardar",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Ests seguro de que deseas cargar una nueva pista?\n\nTu pista actual se perder!",
            "Failed to save - Track name is needed!": "Error al guardar: Se necesita un nombre para la pista!",
            "Track saved!": "Pista guardada!",
            "Failed to save!": "Error al guardar!",
            'Are you sure you want to overwrite "{0}"?': 'Ests seguro de que deseas sobrescribir "{0}"?',
            Export: "Exportar",
            "Failed to export - Track name is needed!": "Error al exportar: Se necesita un nombre para la pista!",
            "Track name": "Nombre de la pista",
            "Are you sure you want to exit the editor?": "Ests seguro de que deseas salir del editor?",
            "All unsaved data will be lost!": "Se perdern todos los datos no guardados!",
            "Press [{0}] or [{1}] to restart": "Presiona [{0}] o [{1}] para reiniciar",
            "Press [{0}] to restart": "Presiona [{0}] para reiniciar",
            Leaderboard: "Tabla de clasificacin",
            Back: "Volver",
            "Error: Failed to load leaderboard": "Error: No se pudo cargar la tabla de clasificacin",
            Verified: "Verificado",
            Invalid: "Invlido",
            Pending: "Pendiente",
            Loading: "Cargando",
            "Failed to load recording": "Error al cargar la grabacin",
            Ok: "Aceptar",
            "Track is missing starting point": "Falta el punto de inicio en la pista",
            "Failed to create user token.": "No se pudo crear el token de usuario.",
            "Leaderboard is disabled.": "El marcador est desactivado.",
            "Please try another browser or device.": "Por favor, prueba otro navegador o dispositivo.",
            "Computer determinism check failed.": "Fall la comprobacin de determinismo del ordenador.",
            Customize: "Personalizar",
            Editor: "Editor",
            Settings: "Configuracin",
            Profile: "Perfil",
            Play: "Jugar",
            Version: "Versin",
            "You cannot have duplicate user profiles": "No puedes tener perfiles de usuario duplicados",
            "Failed to create user profile": "No se pudo crear el perfil de usuario",
            "This user profile does not exist on the server": "Este perfil de usuario no existe en el servidor",
            "Failed to download user profile from the server": "No se pudo descargar el perfil de usuario desde el servidor",
            "User token is invalid": "El token de usuario no es vlido",
            "Are you sure you want to display your private key?": "Ests seguro de que quieres mostrar tu clave privada?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "NO COMPARTAS ESTA CLAVE CON NADIE.",
            "You need a free user profile slot to import a new user profile": "Necesitas un espacio libre de perfil de usuario para importar un nuevo perfil de usuario",
            Nickname: "Apodo",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Elige un apodo para que aparezca en la tabla de clasificacin. Puedes cambiar tu apodo en cualquier momento.",
            Cancel: "Cancelar",
            Confirm: "Confirmar",
            Verifier: "Verificador",
            "User ID": "ID de usuario",
            Profiles: "Perfiles",
            'Are you sure you would like to delete "{0}"?': 'Ests seguro de que quieres eliminar "{0}"?',
            Reset: "Restablecer",
            Apply: "Aplicar",
            Gameplay: "Jugabilidad",
            Units: "Unidades",
            Metric: "Mtrico",
            Imperial: "Imperial",
            "Reset hint": "Restablecer pista",
            Disabled: "Desactivado",
            Enabled: "Activado",
            "Ghost car": "Coche fantasma",
            "Cockpit camera mode": "Modo de cmara en la cabina",
            Hold: "Mantener",
            Toggle: "Alternar",
            "Checkpoints position": "Posicin de los puntos de control",
            "Timer position": "Posicin del temporizador",
            "Speedometer position": "Posicin del velocmetro",
            Bottom: "Inferior",
            Top: "Superior",
            Language: "Idioma",
            Graphics: "Grficos",
            "Car shadow": "Sombra del coche",
            "Track shadow": "Sombra de la pista",
            Off: "Apagar",
            On: "Encender",
            Low: "Bajo",
            Medium: "Medio",
            High: "Alto",
            Clouds: "Nubes",
            Particles: "Partculas",
            Skidmarks: "Marcas de derrape",
            "Render scale": "Escala de renderizado",
            "Anti-aliasing (requires restart)": "Anti-aliasing (requiere reinicio)",
            Audio: "Audio",
            "Sound effect volume": "Volumen de efectos de sonido",
            "Music volume": "Volumen de msica",
            "Checkpoint volume": "Volumen de puntos de control",
            Controls: "Controles",
            "Vehicle accelerate": "Acelerar vehculo",
            "Vehicle brake": "Frenar vehculo",
            "Vehicle turn left": "Girar vehculo a la izquierda",
            "Vehicle turn right": "Girar vehculo a la derecha",
            "Vehicle reset": "Reiniciar vehculo",
            "Vehicle cockpit camera": "Cmara en el interior del vehculo",
            "Hide UI": "Ocultar interfaz de usuario",
            "Editor rotate part": "Rotar pieza del editor",
            "Editor height modifier": "Modificador de altura del editor",
            "Editor delete part": "Eliminar pieza del editor",
            "Editor forwards": "Avanzar en el editor",
            "Editor backwards": "Retroceder en el editor",
            "Editor left": "Moverse a la izquierda en el editor",
            "Editor right": "Moverse a la derecha en el editor",
            "Editor rotate left": "Girar editor a la izquierda",
            "Editor rotate right": "Girar editor a la derecha",
            "Editor move down": "Mover editor hacia abajo",
            "Editor move up": "Mover editor hacia arriba",
            "Editor test": "Prueba de editor",
            "Editor pick": "Seleccin del editor",
            "Toggle FPS counter": "Alternar contador de FPS",
            "Toggle spectator camera": "Alternar cmara de espectador",
            "Spectator forwards": "Avanzar como espectador",
            "Spectator backwards": "Retroceder como espectador",
            "Spectator left": "Moverse a la izquierda como espectador",
            "Spectator right": "Moverse a la derecha como espectador",
            "Spectator speed modifier": "Modificador de velocidad de espectador",
            "Press any key...\n\nPress [Escape] to cancel.": "Presiona cualquier tecla...\n\nPresiona [Escape] para cancelar.",
            Clear: "Borrar",
            "New record": "Nuevo rcord",
            Record: "Rcord",
            Current: "Actual",
            Difference: "Diferencia",
            Copy: "Copiar",
            Import: "Importar",
            "Failed to import track": "Error al importar la pista",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'La pista "{0}" ya existe. Deseas sobrescribirla?',
            Overwrite: "Sobrescribir",
            "Paste track data here...": "Pegar datos de la pista aqu...",
            Rank: "Rango",
            "No record": "Sin rcord",
            "Standard tracks": "Pistas estndar",
            "Custom tracks": "Pistas personalizadas",
            'Are you sure you want to delete "{0}"?': 'Ests seguro de que deseas eliminar "{0}"?',
            Delete: "Eliminar"
        }
          , _R = {
            Checkpoints: "Points de contrle",
            "Checkpoint order": "Ordre des points de contrle",
            Height: "Hauteur",
            Exit: "Quitter",
            Random: "Alatoire",
            Primary: "Principal",
            Secondary: "Secondaire",
            Frame: "Cadre",
            Rims: "Jantes",
            Test: "Test",
            "Starting point is missing!": "Point de dpart manquant !",
            Generate: "Gnrer",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "tes-vous sr de vouloir gnrer une nouvelle piste ?\n\nVotre piste actuelle sera perdue !",
            Load: "Charger",
            Save: "Enregistrer",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "tes-vous sr de vouloir charger une nouvelle piste ?\n\nVotre piste actuelle sera perdue !",
            "Failed to save - Track name is needed!": "chec de l'enregistrement - Le nom de la piste est ncessaire !",
            "Track saved!": "Piste enregistre !",
            "Failed to save!": "chec de l'enregistrement !",
            'Are you sure you want to overwrite "{0}"?': 'tes-vous sr de vouloir craser "{0}" ?',
            Export: "Exporter",
            "Failed to export - Track name is needed!": "chec de l'exportation - Le nom de la piste est ncessaire !",
            "Track name": "Nom de la piste",
            "Are you sure you want to exit the editor?": "tes-vous sr de vouloir quitter l'diteur ?",
            "All unsaved data will be lost!": "Toutes les donnes non sauvegardes seront perdues !",
            "Press [{0}] or [{1}] to restart": "Appuyez sur [{0}] ou [{1}] pour redmarrer",
            "Press [{0}] to restart": "Appuyez sur [{0}] pour redmarrer",
            Leaderboard: "Classement",
            Back: "Retour",
            "Error: Failed to load leaderboard": "Erreur : chec du chargement du classement",
            Verified: "Vrifi",
            Invalid: "Invalide",
            Pending: "En attente",
            Loading: "Chargement",
            "Failed to load recording": "chec du chargement de l'enregistrement",
            Ok: "OK",
            "Track is missing starting point": "La piste n'a pas de point de dpart",
            "Failed to create user token.": "chec de la cration du jeton d'utilisateur.",
            "Leaderboard is disabled.": "Le classement est dsactiv.",
            "Please try another browser or device.": "Veuillez essayer un autre navigateur ou appareil.",
            "Computer determinism check failed.": "chec de la vrification du dterminisme de l'ordinateur.",
            Customize: "Personnaliser",
            Editor: "diteur",
            Settings: "Paramtres",
            Profile: "Profil",
            Play: "Jouer",
            Version: "Version",
            "You cannot have duplicate user profiles": "Vous ne pouvez pas avoir de profils d'utilisateur en double",
            "Failed to create user profile": "chec de la cration du profil utilisateur",
            "This user profile does not exist on the server": "Ce profil utilisateur n'existe pas sur le serveur",
            "Failed to download user profile from the server": "chec du tlchargement du profil utilisateur depuis le serveur",
            "User token is invalid": "Le jeton utilisateur n'est pas valide",
            "Are you sure you want to display your private key?": "tes-vous sr de vouloir afficher votre cl prive ?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "NE PARTAGEZ PAS CETTE CL AVEC PERSONNE.",
            "You need a free user profile slot to import a new user profile": "Vous avez besoin d'un emplacement de profil utilisateur libre pour importer un nouveau profil utilisateur",
            Nickname: "Pseudonyme",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Choisissez un pseudonyme  afficher dans le classement. Vous pouvez changer votre pseudonyme  tout moment.",
            Cancel: "Annuler",
            Confirm: "Confirmer",
            Verifier: "Vrificateur",
            "User ID": "ID utilisateur",
            Profiles: "Profils",
            'Are you sure you would like to delete "{0}"?': 'tes-vous sr de vouloir supprimer "{0}"?',
            Reset: "Rinitialiser",
            Apply: "Appliquer",
            Gameplay: "Jouabilit",
            Units: "Units",
            Metric: "Mtrique",
            Imperial: "Imprial",
            "Reset hint": "Rinitialiser l'astuce",
            Disabled: "Dsactiv",
            Enabled: "Activ",
            "Ghost car": "Voiture fantme",
            "Cockpit camera mode": "Mode camra cockpit",
            Hold: "Maintenir",
            Toggle: "Basculer",
            "Checkpoints position": "Position des checkpoints",
            "Timer position": "Position du minuteur",
            "Speedometer position": "Position du compteur de vitesse",
            Bottom: "Bas",
            Top: "Haut",
            Language: "Langue",
            Graphics: "Graphismes",
            "Car shadow": "Ombre de la voiture",
            "Track shadow": "Ombre de la piste",
            Off: "Dsactiv",
            On: "Activ",
            Low: "Faible",
            Medium: "Moyen",
            High: "lev",
            Clouds: "Nuages",
            Particles: "Particules",
            Skidmarks: "Marques de drapage",
            "Render scale": "chelle de rendu",
            "Anti-aliasing (requires restart)": "Anticrnelage (ncessite un redmarrage)",
            Audio: "Audio",
            "Sound effect volume": "Volume des effets sonores",
            "Music volume": "Volume de la musique",
            "Checkpoint volume": "Volume des points de contrle",
            Controls: "Commandes",
            "Vehicle accelerate": "Acclrer le vhicule",
            "Vehicle brake": "Freiner le vhicule",
            "Vehicle turn left": "Tourner  gauche",
            "Vehicle turn right": "Tourner  droite",
            "Vehicle reset": "Rinitialiser le vhicule",
            "Vehicle cockpit camera": "Camra du cockpit du vhicule",
            "Hide UI": "Masquer l'interface utilisateur",
            "Editor rotate part": "Tourner la pice de l'diteur",
            "Editor height modifier": "Modificateur de hauteur de l'diteur",
            "Editor delete part": "Supprimer la pice de l'diteur",
            "Editor forwards": "Avancer dans l'diteur",
            "Editor backwards": "Reculer dans l'diteur",
            "Editor left": "Aller  gauche dans l'diteur",
            "Editor right": "Aller  droite dans l'diteur",
            "Editor rotate left": "Tourner l'diteur  gauche",
            "Editor rotate right": "Tourner l'diteur  droite",
            "Editor move down": "Dplacer l'diteur vers le bas",
            "Editor move up": "Dplacer l'diteur vers le haut",
            "Editor test": "Test de l'diteur",
            "Editor pick": "Slection de l'diteur",
            "Toggle FPS counter": "Activer/dsactiver le compteur FPS",
            "Toggle spectator camera": "Activer/dsactiver la camra du spectateur",
            "Spectator forwards": "Spectateur - Avancer",
            "Spectator backwards": "Spectateur - Reculer",
            "Spectator left": "Spectateur - Aller  gauche",
            "Spectator right": "Spectateur - Aller  droite",
            "Spectator speed modifier": "Modificateur de vitesse du spectateur",
            "Press any key...\n\nPress [Escape] to cancel.": "Appuyez sur n'importe quelle touche...\n\nAppuyez sur [chap] pour annuler.",
            Clear: "Effacer",
            "New record": "Nouveau record",
            Record: "Record",
            Current: "Actuel",
            Difference: "Diffrence",
            Copy: "Copier",
            Import: "Importer",
            "Failed to import track": "chec de l'importation de la piste",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'La piste "{0}" existe dj. Souhaitez-vous l\'craser ?',
            Overwrite: "craser",
            "Paste track data here...": "Collez les donnes de la piste ici...",
            Rank: "Classement",
            "No record": "Pas de record",
            "Standard tracks": "Pistes standard",
            "Custom tracks": "Pistes personnalises",
            'Are you sure you want to delete "{0}"?': 'tes-vous sr de vouloir supprimer "{0}" ?',
            Delete: "Supprimer"
        }
          , xR = {
            Checkpoints: "Checkpoint",
            "Checkpoint order": "Ordine dei checkpoint",
            Height: "Altezza",
            Exit: "Esci",
            Random: "Casuale",
            Primary: "Primario",
            Secondary: "Secondario",
            Frame: "Telaio",
            Rims: "Cerchioni",
            Test: "Test",
            "Starting point is missing!": "Punto di partenza mancante!",
            Generate: "Genera",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Sei sicuro di voler generare un nuovo percorso?\n\nIl tuo percorso attuale verr perso!",
            Load: "Carica",
            Save: "Salva",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Sei sicuro di voler caricare un nuovo percorso?\n\nIl tuo percorso attuale verr perso!",
            "Failed to save - Track name is needed!": "Salvataggio non riuscito -  necessario un nome per il percorso!",
            "Track saved!": "Percorso salvato!",
            "Failed to save!": "Salvataggio non riuscito!",
            'Are you sure you want to overwrite "{0}"?': 'Sei sicuro di voler sovrascrivere "{0}"?',
            Export: "Esporta",
            "Failed to export - Track name is needed!": "Esportazione non riuscita -  necessario un nome per il percorso!",
            "Track name": "Nome del percorso",
            "Are you sure you want to exit the editor?": "Sei sicuro di voler uscire dall'editor?",
            "All unsaved data will be lost!": "Tutti i dati non salvati andranno persi!",
            "Press [{0}] or [{1}] to restart": "Premi [{0}] o [{1}] per riavviare",
            "Press [{0}] to restart": "Premi [{0}] per riavviare",
            Leaderboard: "Classifica",
            Back: "Indietro",
            "Error: Failed to load leaderboard": "Errore: impossibile caricare la classifica",
            Verified: "Verificato",
            Invalid: "Non valido",
            Pending: "In sospeso",
            Loading: "Caricamento",
            "Failed to load recording": "Caricamento registrazione non riuscito",
            Ok: "Ok",
            "Track is missing starting point": "Il percorso non ha un punto di partenza",
            "Failed to create user token.": "Impossibile creare il token dell'utente.",
            "Leaderboard is disabled.": "La classifica  disabilitata.",
            "Please try another browser or device.": "Si prega di provare un altro browser o dispositivo.",
            "Computer determinism check failed.": "Verifica del determinismo del computer fallita.",
            Customize: "Personalizza",
            Editor: "Editor",
            Settings: "Impostazioni",
            Profile: "Profilo",
            Play: "Gioca",
            Version: "Versione",
            "You cannot have duplicate user profiles": "Non  possibile avere profili utente duplicati",
            "Failed to create user profile": "Impossibile creare il profilo utente",
            "This user profile does not exist on the server": "Questo profilo utente non esiste sul server",
            "Failed to download user profile from the server": "Impossibile scaricare il profilo utente dal server",
            "User token is invalid": "Token utente non valido",
            "Are you sure you want to display your private key?": "Sei sicuro di voler mostrare la tua chiave privata?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "NON CONDIVIDERE QUESTA CHIAVE CON NESSUNO.",
            "You need a free user profile slot to import a new user profile": "Hai bisogno di uno slot di profilo utente libero per importare un nuovo profilo utente",
            Nickname: "Nickname",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Scegli un nickname da mostrare nella classifica. Puoi cambiarlo in qualsiasi momento.",
            Cancel: "Annulla",
            Confirm: "Conferma",
            Verifier: "Verificatore",
            "User ID": "ID Utente",
            Profiles: "Profili",
            'Are you sure you would like to delete "{0}"?': 'Sei sicuro di voler eliminare "{0}"?',
            Reset: "Resetta",
            Apply: "Applica",
            Gameplay: "Modalit di gioco",
            Units: "Unit",
            Metric: "Metrico",
            Imperial: "Imperiale",
            "Reset hint": "Resetta suggerimento",
            Disabled: "Disattivato",
            Enabled: "Attivato",
            "Ghost car": "Auto fantasma",
            "Cockpit camera mode": "Modalit telecamera cabina",
            Hold: "Tieni",
            Toggle: "Attiva/Disattiva",
            "Checkpoints position": "Posizione dei checkpoint",
            "Timer position": "Posizione del timer",
            "Speedometer position": "Posizione del contagiri",
            Bottom: "In basso",
            Top: "In alto",
            Language: "Lingua",
            Graphics: "Grafica",
            "Car shadow": "Ombra dell'auto",
            "Track shadow": "Ombra del percorso",
            Off: "Disattivato",
            On: "Attivato",
            Low: "Basso",
            Medium: "Medio",
            High: "Alto",
            Clouds: "Nuvole",
            Particles: "Particelle",
            Skidmarks: "Segni di frenata",
            "Render scale": "Scala di rendering",
            "Anti-aliasing (requires restart)": "Anti-aliasing (richiede riavvio)",
            Audio: "Audio",
            "Sound effect volume": "Volume degli effetti sonori",
            "Music volume": "Volume della musica",
            "Checkpoint volume": "Volume dei checkpoint",
            Controls: "Controlli",
            "Vehicle accelerate": "Accelerare veicolo",
            "Vehicle brake": "Frenare veicolo",
            "Vehicle turn left": "Sterzare a sinistra",
            "Vehicle turn right": "Sterzare a destra",
            "Vehicle reset": "Riporta veicolo",
            "Vehicle cockpit camera": "Visuale cabina veicolo",
            "Hide UI": "Nascondi UI",
            "Editor rotate part": "Ruota parte nell'editor",
            "Editor height modifier": "Modifica altezza nell'editor",
            "Editor delete part": "Elimina parte nell'editor",
            "Editor forwards": "Avanti nell'editor",
            "Editor backwards": "Indietro nell'editor",
            "Editor left": "Sinistra nell'editor",
            "Editor right": "Destra nell'editor",
            "Editor rotate left": "Ruota editor a sinistra",
            "Editor rotate right": "Ruota editor a destra",
            "Editor move down": "Muovi editor verso il basso",
            "Editor move up": "Muovi editor verso l'alto",
            "Editor test": "Test dell'editor",
            "Editor pick": "Scelta dell'editor",
            "Toggle FPS counter": "Mostra contatore FPS",
            "Toggle spectator camera": "Attiva/disattiva telecamera spettatore",
            "Spectator forwards": "Avanti spettatore",
            "Spectator backwards": "Indietro spettatore",
            "Spectator left": "Sinistra spettatore",
            "Spectator right": "Destra spettatore",
            "Spectator speed modifier": "Modificatore velocit spettatore",
            "Press any key...\n\nPress [Escape] to cancel.": "Premi un tasto qualsiasi...\n\nPremi [Esc] per annullare.",
            Clear: "Cancella",
            "New record": "Nuovo record",
            Record: "Record",
            Current: "Attuale",
            Difference: "Differenza",
            Copy: "Copia",
            Import: "Importa",
            "Failed to import track": "Importazione percorso non riuscita",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'Il percorso "{0}" esiste gi. Vuoi sovrascriverlo?',
            Overwrite: "Sovrascrivi",
            "Paste track data here...": "Incolla dati del percorso qui...",
            Rank: "Posizione",
            "No record": "Nessun record",
            "Standard tracks": "Percorsi standard",
            "Custom tracks": "Percorsi personalizzati",
            'Are you sure you want to delete "{0}"?': 'Sei sicuro di voler eliminare "{0}"?',
            Delete: "Elimina"
        }
          , bR = {
            Checkpoints: "",
            "Checkpoint order": "",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "\n\n",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "\n\n",
            "Failed to save - Track name is needed!": " - ",
            "Track saved!": "",
            "Failed to save!": "",
            'Are you sure you want to overwrite "{0}"?': '"{0}" ',
            Export: "",
            "Failed to export - Track name is needed!": " - ",
            "Track name": "",
            "Are you sure you want to exit the editor?": "",
            "All unsaved data will be lost!": "",
            "Press [{0}] or [{1}] to restart": "[{0}]  [{1}] ",
            "Press [{0}] to restart": "[{0}] ",
            Leaderboard: "",
            Back: "",
            "Error: Failed to load leaderboard": "",
            Verified: "",
            Invalid: "",
            Pending: "",
            Loading: "",
            "Failed to load recording": "",
            Ok: "OK",
            "Track is missing starting point": "",
            "Failed to create user token.": "",
            "Leaderboard is disabled.": "",
            "Please try another browser or device.": "",
            "Computer determinism check failed.": "",
            Customize: "",
            Editor: "",
            Settings: "",
            Profile: "",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "",
            "Failed to create user profile": "",
            "This user profile does not exist on the server": "",
            "Failed to download user profile from the server": "",
            "User token is invalid": "",
            "Are you sure you want to display your private key?": "",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "",
            "You need a free user profile slot to import a new user profile": "",
            Nickname: "",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": "ID",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': '"{0}"',
            Reset: "",
            Apply: "",
            Gameplay: "",
            Units: "",
            Metric: "",
            Imperial: "",
            "Reset hint": "",
            Disabled: "",
            Enabled: "",
            "Ghost car": "",
            "Cockpit camera mode": "",
            Hold: "",
            Toggle: "",
            "Checkpoints position": "",
            "Timer position": "",
            "Speedometer position": "",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": "",
            "Track shadow": "",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: "",
            "Render scale": "",
            "Anti-aliasing (requires restart)": "",
            Audio: "",
            "Sound effect volume": "",
            "Music volume": "",
            "Checkpoint volume": "",
            Controls: "",
            "Vehicle accelerate": "",
            "Vehicle brake": "",
            "Vehicle turn left": "",
            "Vehicle turn right": "",
            "Vehicle reset": "",
            "Vehicle cockpit camera": "",
            "Hide UI": "UI",
            "Editor rotate part": "",
            "Editor height modifier": "",
            "Editor delete part": "",
            "Editor forwards": "",
            "Editor backwards": "",
            "Editor left": "",
            "Editor right": "",
            "Editor rotate left": "",
            "Editor rotate right": "",
            "Editor move down": "",
            "Editor move up": "",
            "Editor test": "",
            "Editor pick": "",
            "Toggle FPS counter": "FPS",
            "Toggle spectator camera": "",
            "Spectator forwards": "",
            "Spectator backwards": "",
            "Spectator left": "",
            "Spectator right": "",
            "Spectator speed modifier": "",
            "Press any key...\n\nPress [Escape] to cancel.": "...\n\n[Escape] ",
            Clear: "",
            "New record": "",
            Record: "",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "",
            'The track "{0}" already exists. Do you wish to overwrite it?': "{0}",
            Overwrite: "",
            "Paste track data here...": "...",
            Rank: "",
            "No record": "",
            "Standard tracks": "",
            "Custom tracks": "",
            'Are you sure you want to delete "{0}"?': '"{0}" ',
            Delete: ""
        }
          , ER = {
            Checkpoints: "",
            "Checkpoint order": " ",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "  !",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "  ?\n\n  !",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "  ?\n\n  !",
            "Failed to save - Track name is needed!": "  -   !",
            "Track saved!": " !",
            "Failed to save!": " !",
            'Are you sure you want to overwrite "{0}"?': '"{0}"() ?',
            Export: "",
            "Failed to export - Track name is needed!": "  -   !",
            "Track name": " ",
            "Are you sure you want to exit the editor?": " ?",
            "All unsaved data will be lost!": "    !",
            "Press [{0}] or [{1}] to restart": "[{0}]  [{1}]()   ",
            "Press [{0}] to restart": "[{0}]()   ",
            Leaderboard: "",
            Back: "",
            "Error: Failed to load leaderboard": ":   ",
            Verified: "",
            Invalid: " ",
            Pending: " ",
            Loading: " ",
            "Failed to load recording": "  ",
            Ok: "",
            "Track is missing starting point": "   ",
            "Failed to create user token.": "   .",
            "Leaderboard is disabled.": " .",
            "Please try another browser or device.": "   .",
            "Computer determinism check failed.": "   .",
            Customize: " ",
            Editor: "",
            Settings: "",
            Profile: "",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "     ",
            "Failed to create user profile": "   ",
            "This user profile does not exist on the server": "     ",
            "Failed to download user profile from the server": "    ",
            "User token is invalid": "   ",
            "Are you sure you want to display your private key?": "  ?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "    .",
            "You need a free user profile slot to import a new user profile": "        ",
            Nickname: "",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "   .     .",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": " ID",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': '"{0}" ?',
            Reset: "",
            Apply: "",
            Gameplay: " ",
            Units: "",
            Metric: "",
            Imperial: "/ ",
            "Reset hint": " ",
            Disabled: "",
            Enabled: "",
            "Ghost car": " ",
            "Cockpit camera mode": "  ",
            Hold: "",
            Toggle: "",
            "Checkpoints position": " ",
            "Timer position": " ",
            "Speedometer position": " ",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": " ",
            "Track shadow": " ",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: " ",
            "Render scale": " ",
            "Anti-aliasing (requires restart)": "  ( )",
            Audio: "",
            "Sound effect volume": "  ",
            "Music volume": " ",
            "Checkpoint volume": " ",
            Controls: "",
            "Vehicle accelerate": " ",
            "Vehicle brake": " ",
            "Vehicle turn left": "  ",
            "Vehicle turn right": "  ",
            "Vehicle reset": " ",
            "Vehicle cockpit camera": "  ",
            "Hide UI": "UI ",
            "Editor rotate part": "  ",
            "Editor height modifier": "  ",
            "Editor delete part": "  ",
            "Editor forwards": " ",
            "Editor backwards": " ",
            "Editor left": " ",
            "Editor right": " ",
            "Editor rotate left": "  ",
            "Editor rotate right": "  ",
            "Editor move down": "  ",
            "Editor move up": "  ",
            "Editor test": " ",
            "Editor pick": " ",
            "Toggle FPS counter": "FPS  ",
            "Toggle spectator camera": "  ",
            "Spectator forwards": " ",
            "Spectator backwards": " ",
            "Spectator left": " ",
            "Spectator right": " ",
            "Spectator speed modifier": "  ",
            "Press any key...\n\nPress [Escape] to cancel.": "  ...\n\n[Escape]  .",
            Clear: "",
            "New record": " ",
            Record: "",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "  ",
            'The track "{0}" already exists. Do you wish to overwrite it?': '"{0}"   . ?',
            Overwrite: "",
            "Paste track data here...": "   ...",
            Rank: "",
            "No record": " ",
            "Standard tracks": " ",
            "Custom tracks": "  ",
            'Are you sure you want to delete "{0}"?': '"{0}"() ?',
            Delete: ""
        }
          , SR = {
            Checkpoints: "Punkty kontrolne",
            "Checkpoint order": "Kolejno punktw kontrolnych",
            Height: "Wysoko",
            Exit: "Wyjcie",
            Random: "Losowe",
            Primary: "Gwny",
            Secondary: "Dodatkowy",
            Frame: "Rama",
            Rims: "Obrcze",
            Test: "Test",
            "Starting point is missing!": "Brak punktu startowego!",
            Generate: "Generuj",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Czy na pewno chcesz wygenerowa now tras?\n\nTwoja obecna trasa zostanie utracona!",
            Load: "Wczytaj",
            Save: "Zapisz",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Czy na pewno chcesz wczyta now tras?\n\nTwoja obecna trasa zostanie utracona!",
            "Failed to save - Track name is needed!": "Nie udao si zapisa - Wymagana nazwa trasy!",
            "Track saved!": "Trasa zostaa zapisana!",
            "Failed to save!": "Nie udao si zapisa!",
            'Are you sure you want to overwrite "{0}"?': "Czy na pewno chcesz nadpisa {0}?",
            Export: "Eksportuj",
            "Failed to export - Track name is needed!": "Nie udao si wyeksportowa - Wymagana nazwa trasy!",
            "Track name": "Nazwa trasy",
            "Are you sure you want to exit the editor?": "Czy na pewno chcesz wyj z edytora?",
            "All unsaved data will be lost!": "Wszystkie niezapisane dane zostan utracone!",
            "Press [{0}] or [{1}] to restart": "Nacinij [{0}] lub [{1}] aby zrestartowa",
            "Press [{0}] to restart": "Nacinij [{0}] aby zrestartowa",
            Leaderboard: "Tabela wynikw",
            Back: "Powrt",
            "Error: Failed to load leaderboard": "Bd: Nie mona wczyta tabeli wynikw",
            Verified: "Zweryfikowany",
            Invalid: "Nieprawidowy",
            Pending: "Oczekujcy",
            Loading: "adowanie",
            "Failed to load recording": "Nie udao si wczyta nagrania",
            Ok: "Ok",
            "Track is missing starting point": "Brak punktu startowego na trasie",
            "Failed to create user token.": "Nie udao si utworzy tokenu uytkownika.",
            "Leaderboard is disabled.": "Tablica wynikw jest wyczona.",
            "Please try another browser or device.": "Prosz sprbowa inn przegldark lub urzdzenie.",
            "Computer determinism check failed.": "Nie udao si sprawdzi determinizmu komputera.",
            Customize: "Dostosuj",
            Editor: "Edytor",
            Settings: "Ustawienia",
            Profile: "Profil",
            Play: "Graj",
            Version: "Wersja",
            "You cannot have duplicate user profiles": "Nie moesz mie zduplikowanych profili uytkownika",
            "Failed to create user profile": "Nie udao si utworzy profilu uytkownika",
            "This user profile does not exist on the server": "Ten profil uytkownika nie istnieje na serwerze",
            "Failed to download user profile from the server": "Nie udao si pobra profilu uytkownika z serwera",
            "User token is invalid": "Token uytkownika jest nieprawidowy",
            "Are you sure you want to display your private key?": "Czy na pewno chcesz wywietli swj klucz prywatny?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "NIE UDOSTPNIAJ TEGO KLUCZA NIKOMU.",
            "You need a free user profile slot to import a new user profile": "Potrzebujesz wolnego miejsca na profil uytkownika, aby zaimportowa nowy profil uytkownika",
            Nickname: "Pseudonim",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Wybierz pseudonim, ktry bdzie wywietlany w tabeli wynikw. Moesz go zmienia w dowolnym momencie.",
            Cancel: "Anuluj",
            Confirm: "Potwierd",
            Verifier: "Weryfikator",
            "User ID": "ID uytkownika",
            Profiles: "Profile",
            'Are you sure you would like to delete "{0}"?': 'Czy na pewno chcesz usun "{0}"?',
            Reset: "Resetuj",
            Apply: "Zastosuj",
            Gameplay: "Rozgrywka",
            Units: "Jednostki",
            Metric: "Metryczne",
            Imperial: "Imperialne",
            "Reset hint": "Resetuj wskazwk",
            Disabled: "Wyczone",
            Enabled: "Wczone",
            "Ghost car": "Duch samochodu",
            "Cockpit camera mode": "Tryb kamery kokpitu",
            Hold: "Przytrzymaj",
            Toggle: "Przecz",
            "Checkpoints position": "Pozycja punktw kontrolnych",
            "Timer position": "Pozycja timera",
            "Speedometer position": "Pozycja licznika prdkoci",
            Bottom: "D",
            Top: "Gra",
            Language: "Jzyk",
            Graphics: "Grafika",
            "Car shadow": "Cie samochodu",
            "Track shadow": "Cie trasy",
            Off: "Wycz",
            On: "Wcz",
            Low: "Niska",
            Medium: "rednia",
            High: "Wysoka",
            Clouds: "Chmury",
            Particles: "Czsteczki",
            Skidmarks: "lady opon",
            "Render scale": "Skala renderowania",
            "Anti-aliasing (requires restart)": "Anti-aliasing (wymaga restartu)",
            Audio: "Dwik",
            "Sound effect volume": "Gono efektw dwikowych",
            "Music volume": "Gono muzyki",
            "Checkpoint volume": "Gono punktw kontrolnych",
            Controls: "Sterowanie",
            "Vehicle accelerate": "Przyspiesz pojazd",
            "Vehicle brake": "Hamuj pojazd",
            "Vehicle turn left": "Skr pojazd w lewo",
            "Vehicle turn right": "Skr pojazd w prawo",
            "Vehicle reset": "Zresetuj pojazd",
            "Vehicle cockpit camera": "Kamera kokpitu pojazdu",
            "Hide UI": "Ukryj interfejs uytkownika",
            "Editor rotate part": "Obr cz w edytorze",
            "Editor height modifier": "Modyfikator wysokoci w edytorze",
            "Editor delete part": "Usu cz w edytorze",
            "Editor forwards": "Edytor do przodu",
            "Editor backwards": "Edytor do tyu",
            "Editor left": "Edytor w lewo",
            "Editor right": "Edytor w prawo",
            "Editor rotate left": "Obr edytor w lewo",
            "Editor rotate right": "Obr edytor w prawo",
            "Editor move down": "Przesu edytor w d",
            "Editor move up": "Przesu edytor w gr",
            "Editor test": "Test edytora",
            "Editor pick": "Wybr edytora",
            "Toggle FPS counter": "Przecz licznik FPS",
            "Toggle spectator camera": "Przecz kamer widza",
            "Spectator forwards": "Widz do przodu",
            "Spectator backwards": "Widz do tyu",
            "Spectator left": "Widz w lewo",
            "Spectator right": "Widz w prawo",
            "Spectator speed modifier": "Modyfikator prdkoci widza",
            "Press any key...\n\nPress [Escape] to cancel.": "Nacinij dowolny klawisz...\n\nNacinij [Escape], aby anulowa.",
            Clear: "Wyczy",
            "New record": "Nowy rekord",
            Record: "Rekord",
            Current: "Aktualny",
            Difference: "Rnica",
            Copy: "Kopiuj",
            Import: "Importuj",
            "Failed to import track": "Import trasy nie powid si",
            'The track "{0}" already exists. Do you wish to overwrite it?': "Trasa {0} ju istnieje. Czy chcesz j nadpisa?",
            Overwrite: "Nadpisz",
            "Paste track data here...": "Wklej dane trasy tutaj...",
            Rank: "Ranking",
            "No record": "Brak rekordu",
            "Standard tracks": "Standardowe trasy",
            "Custom tracks": "Niestandardowe trasy",
            'Are you sure you want to delete "{0}"?': "Czy na pewno chcesz usun {0}?",
            Delete: "Usu"
        }
          , MR = {
            Checkpoints: "Pontos de Verificao",
            "Checkpoint order": "Ordem dos Pontos de Verificao",
            Height: "Altura",
            Exit: "Sair",
            Random: "Aleatrio",
            Primary: "Principal",
            Secondary: "Secundrio",
            Frame: "Estrutura",
            Rims: "Aros",
            Test: "Testar",
            "Starting point is missing!": "Ponto de partida est faltando!",
            Generate: "Gerar",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Tem certeza de que deseja gerar uma nova pista?\n\nSua pista atual ser perdida!",
            Load: "Carregar",
            Save: "Salvar",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Tem certeza de que deseja carregar uma nova pista?\n\nSua pista atual ser perdida!",
            "Failed to save - Track name is needed!": "Falha ao salvar - Nome da pista  necessrio!",
            "Track saved!": "Pista salva!",
            "Failed to save!": "Falha ao salvar!",
            'Are you sure you want to overwrite "{0}"?': 'Tem certeza de que deseja sobrescrever "{0}"?',
            Export: "Exportar",
            "Failed to export - Track name is needed!": "Falha ao exportar - Nome da pista  necessrio!",
            "Track name": "Nome da pista",
            "Are you sure you want to exit the editor?": "Tem certeza de que deseja sair do editor?",
            "All unsaved data will be lost!": "Todos os dados no salvos sero perdidos!",
            "Press [{0}] or [{1}] to restart": "Pressione [{0}] ou [{1}] para reiniciar",
            "Press [{0}] to restart": "Pressione [{0}] para reiniciar",
            Leaderboard: "Quadro de Lderes",
            Back: "Voltar",
            "Error: Failed to load leaderboard": "Erro: Falha ao carregar o quadro de lderes",
            Verified: "Verificado",
            Invalid: "Invlido",
            Pending: "Pendente",
            Loading: "Carregando",
            "Failed to load recording": "Falha ao carregar a gravao",
            Ok: "Ok",
            "Track is missing starting point": "Pista est sem ponto de partida",
            "Failed to create user token.": "Falha ao criar o token do usurio.",
            "Leaderboard is disabled.": "O ranking est desativado.",
            "Please try another browser or device.": "Por favor, tente outro navegador ou dispositivo.",
            "Computer determinism check failed.": "Falha na verificao de determinismo do computador.",
            Customize: "Personalizar",
            Editor: "Editor",
            Settings: "Configuraes",
            Profile: "Perfil",
            Play: "Jogar",
            Version: "Verso",
            "You cannot have duplicate user profiles": "Voc no pode ter perfis de usurio duplicados",
            "Failed to create user profile": "Falha ao criar perfil de usurio",
            "This user profile does not exist on the server": "Este perfil de usurio no existe no servidor",
            "Failed to download user profile from the server": "Falha ao baixar perfil de usurio do servidor",
            "User token is invalid": "Token de usurio invlido",
            "Are you sure you want to display your private key?": "Tem certeza de que deseja exibir sua chave privada?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "NO COMPARTILHE ESTA CHAVE COM NINGUM.",
            "You need a free user profile slot to import a new user profile": "Voc precisa de um slot de perfil de usurio livre para importar um novo perfil de usurio",
            Nickname: "Apelido",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Escolha um apelido para ser exibido no quadro de lderes. Seu apelido pode ser alterado a qualquer momento.",
            Cancel: "Cancelar",
            Confirm: "Confirmar",
            Verifier: "Verificador",
            "User ID": "ID de Usurio",
            Profiles: "Perfis",
            'Are you sure you would like to delete "{0}"?': 'Tem certeza de que deseja excluir "{0}"?',
            Reset: "Redefinir",
            Apply: "Aplicar",
            Gameplay: "Jogabilidade",
            Units: "Unidades",
            Metric: "Mtrico",
            Imperial: "Imperial",
            "Reset hint": "Redefinir dica",
            Disabled: "Desativado",
            Enabled: "Ativado",
            "Ghost car": "Carro Fantasma",
            "Cockpit camera mode": "Modo de cmera do cockpit",
            Hold: "Manter",
            Toggle: "Alternar",
            "Checkpoints position": "Posio dos checkpoints",
            "Timer position": "Posio do temporizador",
            "Speedometer position": "Posio do velocmetro",
            Bottom: "Inferior",
            Top: "Superior",
            Language: "Idioma",
            Graphics: "Grficos",
            "Car shadow": "Sombra do Carro",
            "Track shadow": "Sombra da Pista",
            Off: "Desligado",
            On: "Ligado",
            Low: "Baixo",
            Medium: "Mdio",
            High: "Alto",
            Clouds: "Nuvens",
            Particles: "Partculas",
            Skidmarks: "Marcas de Derrapagem",
            "Render scale": "Escala de Renderizao",
            "Anti-aliasing (requires restart)": "Anti-aliasing (requer reincio)",
            Audio: "udio",
            "Sound effect volume": "Volume de Efeitos Sonoros",
            "Music volume": "Volume de Msica",
            "Checkpoint volume": "Volume dos Pontos de Verificao",
            Controls: "Controles",
            "Vehicle accelerate": "Acelerar Veculo",
            "Vehicle brake": "Freio do Veculo",
            "Vehicle turn left": "Virar  Esquerda",
            "Vehicle turn right": "Virar  Direita",
            "Vehicle reset": "Redefinir Veculo",
            "Vehicle cockpit camera": "Cmera Interna do Veculo",
            "Hide UI": "Esconder UI",
            "Editor rotate part": "Girar Pea do Editor",
            "Editor height modifier": "Modificador de Altura do Editor",
            "Editor delete part": "Excluir Pea do Editor",
            "Editor forwards": "Avanar no Editor",
            "Editor backwards": "Retroceder no Editor",
            "Editor left": "Mover  Esquerda no Editor",
            "Editor right": "Mover  Direita no Editor",
            "Editor rotate left": "Girar o editor para a esquerda",
            "Editor rotate right": "Girar o editor para a direita",
            "Editor move down": "Mover o editor para baixo",
            "Editor move up": "Mover o editor para cima",
            "Editor test": "Teste de editor",
            "Editor pick": "Escolha do editor",
            "Toggle FPS counter": "Alternar Contador de FPS",
            "Toggle spectator camera": "Alternar Cmera de Espectador",
            "Spectator forwards": "Avanar como Espectador",
            "Spectator backwards": "Retroceder como Espectador",
            "Spectator left": "Mover  Esquerda como Espectador",
            "Spectator right": "Mover  Direita como Espectador",
            "Spectator speed modifier": "Modificador de Velocidade do Espectador",
            "Press any key...\n\nPress [Escape] to cancel.": "Pressione qualquer tecla...\n\nPressione [Escape] para cancelar.",
            Clear: "Limpar",
            "New record": "Novo recorde",
            Record: "Recorde",
            Current: "Atual",
            Difference: "Diferena",
            Copy: "Copiar",
            Import: "Importar",
            "Failed to import track": "Falha ao importar a pista",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'A pista "{0}" j existe. Deseja sobrescrev-la?',
            Overwrite: "Sobrescrever",
            "Paste track data here...": "Cole os dados da pista aqui...",
            Rank: "Classificao",
            "No record": "Sem recorde",
            "Standard tracks": "Pistas Padro",
            "Custom tracks": "Pistas Personalizadas",
            'Are you sure you want to delete "{0}"?': 'Tem certeza de que deseja excluir "{0}"?',
            Delete: "Excluir"
        }
          , TR = {
            Checkpoints: "Pontos de Verificao",
            "Checkpoint order": "Ordem dos Pontos de Verificao",
            Height: "Altura",
            Exit: "Sair",
            Random: "Aleatrio",
            Primary: "Primrio",
            Secondary: "Secundrio",
            Frame: "Estrutura",
            Rims: "Aros",
            Test: "Testar",
            "Starting point is missing!": "Ponto de partida em falta!",
            Generate: "Gerar",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Tem a certeza de que deseja gerar uma nova pista?\n\nA pista atual ser perdida!",
            Load: "Carregar",
            Save: "Guardar",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Tem a certeza de que deseja carregar uma nova pista?\n\nA pista atual ser perdida!",
            "Failed to save - Track name is needed!": "Falha ao guardar -  necessrio um nome para a pista!",
            "Track saved!": "Pista guardada!",
            "Failed to save!": "Falha ao guardar!",
            'Are you sure you want to overwrite "{0}"?': 'Tem a certeza de que deseja substituir "{0}"?',
            Export: "Exportar",
            "Failed to export - Track name is needed!": "Falha ao exportar -  necessrio um nome para a pista!",
            "Track name": "Nome da pista",
            "Are you sure you want to exit the editor?": "Tem a certeza de que deseja sair do editor?",
            "All unsaved data will be lost!": "Todos os dados no guardados sero perdidos!",
            "Press [{0}] or [{1}] to restart": "Pressione [{0}] ou [{1}] para reiniciar",
            "Press [{0}] to restart": "Pressione [{0}] para reiniciar",
            Leaderboard: "Tabela de Classificao",
            Back: "Voltar",
            "Error: Failed to load leaderboard": "Erro: Falha ao carregar a tabela de classificao",
            Verified: "Verificado",
            Invalid: "Invlido",
            Pending: "Pendente",
            Loading: "A Carregar",
            "Failed to load recording": "Falha ao carregar a gravao",
            Ok: "Ok",
            "Track is missing starting point": "A pista no tem ponto de partida",
            "Failed to create user token.": "Falha ao criar o token de utilizador.",
            "Leaderboard is disabled.": "O leaderboard est desativado.",
            "Please try another browser or device.": "Por favor, tente outro navegador ou dispositivo.",
            "Computer determinism check failed.": "Falha na verificao de determinismo do computador.",
            Customize: "Personalizar",
            Editor: "Editor",
            Settings: "Definies",
            Profile: "Perfil",
            Play: "Jogar",
            Version: "Verso",
            "You cannot have duplicate user profiles": "No pode ter perfis de utilizador duplicados",
            "Failed to create user profile": "Falha ao criar o perfil de utilizador",
            "This user profile does not exist on the server": "Este perfil de utilizador no existe no servidor",
            "Failed to download user profile from the server": "Falha ao descarregar o perfil de utilizador do servidor",
            "User token is invalid": "Token de utilizador invlido",
            "Are you sure you want to display your private key?": "Tem a certeza de que pretende mostrar a sua chave privada?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "NO PARTILHE ESTA CHAVE COM NINGUM.",
            "You need a free user profile slot to import a new user profile": "Necessita de um slot de perfil de utilizador livre para importar um novo perfil de utilizador",
            Nickname: "Alcunha",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Escolha uma alcunha para ser exibida na tabela de classificao. A sua alcunha pode ser alterada a qualquer momento.",
            Cancel: "Cancelar",
            Confirm: "Confirmar",
            Verifier: "Verificador",
            "User ID": "ID de Utilizador",
            Profiles: "Perfis",
            'Are you sure you would like to delete "{0}"?': 'Tem a certeza de que pretende eliminar "{0}"?',
            Reset: "Repor",
            Apply: "Aplicar",
            Gameplay: "Jogabilidade",
            Units: "Unidades",
            Metric: "Mtrico",
            Imperial: "Imperial",
            "Reset hint": "Repor dica",
            Disabled: "Desativado",
            Enabled: "Ativado",
            "Ghost car": "Carro Fantasma",
            "Cockpit camera mode": "Modo da cmera de cabine",
            Hold: "Manter",
            Toggle: "Alternar",
            "Checkpoints position": "Posio dos checkpoints",
            "Timer position": "Posio do temporizador",
            "Speedometer position": "Posio do velocmetro",
            Bottom: "Inferior",
            Top: "Superior",
            Language: "Idioma",
            Graphics: "Grficos",
            "Car shadow": "Sombra do Carro",
            "Track shadow": "Sombra da Pista",
            Off: "Desligado",
            On: "Ligado",
            Low: "Baixo",
            Medium: "Mdio",
            High: "Alto",
            Clouds: "Nuvens",
            Particles: "Partculas",
            Skidmarks: "Marcas de Derrapagem",
            "Render scale": "Escala de Renderizao",
            "Anti-aliasing (requires restart)": "Anti-aliasing (necessita de reiniciar)",
            Audio: "udio",
            "Sound effect volume": "Volume dos Efeitos Sonoros",
            "Music volume": "Volume da Msica",
            "Checkpoint volume": "Volume dos Pontos de Verificao",
            Controls: "Controlos",
            "Vehicle accelerate": "Acelerar Veculo",
            "Vehicle brake": "Travar Veculo",
            "Vehicle turn left": "Virar  Esquerda",
            "Vehicle turn right": "Virar  Direita",
            "Vehicle reset": "Reiniciar Veculo",
            "Vehicle cockpit camera": "Cmara do Cockpit do Veculo",
            "Hide UI": "Esconder UI",
            "Editor rotate part": "Rodar Pea do Editor",
            "Editor height modifier": "Modificador de Altura do Editor",
            "Editor delete part": "Eliminar Pea do Editor",
            "Editor forwards": "Frente do Editor",
            "Editor backwards": "Trs do Editor",
            "Editor left": "Esquerda do Editor",
            "Editor right": "Direita do Editor",
            "Editor rotate left": "Rodar o editor para a esquerda",
            "Editor rotate right": "Rodar o editor para a direita",
            "Editor move down": "Mover o editor para baixo",
            "Editor move up": "Mover o editor para cima",
            "Editor test": "Teste de editor",
            "Editor pick": "Escolha do editor",
            "Toggle FPS counter": "Alternar Contador de FPS",
            "Toggle spectator camera": "Alternar Cmara de Espectador",
            "Spectator forwards": "Frente do Espectador",
            "Spectator backwards": "Trs do Espectador",
            "Spectator left": "Esquerda do Espectador",
            "Spectator right": "Direita do Espectador",
            "Spectator speed modifier": "Modificador de Velocidade do Espectador",
            "Press any key...\n\nPress [Escape] to cancel.": "Pressione qualquer tecla...\n\nPressione [Escape] para cancelar.",
            Clear: "Limpar",
            "New record": "Novo Recorde",
            Record: "Recorde",
            Current: "Atual",
            Difference: "Diferena",
            Copy: "Copiar",
            Import: "Importar",
            "Failed to import track": "Falha ao importar a pista",
            'The track "{0}" already exists. Do you wish to overwrite it?': 'A pista "{0}" j existe. Deseja substitu-la?',
            Overwrite: "Substituir",
            "Paste track data here...": "Cole os dados da pista aqui...",
            Rank: "Classificao",
            "No record": "Sem Registo",
            "Standard tracks": "Pistas Padro",
            "Custom tracks": "Pistas Personalizadas",
            'Are you sure you want to delete "{0}"?': 'Tem a certeza de que deseja eliminar "{0}"?',
            Delete: "Eliminar"
        }
          , kR = {
            Checkpoints: " ",
            "Checkpoint order": "  ",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "  !",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
            "Failed to save - Track name is needed!": "   -   !",
            "Track saved!": " !",
            "Failed to save!": "  !",
            'Are you sure you want to overwrite "{0}"?': ' ,    "{0}"?',
            Export: "",
            "Failed to export - Track name is needed!": "   -   !",
            "Track name": " ",
            "Are you sure you want to exit the editor?": " ,     ?",
            "All unsaved data will be lost!": "    !",
            "Press [{0}] or [{1}] to restart": " [{0}]  [{1}]  ",
            "Press [{0}] to restart": " [{0}]  ",
            Leaderboard: " ",
            Back: "",
            "Error: Failed to load leaderboard": ":     ",
            Verified: "",
            Invalid: "",
            Pending: " ",
            Loading: "",
            "Failed to load recording": "   ",
            Ok: "",
            "Track is missing starting point": "    ",
            "Failed to create user token.": "    .",
            "Leaderboard is disabled.": "  .",
            "Please try another browser or device.": ",     .",
            "Computer determinism check failed.": "    .",
            Customize: "",
            Editor: "",
            Settings: "",
            Profile: "",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "    ",
            "Failed to create user profile": "    ",
            "This user profile does not exist on the server": "      ",
            "Failed to download user profile from the server": "      ",
            "User token is invalid": "  ",
            "Are you sure you want to display your private key?": " ,      ?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "      .",
            "You need a free user profile slot to import a new user profile": "          ",
            Nickname: "",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": " ,      .       .",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": " ",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': ' ,    "{0}"?',
            Reset: "",
            Apply: "",
            Gameplay: " ",
            Units: " ",
            Metric: "",
            Imperial: "",
            "Reset hint": " ",
            Disabled: "",
            Enabled: "",
            "Ghost car": " ",
            "Cockpit camera mode": " ",
            Hold: "",
            Toggle: "",
            "Checkpoints position": "  ",
            "Timer position": " ",
            "Speedometer position": " ",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": " ",
            "Track shadow": " ",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: "  ",
            "Render scale": " ",
            "Anti-aliasing (requires restart)": " ( )",
            Audio: "",
            "Sound effect volume": "  ",
            "Music volume": " ",
            "Checkpoint volume": "  ",
            Controls: "",
            "Vehicle accelerate": " ",
            "Vehicle brake": " ",
            "Vehicle turn left": "  ",
            "Vehicle turn right": "  ",
            "Vehicle reset": " ",
            "Vehicle cockpit camera": "  ",
            "Hide UI": " ",
            "Editor rotate part": "   ",
            "Editor height modifier": "   ",
            "Editor delete part": "   ",
            "Editor forwards": "   ",
            "Editor backwards": "   ",
            "Editor left": "   ",
            "Editor right": "   ",
            "Editor rotate left": "  ",
            "Editor rotate right": "  ",
            "Editor move down": "  ",
            "Editor move up": "  ",
            "Editor test": " ",
            "Editor pick": " ",
            "Toggle FPS counter": "  FPS",
            "Toggle spectator camera": "  ",
            "Spectator forwards": "  ",
            "Spectator backwards": "  ",
            "Spectator left": "  ",
            "Spectator right": "  ",
            "Spectator speed modifier": "  ",
            "Press any key...\n\nPress [Escape] to cancel.": "  ...\n\n [Escape],  .",
            Clear: "",
            "New record": " ",
            Record: "",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "   ",
            'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}"  .   ?',
            Overwrite: "",
            "Paste track data here...": "   ...",
            Rank: "",
            "No record": " ",
            "Standard tracks": " ",
            "Custom tracks": " ",
            'Are you sure you want to delete "{0}"?': ' ,    "{0}"?',
            Delete: ""
        }
          , CR = {
            Checkpoints: "Kontroller",
            "Checkpoint order": "Kontrol noktas sras",
            Height: "Ykseklik",
            Exit: "k",
            Random: "Rastgele",
            Primary: "Birincil",
            Secondary: "kincil",
            Frame: "ereve",
            Rims: "Jantlar",
            Test: "Test",
            "Starting point is missing!": "Balang noktas eksik!",
            Generate: "Olutur",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "Yeni bir rota oluturmak istediinizden emin misiniz?\n\nMevcut rotanz kaybolacak!",
            Load: "Ykle",
            Save: "Kaydet",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "Yeni bir rota yklemek istediinizden emin misiniz?\n\nMevcut rotanz kaybolacak!",
            "Failed to save - Track name is needed!": "Kaydetme baarsz - Rota ad gerekiyor!",
            "Track saved!": "Rota kaydedildi!",
            "Failed to save!": "Kaydetme baarsz!",
            'Are you sure you want to overwrite "{0}"?': '"{0}" zerine yazmak istediinizden emin misiniz?',
            Export: "Da Aktar",
            "Failed to export - Track name is needed!": "Da aktarma baarsz - Rota ad gerekiyor!",
            "Track name": "Rota ad",
            "Are you sure you want to exit the editor?": "Editrden kmak istediinizden emin misiniz?",
            "All unsaved data will be lost!": "Tm kaydedilmemi veriler kaybolacak!",
            "Press [{0}] or [{1}] to restart": "Yeniden balatmak iin [{0}] veya [{1}] tuuna basn",
            "Press [{0}] to restart": "Yeniden balatmak iin [{0}] tuuna basn",
            Leaderboard: "Liderlik Tablosu",
            Back: "Geri",
            "Error: Failed to load leaderboard": "Hata: Liderlik tablosu yklenemedi",
            Verified: "Doruland",
            Invalid: "Geersiz",
            Pending: "Beklemede",
            Loading: "Ykleniyor",
            "Failed to load recording": "Kayt yklenemedi",
            Ok: "Tamam",
            "Track is missing starting point": "Rota balang noktas eksik",
            "Failed to create user token.": "Kullanc jetonu oluturulamad.",
            "Leaderboard is disabled.": "Liderlik tablosu devre d.",
            "Please try another browser or device.": "Ltfen baka bir tarayc veya cihaz deneyin.",
            "Computer determinism check failed.": "Bilgisayar belirlenim kontrol baarsz oldu.",
            Customize: "zelletir",
            Editor: "Editr",
            Settings: "Ayarlar",
            Profile: "Profil",
            Play: "Oyna",
            Version: "Srm",
            "You cannot have duplicate user profiles": "ift kullanc profili oluturamazsnz",
            "Failed to create user profile": "Kullanc profili oluturulamad",
            "This user profile does not exist on the server": "Bu kullanc profili sunucuda mevcut deil",
            "Failed to download user profile from the server": "Kullanc profili sunucudan indirilemedi",
            "User token is invalid": "Kullanc belirteci geersiz",
            "Are you sure you want to display your private key?": "Gizli anahtarnz gstermek istediinizden emin misiniz?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "BU ANAHTARI KMSEYLE PAYLAMAYIN.",
            "You need a free user profile slot to import a new user profile": "Yeni bir kullanc profili eklemek iin bo bir kullanc profili yuvasna ihtiyacnz var",
            Nickname: "Kullanc Ad",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "Liderlik tablosunda gsterilecek bir kullanc ad sein. Kullanc adnz istediiniz zaman deitirebilirsiniz.",
            Cancel: "ptal",
            Confirm: "Onayla",
            Verifier: "Dorulayc",
            "User ID": "Kullanc Kimlii",
            Profiles: "Profiller",
            'Are you sure you would like to delete "{0}"?': '"{0}" silmek istediinizden emin misiniz?',
            Reset: "Sfrla",
            Apply: "Uygula",
            Gameplay: "Oynan",
            Units: "Birimler",
            Metric: "Metrik",
            Imperial: "ngiliz",
            "Reset hint": "pucunu sfrla",
            Disabled: "Devre D",
            Enabled: "Etkin",
            "Ghost car": "Hayalet araba",
            "Cockpit camera mode": "Kokpit kamera modu",
            Hold: "Basl Tut",
            Toggle: "Deitir",
            "Checkpoints position": "Kontrol noktalar pozisyonu",
            "Timer position": "Kronometre pozisyonu",
            "Speedometer position": "Hz gstergesi pozisyonu",
            Bottom: "Alt",
            Top: "st",
            Language: "Dil",
            Graphics: "Grafikler",
            "Car shadow": "Araba glgesi",
            "Track shadow": "Rota glgesi",
            Off: "Kapal",
            On: "Ak",
            Low: "Dk",
            Medium: "Orta",
            High: "Yksek",
            Clouds: "Bulutlar",
            Particles: "Partikller",
            Skidmarks: "Lastik izleri",
            "Render scale": "Grnt lei",
            "Anti-aliasing (requires restart)": "Kenar yumuatma (yeniden balatma gerektirir)",
            Audio: "Ses",
            "Sound effect volume": "Ses efekti ses seviyesi",
            "Music volume": "Mzik ses seviyesi",
            "Checkpoint volume": "Kontrol noktas ses seviyesi",
            Controls: "Kontroller",
            "Vehicle accelerate": "Ara hzlandr",
            "Vehicle brake": "Ara fren",
            "Vehicle turn left": "Ara sola dn",
            "Vehicle turn right": "Ara saa dn",
            "Vehicle reset": "Ara sfrla",
            "Vehicle cockpit camera": "Ara kokpit kameras",
            "Hide UI": "UI' Gizle",
            "Editor rotate part": "Editr paray dndr",
            "Editor height modifier": "Editr ykseklik dzenleyici",
            "Editor delete part": "Editr para sil",
            "Editor forwards": "Editr ileri",
            "Editor backwards": "Editr geri",
            "Editor left": "Editr sola",
            "Editor right": "Editr saa",
            "Editor rotate left": "Editr sola dndr",
            "Editor rotate right": "Editr saa dndr",
            "Editor move down": "Editr aa ta",
            "Editor move up": "Editr yukar ta",
            "Editor test": "Editr testi",
            "Editor pick": "Editr seimi",
            "Toggle FPS counter": "FPS sayacn a/kapat",
            "Toggle spectator camera": "zleyici kamerasn a/kapat",
            "Spectator forwards": "zleyici ileri",
            "Spectator backwards": "zleyici geri",
            "Spectator left": "zleyici sola",
            "Spectator right": "zleyici saa",
            "Spectator speed modifier": "zleyici hz dzenleyici",
            "Press any key...\n\nPress [Escape] to cancel.": "Herhangi bir tua basn...\n\nptal etmek iin [Escape] tuuna basn",
            Clear: "Temizle",
            "New record": "Yeni kayt",
            Record: "Kayt",
            Current: "Mevcut",
            Difference: "Fark",
            Copy: "Kopyala",
            Import: "e Aktar",
            "Failed to import track": "Rota ie aktarma baarsz oldu",
            'The track "{0}" already exists. Do you wish to overwrite it?': '"{0}" rota zaten var. zerine yazmak istiyor musunuz?',
            Overwrite: "zerine yaz",
            "Paste track data here...": "Rota verilerini buraya yaptr...",
            Rank: "Sra",
            "No record": "Kayt yok",
            "Standard tracks": "Standart rotalar",
            "Custom tracks": "zel rotalar",
            'Are you sure you want to delete "{0}"?': '"{0}" silmek istediinizden emin misiniz?',
            Delete: "Sil"
        }
          , AR = {
            Checkpoints: " ",
            "Checkpoint order": "  ",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "  !",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": " ,     ?\n\n    !",
            "Failed to save - Track name is needed!": "   -    !",
            "Track saved!": " !",
            "Failed to save!": "  !",
            'Are you sure you want to overwrite "{0}"?': ' ,    "{0}"?',
            Export: "",
            "Failed to export - Track name is needed!": "   -    !",
            "Track name": " ",
            "Are you sure you want to exit the editor?": " ,     ?",
            "All unsaved data will be lost!": "     !",
            "Press [{0}] or [{1}] to restart": " [{0}]  [{1}]  ",
            "Press [{0}] to restart": " [{0}]  ",
            Leaderboard: " ",
            Back: "",
            "Error: Failed to load leaderboard": ":     ",
            Verified: "",
            Invalid: "",
            Pending: "  ",
            Loading: "",
            "Failed to load recording": "   ",
            Ok: "",
            "Track is missing starting point": "    ",
            "Failed to create user token.": "    .",
            "Leaderboard is disabled.": "  .",
            "Please try another browser or device.": " ,     .",
            "Computer determinism check failed.": "  '  .",
            Customize: "",
            Editor: "",
            Settings: "",
            Profile: "",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "      ",
            "Failed to create user profile": "    ",
            "This user profile does not exist on the server": "      ",
            "Failed to download user profile from the server": "      ",
            "User token is invalid": "  ",
            "Are you sure you want to display your private key?": " ,      ?",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "     .",
            "You need a free user profile slot to import a new user profile": "          ",
            Nickname: "",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "      .      - .",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": "ID ",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': ' ,    "{0}"?',
            Reset: "",
            Apply: "",
            Gameplay: " ",
            Units: " ",
            Metric: "",
            Imperial: "",
            "Reset hint": " ",
            Disabled: "",
            Enabled: "",
            "Ghost car": " ",
            "Cockpit camera mode": "  ",
            Hold: "",
            Toggle: "",
            "Checkpoints position": "  ",
            "Timer position": " ",
            "Speedometer position": "  ",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": " ",
            "Track shadow": " ",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: "",
            "Render scale": " ",
            "Anti-aliasing (requires restart)": " ( )",
            Audio: "",
            "Sound effect volume": "  ",
            "Music volume": " ",
            "Checkpoint volume": "  ",
            Controls: "",
            "Vehicle accelerate": " ",
            "Vehicle brake": " ",
            "Vehicle turn left": "  ",
            "Vehicle turn right": "  ",
            "Vehicle reset": " ",
            "Vehicle cockpit camera": "  ",
            "Hide UI": "  ",
            "Editor rotate part": "  ",
            "Editor height modifier": "  ",
            "Editor delete part": "  ",
            "Editor forwards": "  ",
            "Editor backwards": "  ",
            "Editor left": "  ",
            "Editor right": "  ",
            "Editor rotate left": "  ",
            "Editor rotate right": "  ",
            "Editor move down": "  ",
            "Editor move up": "  ",
            "Editor test": " ",
            "Editor pick": " ",
            "Toggle FPS counter": "  FPS",
            "Toggle spectator camera": "  ",
            "Spectator forwards": "  ",
            "Spectator backwards": "  ",
            "Spectator left": "  ",
            "Spectator right": "  ",
            "Spectator speed modifier": "  ",
            "Press any key...\n\nPress [Escape] to cancel.": " - ...\n\n [Escape],  .",
            Clear: "",
            "New record": " ",
            Record: "",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "   ",
            'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}"  .   ?',
            Overwrite: "",
            "Paste track data here...": "   ...",
            Rank: "",
            "No record": " ",
            "Standard tracks": " ",
            "Custom tracks": " ",
            'Are you sure you want to delete "{0}"?': ' ,    "{0}"?',
            Delete: ""
        }
          , PR = {
            Checkpoints: "",
            "Checkpoint order": "",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "\n\n",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "\n\n",
            "Failed to save - Track name is needed!": " - ",
            "Track saved!": "",
            "Failed to save!": "",
            'Are you sure you want to overwrite "{0}"?': ' "{0}" ',
            Export: "",
            "Failed to export - Track name is needed!": " - ",
            "Track name": "",
            "Are you sure you want to exit the editor?": "",
            "All unsaved data will be lost!": "",
            "Press [{0}] or [{1}] to restart": " [{0}]  [{1}] ",
            "Press [{0}] to restart": " [{0}] ",
            Leaderboard: "",
            Back: "",
            "Error: Failed to load leaderboard": "",
            Verified: "",
            Invalid: "",
            Pending: "",
            Loading: "",
            "Failed to load recording": "",
            Ok: "",
            "Track is missing starting point": "",
            "Failed to create user token.": "",
            "Leaderboard is disabled.": "",
            "Please try another browser or device.": "",
            "Computer determinism check failed.": "",
            Customize: "",
            Editor: "",
            Settings: "",
            Profile: "",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "",
            "Failed to create user profile": "",
            "This user profile does not exist on the server": "",
            "Failed to download user profile from the server": "",
            "User token is invalid": "",
            "Are you sure you want to display your private key?": "",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "",
            "You need a free user profile slot to import a new user profile": "",
            Nickname: "",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": "ID",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': ' "{0}" ',
            Reset: "",
            Apply: "",
            Gameplay: "",
            Units: "",
            Metric: "",
            Imperial: "",
            "Reset hint": "",
            Disabled: "",
            Enabled: "",
            "Ghost car": "",
            "Cockpit camera mode": "",
            Hold: "",
            Toggle: "",
            "Checkpoints position": "",
            "Timer position": "",
            "Speedometer position": "",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": "",
            "Track shadow": "",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: "",
            "Render scale": "",
            "Anti-aliasing (requires restart)": "",
            Audio: "",
            "Sound effect volume": "",
            "Music volume": "",
            "Checkpoint volume": "",
            Controls: "",
            "Vehicle accelerate": "",
            "Vehicle brake": "",
            "Vehicle turn left": "",
            "Vehicle turn right": "",
            "Vehicle reset": "",
            "Vehicle cockpit camera": "",
            "Hide UI": "",
            "Editor rotate part": "",
            "Editor height modifier": "",
            "Editor delete part": "",
            "Editor forwards": "",
            "Editor backwards": "",
            "Editor left": "",
            "Editor right": "",
            "Editor rotate left": "",
            "Editor rotate right": "",
            "Editor move down": "",
            "Editor move up": "",
            "Editor test": "",
            "Editor pick": "",
            "Toggle FPS counter": "FPS",
            "Toggle spectator camera": "",
            "Spectator forwards": "",
            "Spectator backwards": "",
            "Spectator left": "",
            "Spectator right": "",
            "Spectator speed modifier": "",
            "Press any key...\n\nPress [Escape] to cancel.": "...\n\n [Escape] ",
            Clear: "",
            "New record": "",
            Record: "",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "",
            'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}" ',
            Overwrite: "",
            "Paste track data here...": "...",
            Rank: "",
            "No record": "",
            "Standard tracks": "",
            "Custom tracks": "",
            'Are you sure you want to delete "{0}"?': ' "{0}" ',
            Delete: ""
        }
          , RR = {
            Checkpoints: "",
            "Checkpoint order": "",
            Height: "",
            Exit: "",
            Random: "",
            Primary: "",
            Secondary: "",
            Frame: "",
            Rims: "",
            Test: "",
            "Starting point is missing!": "",
            Generate: "",
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": "\n\n",
            Load: "",
            Save: "",
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": "\n\n",
            "Failed to save - Track name is needed!": " - ",
            "Track saved!": "",
            "Failed to save!": "",
            'Are you sure you want to overwrite "{0}"?': ' "{0}" ',
            Export: "",
            "Failed to export - Track name is needed!": " - ",
            "Track name": "",
            "Are you sure you want to exit the editor?": "",
            "All unsaved data will be lost!": "",
            "Press [{0}] or [{1}] to restart": " [{0}]  [{1}] ",
            "Press [{0}] to restart": " [{0}] ",
            Leaderboard: "",
            Back: "",
            "Error: Failed to load leaderboard": "",
            Verified: "",
            Invalid: "",
            Pending: "",
            Loading: "",
            "Failed to load recording": "",
            Ok: "",
            "Track is missing starting point": "",
            "Failed to create user token.": "",
            "Leaderboard is disabled.": "",
            "Please try another browser or device.": "",
            "Computer determinism check failed.": "",
            Customize: "",
            Editor: "",
            Settings: "",
            Profile: "",
            Play: "",
            Version: "",
            "You cannot have duplicate user profiles": "",
            "Failed to create user profile": "",
            "This user profile does not exist on the server": "",
            "Failed to download user profile from the server": "",
            "User token is invalid": "",
            "Are you sure you want to display your private key?": "",
            "DO NOT SHARE THIS KEY WITH ANYONE.": "",
            "You need a free user profile slot to import a new user profile": "",
            Nickname: "",
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": "",
            Cancel: "",
            Confirm: "",
            Verifier: "",
            "User ID": " ID",
            Profiles: "",
            'Are you sure you would like to delete "{0}"?': ' "{0}" ',
            Reset: "",
            Apply: "",
            Gameplay: "",
            Units: "",
            Metric: "",
            Imperial: "",
            "Reset hint": "",
            Disabled: "",
            Enabled: "",
            "Ghost car": "",
            "Cockpit camera mode": "",
            Hold: "",
            Toggle: "",
            "Checkpoints position": "",
            "Timer position": "",
            "Speedometer position": "",
            Bottom: "",
            Top: "",
            Language: "",
            Graphics: "",
            "Car shadow": "",
            "Track shadow": "",
            Off: "",
            On: "",
            Low: "",
            Medium: "",
            High: "",
            Clouds: "",
            Particles: "",
            Skidmarks: "",
            "Render scale": "",
            "Anti-aliasing (requires restart)": " ()",
            Audio: "",
            "Sound effect volume": "",
            "Music volume": "",
            "Checkpoint volume": "",
            Controls: "",
            "Vehicle accelerate": "",
            "Vehicle brake": "",
            "Vehicle turn left": "",
            "Vehicle turn right": "",
            "Vehicle reset": "",
            "Vehicle cockpit camera": "",
            "Hide UI": "",
            "Editor rotate part": "",
            "Editor height modifier": "",
            "Editor delete part": "",
            "Editor forwards": "",
            "Editor backwards": "",
            "Editor left": "",
            "Editor right": "",
            "Editor rotate left": "",
            "Editor rotate right": "",
            "Editor move down": "",
            "Editor move up": "",
            "Editor test": "",
            "Editor pick": "",
            "Toggle FPS counter": " FPS ",
            "Toggle spectator camera": "",
            "Spectator forwards": "",
            "Spectator backwards": "",
            "Spectator left": "",
            "Spectator right": "",
            "Spectator speed modifier": "",
            "Press any key...\n\nPress [Escape] to cancel.": "...\n\n [Escape] ",
            Clear: "",
            "New record": "",
            Record: "",
            Current: "",
            Difference: "",
            Copy: "",
            Import: "",
            "Failed to import track": "",
            'The track "{0}" already exists. Do you wish to overwrite it?': ' "{0}" ',
            Overwrite: "",
            "Paste track data here...": "...",
            Rank: "",
            "No record": "",
            "Standard tracks": "",
            "Custom tracks": "",
            'Are you sure you want to delete "{0}"?': ' "{0}" ',
            Delete: ""
        };
        var LR, IR, NR, UR, DR, BR = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        }, OR = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        };
        IR = new WeakMap,
        NR = new WeakMap,
        UR = new WeakMap,
        LR = new WeakSet,
        DR = function(e) {
            const t = BR(this, UR, "f").get(e);
            return null != t ? t : wR
        }
        ;
        const zR = class {
            constructor(e) {
                LR.add(this),
                IR.set(this, !1),
                NR.set(this, void 0),
                UR.set(this, new Map([["ar", gR], ["de-DE", vR], ["es-ES", yR], ["fr-FR", _R], ["it-IT", xR], ["ja-JP", bR], ["ko-KR", ER], ["pl-PL", SR], ["pt-BR", MR], ["pt-PT", TR], ["ru-RU", kR], ["tr-TR", CR], ["uk-UA", AR], ["zh-CN", PR], ["zh-TW", RR]])),
                OR(this, NR, BR(this, LR, "m", DR).call(this, e), "f")
            }
            set language(e) {
                OR(this, NR, BR(this, LR, "m", DR).call(this, e), "f")
            }
            get(e, t) {
                if (!(e in BR(this, NR, "f")))
                    return e;
                let n = BR(this, NR, "f")[e];
                return BR(this, IR, "f") && (n = "###"),
                null != t && t.forEach(((e,t)=>{
                    n = n.replace(new RegExp("\\{" + t + "\\}","g"), e)
                }
                )),
                n
            }
        }
        ;
        var FR = n(132)
          , WR = {};
        WR.styleTagTransform = u(),
        WR.setAttributes = l(),
        WR.insert = s().bind(null, "head"),
        WR.domAPI = r(),
        WR.insertStyleElement = h();
        t()(FR.Z, WR);
        FR.Z && FR.Z.locals && FR.Z.locals;
        var HR, VR, GR, jR, XR, qR, YR = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, ZR = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        HR = new WeakMap,
        VR = new WeakMap,
        GR = new WeakMap,
        jR = new WeakMap,
        XR = new WeakMap,
        qR = new WeakMap;
        const KR = class {
            constructor() {
                HR.set(this, void 0),
                VR.set(this, void 0),
                GR.set(this, void 0),
                jR.set(this, void 0),
                XR.set(this, void 0),
                qR.set(this, void 0),
                YR(this, HR, document.getElementById("ui"), "f"),
                YR(this, VR, document.createElement("div"), "f"),
                ZR(this, VR, "f").className = "input-visualizer",
                ZR(this, HR, "f").appendChild(ZR(this, VR, "f")),
                YR(this, GR, document.createElement("div"), "f"),
                ZR(this, GR, "f").className = "arrow-up",
                ZR(this, GR, "f").innerHTML = '<img src="images/arrow_up.svg">',
                ZR(this, VR, "f").appendChild(ZR(this, GR, "f")),
                YR(this, jR, document.createElement("div"), "f"),
                ZR(this, jR, "f").className = "arrow-right",
                ZR(this, jR, "f").innerHTML = '<img src="images/arrow_right.svg">',
                ZR(this, VR, "f").appendChild(ZR(this, jR, "f")),
                YR(this, XR, document.createElement("div"), "f"),
                ZR(this, XR, "f").className = "arrow-down",
                ZR(this, XR, "f").innerHTML = '<img src="images/arrow_down.svg">',
                ZR(this, VR, "f").appendChild(ZR(this, XR, "f")),
                YR(this, qR, document.createElement("div"), "f"),
                ZR(this, qR, "f").className = "arrow-left",
                ZR(this, qR, "f").innerHTML = '<img src="images/arrow_left.svg">',
                ZR(this, VR, "f").appendChild(ZR(this, qR, "f"))
            }
            dispose() {
                ZR(this, HR, "f").removeChild(ZR(this, VR, "f"))
            }
            update(e) {
                ZR(this, GR, "f").className = e.up ? "active arrow-up" : "arrow-up",
                ZR(this, jR, "f").className = e.right ? "active arrow-right" : "arrow-right",
                ZR(this, XR, "f").className = e.down ? "active arrow-down" : "arrow-down",
                ZR(this, qR, "f").className = e.left ? "active arrow-left" : "arrow-left"
            }
        }
        ;
        var JR = n(521)
          , QR = {};
        QR.styleTagTransform = u(),
        QR.setAttributes = l(),
        QR.insert = s().bind(null, "head"),
        QR.domAPI = r(),
        QR.insertStyleElement = h();
        t()(JR.Z, QR);
        JR.Z && JR.Z.locals && JR.Z.locals;
        var $R, eL, tL, nL, iL, rL, aL, sL, oL, lL, cL, hL, dL, uL, pL, fL = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, mL = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        eL = new WeakMap,
        tL = new WeakMap,
        nL = new WeakMap,
        iL = new WeakMap,
        rL = new WeakMap,
        aL = new WeakMap,
        sL = new WeakMap,
        oL = new WeakMap,
        lL = new WeakMap,
        cL = new WeakMap,
        hL = new WeakMap,
        dL = new WeakMap,
        $R = new WeakSet,
        uL = function(e) {
            const t = mL(this, rL, "f").getBoundingClientRect()
              , n = (e.clientX - t.left) / (t.width - 8)
              , i = new vd(Math.max(0, Math.floor(n * mL(this, lL, "f").time * 1e3)));
            mL(this, tL, "f").call(this, i)
        }
        ,
        pL = function() {
            mL(this, oL, "f") ? mL(this, iL, "f").innerHTML = '<img src="images/play.svg">' : mL(this, iL, "f").innerHTML = '<img src="images/pause.svg">'
        }
        ;
        const gL = class {
            constructor(e, t, n, i) {
                $R.add(this),
                eL.set(this, void 0),
                tL.set(this, void 0),
                nL.set(this, void 0),
                iL.set(this, void 0),
                rL.set(this, void 0),
                aL.set(this, void 0),
                sL.set(this, void 0),
                oL.set(this, void 0),
                lL.set(this, void 0),
                cL.set(this, !1),
                hL.set(this, void 0),
                dL.set(this, void 0),
                fL(this, oL, i, "f"),
                fL(this, eL, document.getElementById("ui"), "f"),
                fL(this, tL, n, "f"),
                fL(this, lL, t, "f"),
                fL(this, nL, document.createElement("div"), "f"),
                mL(this, nL, "f").className = "time-bar",
                mL(this, eL, "f").appendChild(mL(this, nL, "f")),
                fL(this, iL, document.createElement("button"), "f"),
                mL(this, iL, "f").className = "button",
                mL(this, iL, "f").addEventListener("click", (()=>{
                    e.playUIClick(),
                    this.isPaused = !this.isPaused
                }
                )),
                mL(this, nL, "f").appendChild(mL(this, iL, "f")),
                mL(this, $R, "m", pL).call(this),
                fL(this, rL, document.createElement("div"), "f"),
                mL(this, rL, "f").className = "bar",
                mL(this, rL, "f").addEventListener("pointerdown", (e=>{
                    fL(this, cL, !0, "f"),
                    mL(this, $R, "m", uL).call(this, e)
                }
                )),
                window.addEventListener("pointermove", fL(this, hL, (e=>{
                    mL(this, cL, "f") && mL(this, $R, "m", uL).call(this, e)
                }
                ), "f")),
                window.addEventListener("pointerup", fL(this, dL, (e=>{
                    mL(this, cL, "f") && (fL(this, cL, !1, "f"),
                    mL(this, $R, "m", uL).call(this, e))
                }
                ), "f")),
                mL(this, nL, "f").appendChild(mL(this, rL, "f"));
                const r = document.createElement("div");
                if (mL(this, rL, "f").appendChild(r),
                fL(this, aL, document.createElement("div"), "f"),
                mL(this, aL, "f").className = "unloaded-fill",
                r.appendChild(mL(this, aL, "f")),
                fL(this, sL, document.createElement("div"), "f"),
                mL(this, sL, "f").className = "fill",
                r.appendChild(mL(this, sL, "f")),
                mL(this, lL, "f").time < 1e4) {
                    let e, t;
                    mL(this, lL, "f").time > 2e3 ? (e = 60,
                    t = 600) : mL(this, lL, "f").time > 200 ? (e = 10,
                    t = 60) : (e = 1,
                    t = 10);
                    for (let n = e; n < mL(this, lL, "f").time; n += e) {
                        const e = document.createElement("div");
                        e.className = n % t == 0 ? "dash long" : "dash",
                        e.style.left = "calc(" + n / mL(this, lL, "f").time * 100 + "% - 1px)",
                        r.appendChild(e)
                    }
                }
            }
            dispose() {
                mL(this, eL, "f").removeChild(mL(this, nL, "f")),
                window.removeEventListener("pointermove", mL(this, hL, "f")),
                window.removeEventListener("pointerup", mL(this, dL, "f"))
            }
            get isDragging() {
                return mL(this, cL, "f")
            }
            get isPaused() {
                return mL(this, oL, "f")
            }
            set isPaused(e) {
                fL(this, oL, e, "f"),
                mL(this, $R, "m", pL).call(this)
            }
            set time(e) {
                null == mL(this, lL, "f") ? mL(this, sL, "f").style.visibility = "hidden" : (mL(this, sL, "f").style.width = "calc(8px + " + e.numberOfFrames / mL(this, lL, "f").numberOfFrames * 100 + "%)",
                0 == e.numberOfFrames ? mL(this, sL, "f").style.visibility = "hidden" : mL(this, sL, "f").style.visibility = "visible")
            }
            set loadedTime(e) {
                null == mL(this, lL, "f") ? mL(this, aL, "f").style.visibility = "hidden" : (mL(this, aL, "f").style.width = "calc(8px + " + 100 * (1 - e.numberOfFrames / mL(this, lL, "f").numberOfFrames) + "%)",
                e.numberOfFrames >= mL(this, lL, "f").numberOfFrames ? mL(this, aL, "f").style.visibility = "hidden" : mL(this, aL, "f").style.visibility = "visible")
            }
        }
        ;
        var vL = n(923)
          , wL = {};
        wL.styleTagTransform = u(),
        wL.setAttributes = l(),
        wL.insert = s().bind(null, "head"),
        wL.domAPI = r(),
        wL.insertStyleElement = h();
        t()(vL.Z, wL);
        vL.Z && vL.Z.locals && vL.Z.locals;
        var yL, _L, xL = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, bL = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        yL = new WeakMap,
        _L = new WeakMap;
        const EL = class {
            constructor(e, t, n) {
                yL.set(this, void 0),
                _L.set(this, void 0),
                xL(this, yL, document.getElementById("ui"), "f"),
                xL(this, _L, document.createElement("div"), "f"),
                bL(this, _L, "f").className = "preview-toolbar";
                const i = document.createElement("button");
                i.className = "button",
                i.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                i.append(document.createTextNode(t.get("Exit"))),
                i.addEventListener("click", (()=>{
                    e.playUIClick(),
                    n()
                }
                )),
                bL(this, _L, "f").appendChild(i),
                bL(this, yL, "f").appendChild(bL(this, _L, "f"))
            }
            dispose() {
                bL(this, yL, "f").removeChild(bL(this, _L, "f"))
            }
        }
        ;
        var SL, ML, TL, kL, CL, AL, PL, RL, LL, IL, NL, UL, DL, BL, OL, zL, FL, WL, HL, VL, GL, jL, XL, qL, YL, ZL = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, KL = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        ML = new WeakMap,
        TL = new WeakMap,
        kL = new WeakMap,
        CL = new WeakMap,
        AL = new WeakMap,
        PL = new WeakMap,
        RL = new WeakMap,
        LL = new WeakMap,
        IL = new WeakMap,
        NL = new WeakMap,
        UL = new WeakMap,
        DL = new WeakMap,
        BL = new WeakMap,
        OL = new WeakMap,
        zL = new WeakMap,
        FL = new WeakMap,
        WL = new WeakMap,
        HL = new WeakMap,
        VL = new WeakMap,
        GL = new WeakMap,
        jL = new WeakMap,
        XL = new WeakMap,
        SL = new WeakSet,
        qL = function(e) {
            var t, n, i, r, a;
            e ? (ZL(this, FL, new gL(KL(this, CL, "f"),KL(this, RL, "f").time,(e=>{
                var t, n, i;
                ZL(this, DL, Math.max(0, Math.min(KL(this, BL, "f"), e.time)), "f");
                const r = Math.floor(1e3 * KL(this, DL, "f"));
                KL(this, SL, "m", YL).call(this, r),
                KL(this, NL, "f").update(0),
                null != KL(this, FL, "f") && (KL(this, FL, "f").time = new vd(r)),
                null === (t = KL(this, HL, "f")) || void 0 === t || t.update(KL(this, NL, "f").getControls()),
                null === (n = KL(this, VL, "f")) || void 0 === n || n.update(KL(this, NL, "f")),
                null === (i = KL(this, GL, "f")) || void 0 === i || i.update(KL(this, NL, "f"))
            }
            ),KL(this, UL, "f")), "f"),
            ZL(this, WL, new EL(KL(this, CL, "f"),KL(this, AL, "f"),KL(this, LL, "f")), "f"),
            ZL(this, HL, new KR, "f"),
            ZL(this, VL, new Lb(KL(this, PL, "f")), "f"),
            KL(this, VL, "f").setOverridePosition(!1),
            ZL(this, GL, new xy(KL(this, AL, "f"),KL(this, PL, "f"),null,!0), "f"),
            KL(this, GL, "f").setOverridePosition(!1)) : (null === (t = KL(this, FL, "f")) || void 0 === t || t.dispose(),
            ZL(this, FL, null, "f"),
            null === (n = KL(this, WL, "f")) || void 0 === n || n.dispose(),
            ZL(this, WL, null, "f"),
            null === (i = KL(this, HL, "f")) || void 0 === i || i.dispose(),
            ZL(this, HL, null, "f"),
            null === (r = KL(this, VL, "f")) || void 0 === r || r.dispose(),
            ZL(this, VL, null, "f"),
            null === (a = KL(this, GL, "f")) || void 0 === a || a.dispose(),
            ZL(this, GL, null, "f"))
        }
        ,
        YL = function(e) {
            const t = KL(this, IL, "f").getFrame(e);
            null != t && KL(this, NL, "f").setCarState(t)
        }
        ;
        const JL = class {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                SL.add(this),
                ML.set(this, void 0),
                TL.set(this, void 0),
                kL.set(this, void 0),
                CL.set(this, void 0),
                AL.set(this, void 0),
                PL.set(this, void 0),
                RL.set(this, void 0),
                LL.set(this, void 0),
                IL.set(this, void 0),
                NL.set(this, void 0),
                UL.set(this, !1),
                DL.set(this, 0),
                BL.set(this, 0),
                OL.set(this, void 0),
                zL.set(this, !0),
                FL.set(this, void 0),
                WL.set(this, void 0),
                HL.set(this, void 0),
                VL.set(this, void 0),
                GL.set(this, void 0),
                jL.set(this, void 0),
                XL.set(this, void 0),
                ZL(this, ML, t, "f"),
                ZL(this, TL, i, "f"),
                ZL(this, kL, r, "f"),
                ZL(this, CL, a, "f"),
                ZL(this, AL, s, "f"),
                ZL(this, PL, o, "f"),
                ZL(this, RL, l, "f"),
                ZL(this, LL, c, "f"),
                t.loadTrackData(n),
                t.generateMeshes(),
                i.generateMountains(t.getBounds());
                const h = t.getStartTransform();
                if (null == h)
                    throw "Track has no starting point";
                ZL(this, IL, new OE, "f");
                const d = e.createCar(h, KL(this, TL, "f").getMountainVertices(), KL(this, TL, "f").getMountainOffset(), KL(this, ML, "f").getTrackData(), l.recording, (e=>{
                    KL(this, IL, "f").push(e)
                }
                ));
                KL(this, IL, "f").push(d),
                e.startCar(d.id, l.time),
                ZL(this, BL, l.time.time, "f"),
                ZL(this, NL, new Jm(null,h,l.recording,null,!0,r,a,i,t,o), "f"),
                KL(this, NL, "f").setColors(l.carColors),
                r.setCamera(KL(this, NL, "f").cameraOrbit),
                ZL(this, OL, new vE(o), "f"),
                KL(this, OL, "f").addToggleListener((e=>{
                    e ? r.setCamera(KL(this, OL, "f").camera) : null != KL(this, NL, "f") && r.setCamera(KL(this, NL, "f").cameraOrbit)
                }
                )),
                KL(this, SL, "m", qL).call(this, !0),
                window.addEventListener("keydown", ZL(this, jL, (e=>{
                    if (KL(this, OL, "f").enabled || ("Escape" == e.code ? (c(),
                    e.preventDefault()) : o.checkKeyBinding(e, Xw.VehicleReset) ? (ZL(this, DL, 0, "f"),
                    e.preventDefault()) : KL(this, PL, "f").checkKeyBinding(e, Xw.VehicleCockpitCamera) && (e.repeat || null == KL(this, NL, "f") || KL(this, NL, "f").hasFinished() || (KL(this, PL, "f").getSettingBoolean(uc.CockpitCameraToggle) ? KL(this, kL, "f").camera == KL(this, NL, "f").cameraOrbit ? KL(this, kL, "f").setCamera(KL(this, NL, "f").cameraCockpit) : KL(this, kL, "f").setCamera(KL(this, NL, "f").cameraOrbit) : KL(this, kL, "f").setCamera(KL(this, NL, "f").cameraCockpit)),
                    e.preventDefault())),
                    o.checkKeyBinding(e, Xw.ToggleUI) && (ZL(this, zL, !KL(this, zL, "f"), "f"),
                    KL(this, SL, "m", qL).call(this, KL(this, zL, "f")),
                    e.preventDefault()),
                    o.checkKeyBinding(e, Xw.ToggleSpectatorCamera)) {
                        KL(this, OL, "f").camera.position.copy(KL(this, kL, "f").camera.position);
                        const t = new Kt(0,0,0,"YXZ").setFromQuaternion(KL(this, kL, "f").camera.quaternion);
                        t.z = 0,
                        KL(this, OL, "f").camera.quaternion.setFromEuler(t),
                        KL(this, OL, "f").toggle(),
                        e.preventDefault()
                    }
                    "Space" == e.code && (ZL(this, UL, !KL(this, UL, "f"), "f"),
                    null != KL(this, FL, "f") && (KL(this, FL, "f").isPaused = KL(this, UL, "f")),
                    e.preventDefault())
                }
                ), "f")),
                window.addEventListener("keyup", ZL(this, XL, (e=>{
                    KL(this, OL, "f").enabled || KL(this, PL, "f").checkKeyBinding(e, Xw.VehicleCockpitCamera) && (KL(this, NL, "f").hasFinished() || KL(this, PL, "f").getSettingBoolean(uc.CockpitCameraToggle) || KL(this, kL, "f").setCamera(KL(this, NL, "f").cameraOrbit))
                }
                ), "f"))
            }
            dispose() {
                KL(this, ML, "f").clear(),
                KL(this, TL, "f").clearMountains(),
                KL(this, NL, "f").dispose(),
                KL(this, SL, "m", qL).call(this, !1),
                window.removeEventListener("keydown", KL(this, jL, "f")),
                window.removeEventListener("keyup", KL(this, XL, "f"))
            }
            update(e) {
                var t, n, i, r;
                let a;
                if (null != KL(this, FL, "f") && ZL(this, UL, KL(this, FL, "f").isPaused, "f"),
                KL(this, UL, "f") || (null === (t = KL(this, FL, "f")) || void 0 === t ? void 0 : t.isDragging))
                    a = 0,
                    KL(this, NL, "f").audioVolume = 0;
                else {
                    a = e,
                    KL(this, NL, "f").audioVolume = 1,
                    ZL(this, DL, Math.min(KL(this, BL, "f"), KL(this, DL, "f") + e), "f"),
                    KL(this, DL, "f") == KL(this, BL, "f") && (null != KL(this, FL, "f") && (KL(this, FL, "f").isPaused = !0),
                    ZL(this, UL, !0, "f"));
                    const t = Math.floor(1e3 * KL(this, DL, "f"))
                      , n = Math.min(t, KL(this, IL, "f").getLastFrame().numberOfFrames);
                    if (n < KL(this, NL, "f").getTotalTime().numberOfFrames || n > KL(this, NL, "f").getTotalTime().numberOfFrames + 1e3)
                        KL(this, SL, "m", YL).call(this, n);
                    else {
                        for (let e = KL(this, NL, "f").getTotalTime().numberOfFrames + 1; e <= n; e++)
                            KL(this, SL, "m", YL).call(this, e)
                    }
                }
                null != KL(this, FL, "f") && (KL(this, FL, "f").time = KL(this, NL, "f").getTotalTime(),
                KL(this, FL, "f").loadedTime = KL(this, IL, "f").getLastFrame()),
                null === (n = KL(this, HL, "f")) || void 0 === n || n.update(KL(this, NL, "f").getControls()),
                null === (i = KL(this, VL, "f")) || void 0 === i || i.update(KL(this, NL, "f")),
                null === (r = KL(this, GL, "f")) || void 0 === r || r.update(KL(this, NL, "f")),
                KL(this, NL, "f").update(a),
                KL(this, OL, "f").update(e),
                KL(this, kL, "f").update(KL(this, NL, "f").getPosition()),
                KL(this, CL, "f").update(e, !1, KL(this, kL, "f"), KL(this, PL, "f"))
            }
        }
        ;
        var QL, $L, eI = function(e, t, n, i, r) {
            if ("m" === i)
                throw new TypeError("Private method is not writable");
            if ("a" === i && !r)
                throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof t ? e !== t || !r : !t.has(e))
                throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
            n
        }, tI = function(e, t, n, i) {
            if ("a" === n && !i)
                throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
        };
        QL = new WeakMap,
        $L = new WeakMap;
        const nI = class {
            constructor() {
                QL.set(this, !1),
                $L.set(this, []),
                window.addEventListener("touchstart", (()=>{
                    eI(this, QL, !0, "f"),
                    tI(this, $L, "f").forEach((e=>e(tI(this, QL, "f"))))
                }
                )),
                window.addEventListener("keydown", (()=>{
                    eI(this, QL, !1, "f"),
                    tI(this, $L, "f").forEach((e=>e(tI(this, QL, "f"))))
                }
                ))
            }
            get touchEnabled() {
                return tI(this, QL, "f")
            }
            addChangeListener(e) {
                tI(this, $L, "f").push(e),
                e(tI(this, QL, "f"))
            }
            removeChangeListener(e) {
                const t = tI(this, $L, "f").indexOf(e);
                t >= 0 && tI(this, $L, "f").splice(t, 1)
            }
        }
        ;
        /**
 * @license
 * Copyright 2023 Kodub.com
 */
        Ye.enabled = !1,
        function() {
            const e = new PC;
            e.preloadImage("images/apply.svg"),
            e.preloadImage("images/arrow_down.svg"),
            e.preloadImage("images/arrow_up.svg"),
            e.preloadImage("images/back.svg"),
            e.preloadImage("images/cancel.svg"),
            e.preloadImage("images/clouds.jpg"),
            e.preloadImage("images/copy.svg"),
            e.preloadImage("images/customize.svg"),
            e.preloadImage("images/editor.svg"),
            e.preloadImage("images/erase.svg"),
            e.preloadImage("images/export.svg"),
            e.preloadImage("images/helmet.svg"),
            e.preloadImage("images/import.svg"),
            e.preloadImage("images/load.svg"),
            e.preloadImage("images/logo.svg"),
            e.preloadImage("images/pause.svg"),
            e.preloadImage("images/play.svg"),
            e.preloadImage("images/preview.svg"),
            e.preloadImage("images/quit.svg"),
            e.preloadImage("images/random.svg"),
            e.preloadImage("images/reset_settings.svg"),
            e.preloadImage("images/save.svg"),
            e.preloadImage("images/settings.svg"),
            e.preloadImage("images/smoke.png"),
            e.preloadImage("images/state_invalid.svg"),
            e.preloadImage("images/state_pending.svg"),
            e.preloadImage("images/state_verified.svg"),
            e.preloadImage("images/test.svg");
            const t = new cA
              , n = new aP
              , i = new Sc(e);
            i.load("music", ["audio/music.mp3", "audio/music.flac"]),
            i.load("click", ["audio/click.flac"]),
            i.load("engine", ["audio/engine.flac"]),
            i.load("suspension", ["audio/suspension.flac"]),
            i.load("tires", ["audio/tires.flac"]),
            i.load("collision", ["audio/collision.flac"]),
            i.load("skidding", ["audio/skidding.flac"]),
            i.load("editor_edit", ["audio/editor_edit.flac"]),
            i.load("checkpoint", ["audio/checkpoint.flac"]),
            i.load("finish", ["audio/checkpoint.flac"]),
            Jh.initResources(e),
            Jm.initResources(e),
            ww.initResources(e);
            const r = new sA(e)
              , a = new YA;
            a.migrate(r),
            e.addResource();
            const s = new PP(r,e)
              , o = new PP(r,e);
            s.testDeterminism().then((t=>{
                d.submitAllowed = t,
                e.loadedResource()
            }
            ));
            const l = new yP(a)
              , c = new zR(l.getSetting(uc.Language))
              , h = new TA(a)
              , d = new dP(h);
            h.syncUserProfile(d);
            const u = new FC(a,d,h)
              , p = document.getElementById("screen")
              , f = new jS(p,l)
              , m = new fA(f,l,e)
              , g = new sM(f)
              , v = new cw(f,l,r)
              , w = new KC(e,r,a)
              , y = new vv
              , _ = new EC(i)
              , x = new nI
              , b = ()=>{
                t.trigger((()=>{
                    C.dispose(),
                    C = new cC(s,v,r,g,w,c,_,h,u,f,i,a,l,d,e,E,S,M,T,k)
                }
                ))
            }
              , E = ()=>{
                t.trigger((()=>{
                    C.dispose(),
                    C = new lv(s,c,v,g,f,i,h,l,d,b)
                }
                ))
            }
              , S = ()=>{
                t.trigger((()=>{
                    C.dispose();
                    const p = C = new Yx(v,r,c,i,f,l,t,h,u,a,w,_,x,(()=>{
                        C.dispose(),
                        C = new cC(s,v,r,g,w,c,_,h,u,f,i,a,l,d,e,E,S,M,T,k)
                    }
                    ),((e,t,r)=>{
                        const a = C = new IS(s,o,v,g,c,f,i,h,l,n,x,e,t,{
                            recording: null,
                            carColors: null,
                            name: null,
                            time: null,
                            isSelf: !0
                        },null,(()=>{}
                        ),(()=>{
                            a.dispose(!1),
                            C = p,
                            r()
                        }
                        ))
                    }
                    ))
                }
                ))
            }
              , M = (e,a,d)=>{
                t.trigger((()=>{
                    C.dispose();
                    const t = h.profileSlot
                      , p = u.getRecordTime(t, a.getId(r));
                    C = new IS(s,o,v,g,c,f,i,h,l,n,x,e,a,d,p,((e,n,i,r)=>{
                        if (null != e) {
                            const a = u.getRecordTime(t, e);
                            (null == a || i.lessThan(a)) && u.setRecord(t, e, i, n, r)
                        }
                    }
                    ),b)
                }
                ))
            }
              , T = (e,n)=>{
                t.trigger((()=>{
                    C.dispose(),
                    C = new JL(s,v,e,g,f,i,c,l,n,b)
                }
                ))
            }
              , k = n=>{
                t.trigger((()=>{
                    C.dispose(),
                    C = new mR(i,f,d,w,r,l,e,n,b)
                }
                ))
            }
            ;
            let C = new cC(s,v,r,g,w,c,_,h,u,f,i,a,l,d,e,E,S,M,T,k)
              , A = 0;
            f.setAnimationLoop((function(e) {
                const t = Math.max(e - A, 0) / 1e3;
                A = e,
                C.update(t),
                m.update(t, f.camera),
                g.update(),
                y.update(t)
            }
            )),
            window.addEventListener("keyup", (function(e) {
                l.checkKeyBinding(e, Xw.ToggleFpsCounter) && y.toggle()
            }
            ))
        }()
    }
    )()
}
)();
